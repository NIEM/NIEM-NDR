# -*-org-*-

* stack: add to top
* Tasks & issues: sort first to top
- [-] allow @fixed
  - [X] investigate valid / invalid use cases
  - [ ] get tests running
  - [ ] check rules
- [ ] add Schematron for rules without Schematron
- [ ] eliminate use of the root() function, since it breaks contesa
- [ ] add check: any component in the target namespace MUST be declared within the schema
- [ ] break up huge opening phrases rule
- [ ] id / ref / @uri resolution & unification
- [ ] Lighten EXT structural rules
- [ ] use MACRO_REPRESENTATION_TERM_QUANTITY, and the other like macros, universally across the document. They're only used in some places.
** completed tasks: put new at bottom
- [X] rebuild the make system
  - [X] Replace the delegated makefile with a single makefile that blocks off unwanted operations in ifneq/endif blocks.
- [X] set up doc version for rc release
- [X] sync doc with NIEM 4 release
  - [X] checkout niem release to NDR place
  - [X] ensure files are same as NIEM release
    - [X] structures
    - [X] appinfo
  - [X] update instances to validate vs release
  - [X] update schema examples to release
- [X] add REF rule: thing with representation term "Abstract" must be @abstract=true
- [X] Stand up testing
- [X] Lighten naming rules from MUST to SHOULD
  - [X] Rule 7-5. Component name follows ISO 11179 Part 5 Annex A
  - [X] Rule 10-55. Component name follows pattern
  - [X] Rule 10-62. Element with simple content has representation term
  - [X] Rule 10-63. Name has representation term when appropriate
  - [X] Rule 10-64. Name has representation term only when appropriate
  - [X] Rule 11-16. Name of element declaration with simple content has representation term
  - [X] Rule 11-17. Name of element declaration with simple content has representation term
  - [X] Rule 11-20. Attribute name uses representation term
  - [X] Additional name lightening changes:
    - [X] rule 11-9 Name of a code simple type has standard suffix lightened to SHOULD
    - [X] rule 11-10 "code simple type has enumerations" lightened
  - [X] Rule 10-17. Name of code type ends in CodeType
  - [X] Rule 11-9 Name of a code simple type has standard suffix
- [X] Turn off always-firing warning rules
- [X] stand up NIEM 4 subset schema for validation
- [X] Add rule for *Code elements and attributes
  - [X] add rule that element of CodeType should be *Code
  - [X] add rule that attribute of CodeSimpleType should be *Code
- [X] Handwave to code lists specification @ code type, code simple type, to explain to someone how she might specify that code types have codes.

* Agendas: discuss with:
** NTAC
*** code updates:
**** complex: 
- updated definition of "code type"
  - to: A code type is a NIEM object type for which each simple value carried by the type corresponds to an entry in a list of distinct conceptual entities.
  - from: A code type is a NIEM object type with a content model that is constrained by one or more enumeration facets.
- rule 10-17: Name of code type ends in CodeType
  - from: bidirectional: A complex type definition MUST have a {name} that ends in 'CodeType' if and only if it has a {base type definition} of a code type or code simple type.
  - to: one-directional: A complex type definition a {base type definition} of a code type or code simple type SHOULD have a {name} that ends in 'CodeType'.
- new: Rule 10-18. Code type corresponds to a code list
  - [Rule 10-18] (REF, EXT) (Constraint)
    - A complex type SHOULD have a name ending in CodeType if and only if it has a correspondence to a list of distinct conceptual entities.
****  simple 
    - new definition of "code simple type":
      - to: A code simple type is a simple type definition schema component for which each value carried by the type corresponds to an entry in a list of distinct conceptual entities.
      - from: A code simple type is a simple type definition schema component that is constrained by one or more enumeration facets.
  - new rule (currently 11-10):
    - Rule 11-10. (REF, EXT) (Constraint) Code simple type corresponds to a code list
      - A simple type SHOULD have a name ending in CodeSimpleType if and only if it has a correspondence to a list of distinct conceptual entities.
    - stands down old rule 11-10: Code simple type has enumerations
*** removed always-firing schematron rules
- Schema is CTAS-conformant
- Document is a schema document
- Document uses XML namespaces properly
- Target namespace is absolute URI
- Document is an XML document
** CDM
- [ ] Did Representations get screwed up? Now they're "RepresentationAbstract"?

* Document conventions:

1. The user/developer is a "she" / "her", unless there are multiples, in which cases the 2nd may be a "he".
2. Only put rules in as "SET" rules if it adds something above & beyond the REF/EXT checks. Like add'l cross-schema validations. Or if it needs to be checked on files that aren't REF/EXT, like external schemas.
3. Keep document references in Zotero
   1. Enter niem specs as type 'document'
   2. Generate citations as "Chicago Manual of Style 16th edition (full note)"

* Building
For RC releases, just n
* document folder layout

* functions used

Functions 

- fn:QName($paramURI as xs:string?, $paramQName as xs:string) as xs:QName
- fn:in-scope-prefixes($element as element()) as xs:string*
- fn:namespace-uri-for-prefix($prefix as xs:string?, $element as element()) as xs:anyURI?
- fn:namespace-uri-from-QName($arg as xs:QName?) as xs:anyURI?
- fn:resolve-QName($qname as xs:string?, $element as element()) as xs:QName?
- fn:string($arg as item()?) as xs:string
- fn:matches($input as xs:string?, $pattern as xs:string) as xs:boolean

* Tree of types

- simple: Simple Type (name = *SimpleType)
  - code: code simple type
- complex: Complex type (otherwise)  
  - association: AssociationType (name = *AssociationType)
  - metadata: Metadata type (name = *MetadataType)
  - augmentation: AugmentationType (name = *AugmentationType)
  - object: Object type (otherwise)
    - csc: CSC
      - proxy: Proxy type
      - role: role type
      - code : Code type
    - ccc: CCC
      - adapter: Adapter type

complex types by name, in conformant schema:

  - *AssociationType
  - *MetadataType
  - *AugmentationType
  - otherwise: object type

* Tree of elements

- Metadata element
- Association element

* Conformant schema patterns

  - xs:schema
    - xs:complexType
      - xs:complexContent
        - xs:extension/@base
        - xs:restriction/@base
      - xs:simpleContent
    - xs:simpleType
      -xs:restriction
    - xs:attribute
      - xs:
    - xs:element

* XML Schema References

  xs:simpleType/xs:restriction/@base = simpleType
  xs:complextype/xs:{restriction,extension}/@base = type
  xs:element/@substitutionGroup : element
  xs:attribute/@type : simpleType
  xs:element/@type : type
  xs:{element,attribute}/@ref
  xs:union/@memberTypes = simpleType*
  xs:list/@itemType = simpleType
   
* Namespaces in play:

  - target namespace: nf:get-target-namespace(.)
  - structures namespace: xs:anyURI('MACRO_NS_STRUCTURES') 
  - the XML Schema namespace: xs:anyURI('MACRO_NS_XS')
  - The XML namespace: anyURI('MACRO_NS_XML') http://www.w3.org/XML/1998/namespace
  - the IC namespaces:
    - NTK: xs:anyURI('MACRO_NS_IC_NTK')
    - ISM: xs:anyURI('MACRO_NS_IC_ISM')

* Changes made

  - Removed NIEM OVERVIEW Appendix




* Augmentations

An AUGMENTABLE TYPE is:

  - or (
    - association
    - object : 
      - and
        - not a CSC
        - not an external
  
     
