<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>National Information Exchange Model Naming and Design Rules, 3.0alpha8</title><style type="text/css" media="all">body { font-family: "Times New Roman", Times, serif; background-color: #FFF; color: #000; margin: 3em; } p.todo { color: #000; background-color: #FCC; } a { text-decoration: none; color: #000; background-color: #FFF; } span.issue, span.issue a { color: #000; background-color: #FCC; } a[href]:hover { color: #000; background-color: #F9FAD4; } a.url { font-family: "Courier New", Courier, monospace; font-size: 80%; } a.ref, span.ref { font-weight: bold; } div.img { width: 100%; text-align: center; } img { width: 100%; } div.table { } div.table > table { margin: auto; } div.title { font-size: 200%; font-weight: bold; margin: 1em 5em; text-align: center; } div.subtitle { font-size: 150%; font-weight: bold; margin: 1em 5em; text-align: center; } div.heading { font-size: 125%; font-weight: bold; margin-top: 1em; margin-bottom: 1em; page-break-after: avoid; page-break-inside: avoid; } div.section { margin-left: 2em; } div.section div.section { margin-left: 0; } div.section div.heading { margin-left: -2em; } div.box { background-color: #EEE; color: #000; border: solid black 1px; padding: 1.0em; } div.box a { background-color: #EEE; color: #000; } div.box a:hover { background-color: #F9FAD4; color: #000; } div.box + div.box, div.figure + div.box { margin-top: 1em; } div.normativeHead { font-weight: bold; margin-bottom: 1em; } dfn { font-style: normal; } div.sub { margin-left: 2em; } td,th { border: solid black 1px; } th { color: #000; background-color: #EEE; } table { border-collapse: collapse; } code { font-family: "Courier New", Courier, monospace; font-size: 80%; } pre { font-family: "Courier New", Courier, monospace; font-size: 80%; white-space: pre-wrap; margin: 0; } div.caption { font-weight: bold; text-align: center; page-break-after: avoid; page-break-inside: avoid; } p.hang { text-indent: -2em; margin-left: 2em; } q { quotes: '\201C' '\201D' '\2018' '\2019'; } q:before { content: open-quote; } q:after { content: close-quote; } ol ol > li { list-style-type: upper-alpha; } li > p { margin-bottom: 0; }</style></head><body><div class="title">National Information Exchange Model Naming and Design Rules</div><div class="subtitle">Version 3.0alpha8</div><div class="subtitle">February 5, 2014</div><div class="subtitle">NIEM Technical Architecture Committee (NTAC)</div><div class="section"><a name="toc"></a><div class="heading">Contents</div><ul><li><a href="#section_1">1. Introduction</a><ul><li><a href="#section_1.1">1.1. Scope</a></li><li><a href="#section_1.2">1.2. Audience</a></li></ul></li><li><a href="#section_2">2. Document conventions and normative content</a><ul><li><a href="#section_2.1">2.1. Document references</a></li><li><a href="#section_2.2">2.2. Formatting</a></li><li><a href="#section_2.3">2.3. Clark notation and qualified names</a></li><li><a href="#section_2.4">2.4. Use of namespaces</a></li><li><a href="#section_2.5">2.5. Normative and informative content</a><ul><li><a href="#section_2.5.1">2.5.1. Rules</a></li></ul></li><li><a href="#section_2.6">2.6. Use of normative Schematron</a></li><li><a href="#section_2.7">2.7. Normative XPath functions</a></li><li><a href="#section_2.8">2.8. Normative Schematron namespace declarations</a></li></ul></li><li><a href="#section_3">3. Terminology</a><ul><li><a href="#section_3.1">3.1. RFC 2119 terminology</a></li><li><a href="#section_3.2">3.2. XML terminology</a></li><li><a href="#section_3.3">3.3. XML Information Set terminology</a></li><li><a href="#section_3.4">3.4. XML Schema terminology</a></li><li><a href="#section_3.5">3.5. XML Namespaces terminology</a></li><li><a href="#section_3.6">3.6. Conformance Targets Attribute Specification terminology</a></li></ul></li><li><a href="#section_4">4. Conformance targets</a><ul><li><a href="#section_4.1">4.1. Conformance targets defined</a><ul><li><a href="#section_4.1.1">4.1.1. Reference schema document</a></li><li><a href="#section_4.1.2">4.1.2. Extension schema document</a></li><li><a href="#section_4.1.3">4.1.3. Schema document set</a></li><li><a href="#section_4.1.4">4.1.4. Instance documents and elements</a></li></ul></li><li><a href="#section_4.2">4.2. Applicability of rules to conformance targets</a></li><li><a href="#section_4.3">4.3. Conformance target identifiers</a><ul><li><a href="#section_4.3.1">4.3.1. Schema is CTAS-conformant</a></li><li><a href="#section_4.3.2">4.3.2. Document element has conformanceTargets</a></li><li><a href="#section_4.3.3">4.3.3. Schema claims reference schema conformance target.</a></li><li><a href="#section_4.3.4">4.3.4. Schema claims extension conformance target</a></li></ul></li></ul></li><li><a href="#section_5">5. The NIEM conceptual model</a><ul><li><a href="#section_5.1">5.1. NIEM and the RDF model</a></li><li><a href="#section_5.2">5.2. NIEM properties</a></li><li><a href="#section_5.3">5.3. Unique identification of data objects</a></li><li><a href="#section_5.4">5.4. NIEM data model is explicit, not implicit</a></li><li><a href="#section_5.5">5.5. NIEM data model implementation in XML Schema</a></li></ul></li><li><a href="#section_6">6. Guiding principles</a><ul><li><a href="#section_6.1">6.1. Specification guidelines</a><ul><li><a href="#section_6.1.1">6.1.1. Keep specification to a minimum</a></li><li><a href="#section_6.1.2">6.1.2. Focus on rules for schemas</a></li><li><a href="#section_6.1.3">6.1.3. Use specific, concise rules</a></li></ul></li><li><a href="#section_6.2">6.2. XML Schema design guidelines</a><ul><li><a href="#section_6.2.1">6.2.1. Disallow content modification with XML processors</a></li><li><a href="#section_6.2.2">6.2.2. Use XML validating parsers for content validation</a></li><li><a href="#section_6.2.3">6.2.3. Validate for conformance to reference schemas</a></li><li><a href="#section_6.2.4">6.2.4. Allow multiple schemas for XML constraints</a></li><li><a href="#section_6.2.5">6.2.5. Define one reference schema per namespace</a></li><li><a href="#section_6.2.6">6.2.6. Disallow mixed content</a></li><li><a href="#section_6.2.7">6.2.7. Specify types for all constructs</a></li><li><a href="#section_6.2.8">6.2.8. Avoid wildcards in reference schemas</a></li><li><a href="#section_6.2.9">6.2.9. Provide default reference schema locations</a></li><li><a href="#section_6.2.10">6.2.10. Use open standards</a></li></ul></li><li><a href="#section_6.3">6.3. Modeling design guidelines</a><ul><li><a href="#section_6.3.1">6.3.1. Namespaces enhance reuse</a></li><li><a href="#section_6.3.2">6.3.2. Design NIEM for extensibility</a></li></ul></li><li><a href="#section_6.4">6.4. Implementation guidelines</a><ul><li><a href="#section_6.4.1">6.4.1. Avoid displaying raw XML data</a></li><li><a href="#section_6.4.2">6.4.2. Leave implementation decisions to implementers</a></li></ul></li><li><a href="#section_6.5">6.5. Modeling guidelines</a><ul><li><a href="#section_6.5.1">6.5.1. Documentation</a></li><li><a href="#section_6.5.2">6.5.2. Consistent naming</a></li><li><a href="#section_6.5.3">6.5.3. Reflect the real world</a></li><li><a href="#section_6.5.4">6.5.4. Be consistent</a></li><li><a href="#section_6.5.5">6.5.5. Reserve inheritance for specialization</a></li><li><a href="#section_6.5.6">6.5.6. Do not duplicate definitions</a></li><li><a href="#section_6.5.7">6.5.7. Keep it simple</a></li><li><a href="#section_6.5.8">6.5.8. Be aware of scope</a></li><li><a href="#section_6.5.9">6.5.9. Be mindful of namespace cohesion</a></li></ul></li></ul></li><li><a href="#section_7">7. Conformance to standards</a><ul><li><a href="#section_7.1">7.1. Conformance to XML</a></li><li><a href="#section_7.2">7.2. Conformance to XML Namespaces</a></li><li><a href="#section_7.3">7.3. Conformance to XML Schema</a></li><li><a href="#section_7.4">7.4. ISO 11179 Part 4</a></li><li><a href="#section_7.5">7.5. ISO 11179 Part 5</a><ul><li><a href="#section_7.5.1">7.5.1. Component names follow ISO 11179 Part 5 Annex A</a></li></ul></li></ul></li><li><a href="#section_8">8. Strategy for a NIEM profile of XML Schema</a><ul><li><a href="#section_8.1">8.1. Wildcards</a></li><li><a href="#section_8.2">8.2. Components are globally reusable</a></li><li><a href="#section_8.3">8.3. Avoid recursive model groups</a></li><li><a href="#section_8.4">8.4. Ensure schema processing does not alter processed data</a></li><li><a href="#section_8.5">8.5. Use namespaces rigorously</a></li><li><a href="#section_8.6">8.6. Documentation is for people; appinfo is for machines</a></li></ul></li><li><a href="#section_9">9. Rules for a NIEM profile of XML Schema</a><ul><li><a href="#section_9.1">9.1. Type definition components</a><ul><li><a href="#section_9.1.1">9.1.1. Type definition hierarchy</a><ul><li><a href="#section_9.1.1.1">9.1.1.1. Types prohibited as base types</a><ul><li><a href="#section_9.1.1.1.1">9.1.1.1.1. No base type of <code>xs:ID</code></a></li><li><a href="#section_9.1.1.1.2">9.1.1.1.2. No base type of <code>xs:IDREF</code></a></li><li><a href="#section_9.1.1.1.3">9.1.1.1.3. No base type of <code>xs:anyType</code></a></li><li><a href="#section_9.1.1.1.4">9.1.1.1.4. No base type of <code>xs:anySimpleType</code></a></li><li><a href="#section_9.1.1.1.5">9.1.1.1.5. No base type of <code>xs:NOTATION</code></a></li></ul></li></ul></li><li><a href="#section_9.1.2">9.1.2. Simple type definition</a><ul><li><a href="#section_9.1.2.1">9.1.2.1. Simple type definition is top-level</a></li><li><a href="#section_9.1.2.2">9.1.2.2. Simple type data definitions</a><ul><li><a href="#section_9.1.2.2.1">9.1.2.2.1. Simple type has data definition</a></li><li><a href="#section_9.1.2.2.2">9.1.2.2.2. Simple type data definition is not empty</a></li></ul></li><li><a href="#section_9.1.2.3">9.1.2.3. Simple types prohibited as list item types</a><ul><li><a href="#section_9.1.2.3.1">9.1.2.3.1. No list item type of <code>xs:ID</code></a></li><li><a href="#section_9.1.2.3.2">9.1.2.3.2. No list item type of <code>xs:IDREF</code></a></li><li><a href="#section_9.1.2.3.3">9.1.2.3.3. No list item type of <code>xs:anySimpleType</code></a></li></ul></li><li><a href="#section_9.1.2.4">9.1.2.4. Simple types prohibited as union member types</a><ul><li><a href="#section_9.1.2.4.1">9.1.2.4.1. No union member types of <code>xs:ID</code></a></li><li><a href="#section_9.1.2.4.2">9.1.2.4.2. No union member types of <code>xs:IDREF</code></a></li><li><a href="#section_9.1.2.4.3">9.1.2.4.3. No union member types of <code>xs:anySimpleType</code></a></li></ul></li><li><a href="#section_9.1.2.5">9.1.2.5. No simple type disallowed derivation</a></li><li><a href="#section_9.1.2.6">9.1.2.6. Enumeration data definitions</a><ul><li><a href="#section_9.1.2.6.1">9.1.2.6.1. Enumeration has data definition</a></li><li><a href="#section_9.1.2.6.2">9.1.2.6.2. Enumeration data definition is not empty</a></li></ul></li></ul></li><li><a href="#section_9.1.3">9.1.3. Complex type definitions</a><ul><li><a href="#section_9.1.3.1">9.1.3.1. Complex type definitions are top-level</a></li><li><a href="#section_9.1.3.2">9.1.3.2. Complex type data definitions</a><ul><li><a href="#section_9.1.3.2.1">9.1.3.2.1. Complex type has data definition</a></li><li><a href="#section_9.1.3.2.2">9.1.3.2.2. Complex type data definition is not empty</a></li></ul></li><li><a href="#section_9.1.3.3">9.1.3.3. No mixed content</a><ul><li><a href="#section_9.1.3.3.1">9.1.3.3.1. No mixed content on complex type</a></li><li><a href="#section_9.1.3.3.2">9.1.3.3.2. No mixed content on complex content</a></li></ul></li><li><a href="#section_9.1.3.4">9.1.3.4. Complex type content is explicitly simple or complex</a></li><li><a href="#section_9.1.3.5">9.1.3.5. Complex content</a><ul><li><a href="#section_9.1.3.5.1">9.1.3.5.1. Complex content uses extension</a></li><li><a href="#section_9.1.3.5.2">9.1.3.5.2. Complex type with complex content must have complex content</a></li></ul></li><li><a href="#section_9.1.3.6">9.1.3.6. Simple content</a><ul><li><a href="#section_9.1.3.6.1">9.1.3.6.1. Simple content uses extension</a></li><li><a href="#section_9.1.3.6.2">9.1.3.6.2. Complex types with simple content have <code>structures:SimpleObjectAttributeGroup</code></a></li></ul></li><li><a href="#section_9.1.3.7">9.1.3.7. No complex type disallowed substitutions</a></li><li><a href="#section_9.1.3.8">9.1.3.8. No complex type disallowed derivation</a></li></ul></li></ul></li><li><a href="#section_9.2">9.2. Declaration components</a><ul><li><a href="#section_9.2.1">9.2.1. Element declaration</a><ul><li><a href="#section_9.2.1.1">9.2.1.1. Element declaration is top-level</a></li><li><a href="#section_9.2.1.2">9.2.1.2. Element declaration data definitions</a><ul><li><a href="#section_9.2.1.2.1">9.2.1.2.1. Element declaration has data definition</a></li><li><a href="#section_9.2.1.2.2">9.2.1.2.2. Element declaration data definition is not empty</a></li></ul></li><li><a href="#section_9.2.1.3">9.2.1.3. Untyped element is abstract</a></li><li><a href="#section_9.2.1.4">9.2.1.4. Element of type <code>xs:anySimpleType</code> is abstract</a></li><li><a href="#section_9.2.1.5">9.2.1.5. Element type not in the XML Schema namespace</a></li><li><a href="#section_9.2.1.6">9.2.1.6. Element type not in a special namespace</a></li><li><a href="#section_9.2.1.7">9.2.1.7. Element type is not a simple type</a></li><li><a href="#section_9.2.1.8">9.2.1.8. No element disallowed substitutions </a></li><li><a href="#section_9.2.1.9">9.2.1.9. No element disallowed derivation</a></li><li><a href="#section_9.2.1.10">9.2.1.10. No element value constraints</a><ul><li><a href="#section_9.2.1.10.1">9.2.1.10.1. No element default values</a></li><li><a href="#section_9.2.1.10.2">9.2.1.10.2. No element fixed values</a></li></ul></li><li><a href="#section_9.2.1.11">9.2.1.11. Element declaration is nillable</a></li></ul></li><li><a href="#section_9.2.2">9.2.2. Element substitution group</a></li><li><a href="#section_9.2.3">9.2.3. Attribute declaration</a><ul><li><a href="#section_9.2.3.1">9.2.3.1. Attribute declarations are top-level</a></li><li><a href="#section_9.2.3.2">9.2.3.2. Attribute declaration data definitions</a><ul><li><a href="#section_9.2.3.2.1">9.2.3.2.1. Attribute declaration has data definition</a></li><li><a href="#section_9.2.3.2.2">9.2.3.2.2. Attribute declaration data definition is not empty</a></li></ul></li><li><a href="#section_9.2.3.3">9.2.3.3. Attribute declaration has type</a></li><li><a href="#section_9.2.3.4">9.2.3.4. Prohibited attribute types</a><ul><li><a href="#section_9.2.3.4.1">9.2.3.4.1. No attribute type of <code>xs:ID</code></a></li><li><a href="#section_9.2.3.4.2">9.2.3.4.2. No attribute type of <code>xs:IDREF</code></a></li></ul></li><li><a href="#section_9.2.3.5">9.2.3.5. No attribute value constraints</a><ul><li><a href="#section_9.2.3.5.1">9.2.3.5.1. No attribute default values</a></li><li><a href="#section_9.2.3.5.2">9.2.3.5.2. No attribute fixed values</a></li></ul></li></ul></li><li><a href="#section_9.2.4">9.2.4. Notation declaration</a><ul><li><a href="#section_9.2.4.1">9.2.4.1. No use of element xs:notation</a></li></ul></li></ul></li><li><a href="#section_9.3">9.3. Model group components</a><ul><li><a href="#section_9.3.1">9.3.1. Model group</a><ul><li><a href="#section_9.3.1.1">9.3.1.1. Model group does not affect meaning</a></li><li><a href="#section_9.3.1.2">9.3.1.2. No <code>xs:all</code></a></li><li><a href="#section_9.3.1.3">9.3.1.3. Sequence</a><ul><li><a href="#section_9.3.1.3.1">9.3.1.3.1. <code>xs:sequence</code> must be child of <code>xs:extension</code></a></li><li><a href="#section_9.3.1.3.2">9.3.1.3.2. <code>xs:sequence</code> must be child of <code>xs:extension</code> or <code>xs:restriction</code></a></li></ul></li><li><a href="#section_9.3.1.4">9.3.1.4. Choice</a><ul><li><a href="#section_9.3.1.4.1">9.3.1.4.1. No <code>xs:choice</code></a></li><li><a href="#section_9.3.1.4.2">9.3.1.4.2. <code>xs:choice</code> must be child of <code>xs:sequence</code></a></li></ul></li></ul></li><li><a href="#section_9.3.2">9.3.2. Particle</a><ul><li><a href="#section_9.3.2.1">9.3.2.1. Sequence cardinality</a><ul><li><a href="#section_9.3.2.1.1">9.3.2.1.1. Sequence minimum cardinality</a></li><li><a href="#section_9.3.2.1.2">9.3.2.1.2. Sequence maximum cardinality</a></li></ul></li><li><a href="#section_9.3.2.2">9.3.2.2. Choice cardinality</a><ul><li><a href="#section_9.3.2.2.1">9.3.2.2.1. Choice minimum cardinality</a></li><li><a href="#section_9.3.2.2.2">9.3.2.2.2. Choice maximum cardinality</a></li></ul></li></ul></li><li><a href="#section_9.3.3">9.3.3. Attribute use</a><ul><li><a href="#section_9.3.3.1">9.3.3.1. Attribute ref defined by conformant schemas</a></li></ul></li><li><a href="#section_9.3.4">9.3.4. Attribute group</a><ul><li><a href="#section_9.3.4.1">9.3.4.1. Only known attribute groups</a></li></ul></li><li><a href="#section_9.3.5">9.3.5. Wildcard</a><ul><li><a href="#section_9.3.5.1">9.3.5.1. No use of <code>xs:any</code></a></li><li><a href="#section_9.3.5.2">9.3.5.2. No use of <code>xs:anyAttribute</code></a></li></ul></li></ul></li><li><a href="#section_9.4">9.4. Identity-constraint definition components</a><ul><li><a href="#section_9.4.1">9.4.1. No use of <code>xs:unique</code></a></li><li><a href="#section_9.4.2">9.4.2. No use of <code>xs:key</code></a></li><li><a href="#section_9.4.3">9.4.3. No use of <code>xs:keyref</code></a></li><li><a href="#section_9.4.4">9.4.4. No use of <code>xs:selector</code></a></li><li><a href="#section_9.4.5">9.4.5. No use of <code>xs:field</code></a></li></ul></li><li><a href="#section_9.5">9.5. Group definition components</a><ul><li><a href="#section_9.5.1">9.5.1. Model group definition</a><ul><li><a href="#section_9.5.1.1">9.5.1.1. No use of <code>xs:group</code></a></li></ul></li><li><a href="#section_9.5.2">9.5.2. Attribute group definition</a><ul><li><a href="#section_9.5.2.1">9.5.2.1. No definition of attribute groups</a></li></ul></li></ul></li><li><a href="#section_9.6">9.6. Annotation components</a><ul><li><a href="#section_9.6.1">9.6.1. Comments are not recommended</a></li><li><a href="#section_9.6.2">9.6.2. Documentation elements have no element children</a></li><li><a href="#section_9.6.3">9.6.3. Application information annotations</a><ul><li><a href="#section_9.6.3.1">9.6.3.1. Appinfo has elements</a></li><li><a href="#section_9.6.3.2">9.6.3.2. Appinfo child elements have namespaces</a></li><li><a href="#section_9.6.3.3">9.6.3.3. Appinfo descendants are not XML Schema elements</a></li></ul></li></ul></li><li><a href="#section_9.7">9.7. Schema as a whole</a><ul><li><a href="#section_9.7.1">9.7.1. Schema data definitions</a><ul><li><a href="#section_9.7.1.1">9.7.1.1. Schema has data definition</a></li><li><a href="#section_9.7.1.2">9.7.1.2. Schema data definition is not empty</a></li></ul></li><li><a href="#section_9.7.2">9.7.2. Define target namespace</a></li><li><a href="#section_9.7.3">9.7.3. Target namespace is absolute URI</a></li><li><a href="#section_9.7.4">9.7.4. Schema document version</a><ul><li><a href="#section_9.7.4.1">9.7.4.1. Schema must have version</a></li><li><a href="#section_9.7.4.2">9.7.4.2. Schema version must not be empty.</a></li></ul></li><li><a href="#section_9.7.5">9.7.5. No disallowed substitutions</a></li><li><a href="#section_9.7.6">9.7.6. No disallowed derivations</a></li></ul></li><li><a href="#section_9.8">9.8. Schema assembly</a><ul><li><a href="#section_9.8.1">9.8.1. No use of <code>xs:redefine</code></a></li><li><a href="#section_9.8.2">9.8.2. No use of <code>xs:include</code></a></li><li><a href="#section_9.8.3">9.8.3. <code>xs:import</code> must have namespace</a></li></ul></li></ul></li><li><a href="#section_10">10. Rules for NIEM modeling, by NIEM concept</a><ul><li><a href="#section_10.1">10.1. NIEM structural facilities</a><ul><li><a href="#section_10.1.1">10.1.1. Use structures as specified</a></li></ul></li><li><a href="#section_10.2">10.2. Categories of NIEM components</a><ul><li><a href="#section_10.2.1">10.2.1. Classes of complex types</a></li><li><a href="#section_10.2.2">10.2.2. Objects</a><ul><li><a href="#section_10.2.2.1">10.2.2.1. General object types</a><ul><li><a href="#section_10.2.2.1.1">10.2.2.1.1. Object types with complex content</a><ul><li><a href="#section_10.2.2.1.1.1">10.2.2.1.1.1. An object type with complex content is derived from an object type</a></li></ul></li></ul></li><li><a href="#section_10.2.2.2">10.2.2.2. Roles</a><ul><li><a href="#section_10.2.2.2.1">10.2.2.2.1. RoleOf element type is an object type</a></li><li><a href="#section_10.2.2.2.2">10.2.2.2.2. Only object types have RoleOf element</a></li><li><a href="#section_10.2.2.2.3">10.2.2.2.3. RoleOf element indicates the base types of a role type</a></li><li><a href="#section_10.2.2.2.4">10.2.2.2.4. Instance of RoleOf element indicates a role object</a></li></ul></li><li><a href="#section_10.2.2.3">10.2.2.3. External adapter types</a><ul><li><a href="#section_10.2.2.3.1">10.2.2.3.1. External adapter type has complex content</a></li><li><a href="#section_10.2.2.3.2">10.2.2.3.2. External adapter type uses extension</a></li><li><a href="#section_10.2.2.3.3">10.2.2.3.3. External adapter type extends structures:ObjectType</a></li><li><a href="#section_10.2.2.3.4">10.2.2.3.4. External adapter types use sequence</a></li></ul></li><li><a href="#section_10.2.2.4">10.2.2.4. Code types</a><ul><li><a href="#section_10.2.2.4.1">10.2.2.4.1. The name of a code type ends in <q>CodeType</q></a></li></ul></li><li><a href="#section_10.2.2.5">10.2.2.5. Proxy types</a></li></ul></li><li><a href="#section_10.2.3">10.2.3. Associations</a><ul><li><a href="#section_10.2.3.1">10.2.3.1. Association types</a><ul><li><a href="#section_10.2.3.1.1">10.2.3.1.1. Association types are derived from association types</a></li></ul></li><li><a href="#section_10.2.3.2">10.2.3.2. Association element declarations</a><ul><li><a href="#section_10.2.3.2.1">10.2.3.2.1. Association element is an element of an association type</a></li></ul></li></ul></li><li><a href="#section_10.2.4">10.2.4. Augmentations</a><ul><li><a href="#section_10.2.4.1">10.2.4.1. Augmentable types</a><ul><li><a href="#section_10.2.4.1.1">10.2.4.1.1. Augmentable type has augmentation point</a></li></ul></li><li><a href="#section_10.2.4.2">10.2.4.2. Augmentation point element declarations</a><ul><li><a href="#section_10.2.4.2.1">10.2.4.2.1. An augmentation point corresponds to an augmentable type</a></li><li><a href="#section_10.2.4.2.2">10.2.4.2.2. An augmentation point has no type</a></li><li><a href="#section_10.2.4.2.3">10.2.4.2.3. An augmentation point has no substitution group</a></li></ul></li><li><a href="#section_10.2.4.3">10.2.4.3. Augmentation point element use</a><ul><li><a href="#section_10.2.4.3.1">10.2.4.3.1. Augmentation element may only be referenced by its type</a></li><li><a href="#section_10.2.4.3.2">10.2.4.3.2. Augmentation reference is optional</a></li><li><a href="#section_10.2.4.3.3">10.2.4.3.3. Augmentation reference is unbounded</a></li><li><a href="#section_10.2.4.3.4">10.2.4.3.4. Augmentation reference must be last particle</a></li></ul></li><li><a href="#section_10.2.4.4">10.2.4.4. Augmentation types</a><ul><li><a href="#section_10.2.4.4.1">10.2.4.4.1. Augmentation type name ends in <q>AugmentationType</q></a></li><li><a href="#section_10.2.4.4.2">10.2.4.4.2. Augmentation type derived from augmentation type</a></li><li><a href="#section_10.2.4.4.3">10.2.4.4.3. Augmentation types are derived from augmentation types</a></li></ul></li><li><a href="#section_10.2.4.5">10.2.4.5. Augmentation element declarations</a><ul><li><a href="#section_10.2.4.5.1">10.2.4.5.1. Augmentation element is an element of an augmentation type</a></li></ul></li></ul></li><li><a href="#section_10.2.5">10.2.5. Metadata</a><ul><li><a href="#section_10.2.5.1">10.2.5.1. Metadata types</a></li><li><a href="#section_10.2.5.2">10.2.5.2. Metadata types are derived from metadata types</a></li></ul></li></ul></li><li><a href="#section_10.3">10.3. Container elements</a></li><li><a href="#section_10.4">10.4. Naming rules</a><ul><li><a href="#section_10.4.1">10.4.1. Extension of XSD namespace simple types</a></li><li><a href="#section_10.4.2">10.4.2. Usage of English</a></li><li><a href="#section_10.4.3">10.4.3. Characters in names</a></li><li><a href="#section_10.4.4">10.4.4. Character case</a><ul><li><a href="#section_10.4.4.1">10.4.4.1. Names use camel case</a></li></ul></li><li><a href="#section_10.4.5">10.4.5. Use of acronyms and abbreviations</a></li><li><a href="#section_10.4.6">10.4.6. Word forms</a></li><li><a href="#section_10.4.7">10.4.7. Name generation</a></li><li><a href="#section_10.4.8">10.4.8. Object-class term</a></li><li><a href="#section_10.4.9">10.4.9. Property term</a></li><li><a href="#section_10.4.10">10.4.10. Qualifier terms</a></li><li><a href="#section_10.4.11">10.4.11. Representation terms</a></li></ul></li><li><a href="#section_10.5">10.5. Machine-readable annotations</a><ul><li><a href="#section_10.5.1">10.5.1. Machine-readable annotations are valid</a></li><li><a href="#section_10.5.2">10.5.2. The NIEM appinfo namespace</a><ul><li><a href="#section_10.5.2.1">10.5.2.1. Deprecation</a><ul><li><a href="#section_10.5.2.1.1">10.5.2.1.1. A component marked as deprecated is a deprecated component</a></li><li><a href="#section_10.5.2.1.2">10.5.2.1.2. Deprecated annotates schema component</a></li></ul></li><li><a href="#section_10.5.2.2">10.5.2.2. External import indicator annotates import</a></li><li><a href="#section_10.5.2.3">10.5.2.3. External adapter type indicator annotates complex type</a></li><li><a href="#section_10.5.2.4">10.5.2.4. Applies to types annotation</a><ul><li><a href="#section_10.5.2.4.1">10.5.2.4.1. Applies to types annotates metadata element</a></li><li><a href="#section_10.5.2.4.2">10.5.2.4.2. Applies to types indicates elements</a></li></ul></li><li><a href="#section_10.5.2.5">10.5.2.5. Applies to elements annotation</a><ul><li><a href="#section_10.5.2.5.1">10.5.2.5.1. Applies to elements annotates metadata element</a></li><li><a href="#section_10.5.2.5.2">10.5.2.5.2. Applies to elements indicates elements</a></li></ul></li></ul></li><li><a href="#section_10.5.3">10.5.3. The NIEM local terminology namespace</a><ul><li><a href="#section_10.5.3.1">10.5.3.1. LocalTerm annotates schema</a></li><li><a href="#section_10.5.3.2">10.5.3.2. LocalTerm has literal or definition</a></li></ul></li></ul></li></ul></li><li><a href="#section_11">11. Rules for NIEM modeling, by XML Schema component</a><ul><li><a href="#section_11.1">11.1. Type definition components</a><ul><li><a href="#section_11.1.1">11.1.1. Name of type ends in <q>Type</q></a></li><li><a href="#section_11.1.2">11.1.2. Name of type is in upper camel case</a></li><li><a href="#section_11.1.3">11.1.3. Type definition hierarchy</a><ul><li><a href="#section_11.1.3.1">11.1.3.1. Base type definition defined by conformant schema</a></li></ul></li><li><a href="#section_11.1.4">11.1.4. Simple type definition</a><ul><li><a href="#section_11.1.4.1">11.1.4.1. Name of simple type ends in <q>SimpleType</q></a></li><li><a href="#section_11.1.4.2">11.1.4.2. Name of simple type is upper camel case</a></li><li><a href="#section_11.1.4.3">11.1.4.3. Derivation by list</a><ul><li><a href="#section_11.1.4.3.1">11.1.4.3.1. Use lists only when data is uniform</a></li><li><a href="#section_11.1.4.3.2">11.1.4.3.2. List item type defined by conformant schemas</a></li></ul></li><li><a href="#section_11.1.4.4">11.1.4.4. Derivation by union</a><ul><li><a href="#section_11.1.4.4.1">11.1.4.4.1. Union member types defined by conformant schemas</a></li></ul></li><li><a href="#section_11.1.4.5">11.1.4.5. Code simple types</a><ul><li><a href="#section_11.1.4.5.1">11.1.4.5.1. Name of a code simple type has standard suffix</a></li><li><a href="#section_11.1.4.5.2">11.1.4.5.2. Code simple type has enumerations</a></li></ul></li></ul></li></ul></li><li><a href="#section_11.2">11.2. Declaration components</a><ul><li><a href="#section_11.2.1">11.2.1. Element declaration</a><ul><li><a href="#section_11.2.1.1">11.2.1.1. Element name is upper camel case</a></li><li><a href="#section_11.2.1.2">11.2.1.2. Element type does not have a simple type name</a></li><li><a href="#section_11.2.1.3">11.2.1.3. Element type is from conformant namespace</a></li><li><a href="#section_11.2.1.4">11.2.1.4. Name of element that ends in <q>Abstract</q> must be abstract</a></li><li><a href="#section_11.2.1.5">11.2.1.5. Name of element that ends in <q>Representation</q> must be abstract</a></li><li><a href="#section_11.2.1.6">11.2.1.6. Object element declarations</a><ul><li><a href="#section_11.2.1.6.1">11.2.1.6.1. Elements with simple content use representation term</a></li></ul></li><li><a href="#section_11.2.1.7">11.2.1.7. Metadata element declarations</a><ul><li><a href="#section_11.2.1.7.1">11.2.1.7.1. Metadata element is an element of a metadata type</a></li></ul></li></ul></li><li><a href="#section_11.2.2">11.2.2. Element substitution group</a><ul><li><a href="#section_11.2.2.1">11.2.2.1. Element substitution group defined by conformant schemas</a></li></ul></li><li><a href="#section_11.2.3">11.2.3. Attribute declaration</a><ul><li><a href="#section_11.2.3.1">11.2.3.1. Attribute type defined by conformant schemas</a></li><li><a href="#section_11.2.3.2">11.2.3.2. Attribute name uses representation term</a></li></ul></li><li><a href="#section_11.2.4">11.2.4. Notation declaration</a></li></ul></li><li><a href="#section_11.3">11.3. Model group components</a><ul><li><a href="#section_11.3.1">11.3.1. Model group</a></li><li><a href="#section_11.3.2">11.3.2. Particle</a><ul><li><a href="#section_11.3.2.1">11.3.2.1. Element use</a><ul><li><a href="#section_11.3.2.1.1">11.3.2.1.1. Element introduced only once in a content model</a></li><li><a href="#section_11.3.2.1.2">11.3.2.1.2. Element ref in external type defined by external schemas</a></li><li><a href="#section_11.3.2.1.3">11.3.2.1.3. Element reference defined by conformant schemas</a></li></ul></li></ul></li><li><a href="#section_11.3.3">11.3.3. Attribute use</a></li><li><a href="#section_11.3.4">11.3.4. Wildcard</a></li></ul></li><li><a href="#section_11.4">11.4. Annotation components</a><ul><li><a href="#section_11.4.1">11.4.1. Human-readable documentation</a></li><li><a href="#section_11.4.2">11.4.2. Data definition follows 11179-4 requirements</a></li><li><a href="#section_11.4.3">11.4.3. Data definition follows 11179-4 recommendations</a></li></ul></li><li><a href="#section_11.5">11.5. Schema as a whole</a><ul><li><a href="#section_11.5.1">11.5.1. <code>xs:schema</code> document element restrictions</a></li></ul></li><li><a href="#section_11.6">11.6. Schema assembly</a><ul><li><a href="#section_11.6.1">11.6.1. Reference schemas import reference schemas.</a></li><li><a href="#section_11.6.2">11.6.2. Special namespaces are imported as conformant</a><ul><li><a href="#section_11.6.2.1">11.6.2.1. Structures imported as conformant</a></li><li><a href="#section_11.6.2.2">11.6.2.2. Schema for XML imported as conformant</a></li><li><a href="#section_11.6.2.3">11.6.2.3. Schema for IC-ISM imported as conformant</a></li><li><a href="#section_11.6.2.4">11.6.2.4. Schema for IC-NTK imported as conformant</a></li></ul></li><li><a href="#section_11.6.3">11.6.3. Each namespace may have only a single root schema in a schema set.</a></li><li><a href="#section_11.6.4">11.6.4. Consistently marked namespace imports</a></li></ul></li></ul></li><li><a href="#section_12">12. XML instance document rules</a><ul><li><a href="#section_12.1">12.1. Instance must be schema-valid</a></li><li><a href="#section_12.2">12.2. Content elements</a></li><li><a href="#section_12.3">12.3. Reference elements</a><ul><li><a href="#section_12.3.1">12.3.1. Element with <code>structures:ref</code> does not have content</a></li><li><a href="#section_12.3.2">12.3.2. Attribute <code>structures:ref</code> must reference <code>structures:id</code></a></li><li><a href="#section_12.3.3">12.3.3. Linked elements have same validation root</a></li><li><a href="#section_12.3.4">12.3.4. Attribute <code>structures:ref</code> references element of correct type</a></li><li><a href="#section_12.3.5">12.3.5. Reference and content elements have same meaning</a></li></ul></li><li><a href="#section_12.4">12.4. Instance meaning</a></li><li><a href="#section_12.5">12.5. Instance metadata</a></li><li><a href="#section_12.6">12.6. Attribute <code>structures:ref</code> references <code>structures:id</code></a></li><li><a href="#section_12.7">12.7. Attribute <code>structures:metadata</code> references a metadata element</a></li><li><a href="#section_12.8">12.8. Attribute <code>structures:relationshipMetadata</code> references a metadata element</a></li></ul></li><li><a href="#appendix_A">Appendix A. References</a></li><li><a href="#appendix_B">Appendix B. Structures namespace</a></li><li><a href="#appendix_C">Appendix C. Appinfo namespace</a></li><li><a href="#appendix_D">Appendix D. Local terminology namespace</a></li><li><a href="#appendix_E">Appendix E. Index of definitions</a></li><li><a href="#appendix_F">Appendix F. Index</a></li></ul></div><div class="section"><a name="d3e32"></a><div class="heading">Table of Figures</div><ul><li><a href="#figure_2-1">Figure 2-1: Example of an XML fragment</a></li><li><a href="#figure_2-2">Figure 2-2: Normative Schematron namespace declarations</a></li><li><a href="#figure_5-1">Figure 5-1: Conceptual class rendered as XML Schema complex type</a></li><li><a href="#figure_5-2">Figure 5-2: Conceptual property rendered as element declaration</a></li><li><a href="#figure_6-1">Figure 6-1: Example of the use of a namespace</a></li><li><a href="#figure_7-1">Figure 7-1: Example of data definition of element <code>nc:Activity</code></a></li><li><a href="#figure_9-1">Figure 9-1: Example of complex type with simple content derived from a simple type</a></li><li><a href="#figure_10-1">Figure 10-1: An element definition that constitutes a role without the use of a role type</a></li><li><a href="#figure_10-2">Figure 10-2: Element <code>j:CrashDriver</code>, modeling the role of a driver in a crash</a></li><li><a href="#figure_10-3">Figure 10-3: Role type <code>j:CrashDriverType</code>, modeling a driver involved in a crash</a></li><li><a href="#figure_10-4">Figure 10-4: Declaration of RoleOf element <code>nc:RoleOfPerson</code></a></li><li><a href="#figure_10-5">Figure 10-5: An XML instance of a role type</a></li><li><a href="#figure_10-6">Figure 10-6: Use of external components to create a NIEM-conformant type</a></li><li><a href="#figure_10-7">Figure 10-7: An association in an instance</a></li><li><a href="#figure_10-8">Figure 10-8: A definition of an association type</a></li><li><a href="#figure_11-1">Figure 11-1: A definition that describes mathematical representation</a></li><li><a href="#figure_11-2">Figure 11-2: A definition that describes syntactic representation</a></li><li><a href="#figure_12-1">Figure 12-1: Example of content elements</a></li><li><a href="#figure_12-2">Figure 12-2: Example of reference element</a></li><li><a href="#figure_12-3">Figure 12-3: Example with a backward reference</a></li><li><a href="#figure_12-4">Figure 12-4: Example with a forward reference</a></li><li><a href="#figure_12-5">Figure 12-5: Simple example of instance metadata</a></li><li><a href="#figure_12-6">Figure 12-6: Example of metadata used in an instance</a></li><li><a href="#figure_12-7">Figure 12-7: A metadata type that describes applicability using <code>appinfo:AppliesTo</code></a></li></ul></div><div class="section"><a name="d3e40"></a><div class="heading">Table of Tables</div><ul><li><a href="#table_4-1">Table 4-1: Codes representing conformance targets</a></li><li><a href="#table_10-1">Table 10-1: Abbreviations used in NIEM core names</a></li><li><a href="#table_11-1">Table 11-1: Representation terms</a></li><li><a href="#table_11-2">Table 11-2: Standard opening phrases</a></li></ul></div><div class="section"><a name="d3e49"></a><div class="heading">Authors</div><p>Webb Roberts, Georgia Tech Research Institute</p></div><div class="section"><a name="d3e58"></a><div class="heading">Abstract</div><p>This document specifies the data model, XML components, and XML data for use with the National Information Exchange Model (NIEM) version 3.0.</p></div><div class="section"><a name="d3e67"></a><div class="heading">Status</div><p>This document is draft of the specification for NIEM-conformant XML Schema documents, components, and instances. It represents the design that has evolved from the collaborative work of the NIEM Business Architecture Committee (NBAC) and the NIEM Technical Architecture Committee (NTAC) and their predecessors.</p><p>This specification is a product of the NIEM Program Management Office (PMO).</p><p>Send comments on this specification via email to <a class="url" target="_blank" href="mailto:niem-comments%40lists.gatech.edu?subject=NIEM%20NDR%20Rules%20Version%203.0alpha8">niem-comments@lists.gatech.edu</a>.</p></div><div class="section"><a name="section_1"></a><div class="heading">1. Introduction</div><p>This Naming and Design Rules (NDR) document specifies XML Schema documents for use with the National Information Exchange Model (NIEM). NIEM is an information sharing framework based on the World Wide Web Consortium (W3C) Extensible Markup Language (XML) Schema standard. In February 2005, the U.S. Departments of Justice (DOJ) and Homeland Security (DHS) signed a cooperative agreement to jointly develop NIEM by leveraging and expanding the Global Justice XML Data Model (GJXDM) into multiple domains. NIEM is a result of a combined government and industry effort to improve information interoperability and exchange within the United States at federal, state, tribal, and local levels of government.</p><p>NIEM specifies a set of reusable information components for defining standard information exchange messages, transactions, and documents on a large scale: across multiple communities of interest and lines of business. These reusable components are rendered in XML Schema documents as type, element, and attribute definitions that comply with the W3C XML Schema specification. The resulting reference schemas are available to government practitioners and developers at <a class="url" target="_blank" href="http://niem.gov/">http://niem.gov/</a>.</p><p>The W3C XML Schema standard enables information interoperability and sharing by providing a common language for describing data precisely. The constructs it defines are basic metadata building blocks — baseline data types and structural components. Users employ these building blocks to describe their own domain-oriented data semantics and structures, as well as structures for specific information exchanges and components for reuse across multiple information exchanges. Rules that profile allowable XML Schema constructs and describe how to use them help ensure that those components are consistent and reusable.</p><p>This document specifies principles and enforceable rules for NIEM data components and schemas. Schemas and components that obey the rules set forth here are considered to be <strong>NIEM-conformant</strong>.</p><div class="section"><a name="section_1.1"></a><div class="heading">1.1. Scope</div><p>This document was developed to specify NIEM 3.0. Later releases of NIEM may be specified by later versions of this document. The document covers the following issues in depth:</p><ul><li>The underlying NIEM data model</li><li>Guiding principles behind the design of NIEM</li><li>Rules for using XML Schema constructs in NIEM</li><li>Rules for modeling and structuring NIEM-conformant schemas</li><li>Rules for creating NIEM-conformant instances</li><li>Rules for naming NIEM components</li><li>Rules for extending NIEM-conformant components</li></ul><p>This document does NOT address the following:</p><ul><li><p>A formal definition of the NIEM data model.</p><p>Such a definition would focus on the Resource Definition Framework (RDF) and concepts not strictly required for interoperability. This document instead focuses on definition of schemas that work with the data model, to ensure translatability and interoperability.</p></li><li>A detailed discussion of NIEM architecture and schema versioning.</li><li>The artifacts of the NIEM information exchange process.</li></ul><p>This document is intended as a technical specification. It is not intended to be a tutorial or a user guide.</p></div><div class="section"><a name="section_1.2"></a><div class="heading">1.2. Audience</div><p>This document targets practitioners and developers who employ NIEM for information exchange and interoperability. Such information exchanges may be between or within organizations. The NIEM reference schemas provide system implementers much content on which to build specific exchanges. However, there is a need for extended and additional content. The purpose of this document is to define the rules for such new content so that it will be consistent with the NIEM reference schemas. These rules are intended to establish and, more important, enforce a degree of standardization on a national level.</p></div></div><div class="section"><a name="section_2"></a><div class="heading">2. Document conventions and normative content</div><p>This document uses formatting and syntactic conventions to clarify meaning and avoid ambiguity.</p><div class="section"><a name="section_2.1"></a><div class="heading">2.1. Document references</div><p>This document relies on references to many outside documents. Such references are noted by bold, bracketed inline terms. For example, a reference to RFC 2119 is shown as <a href="#RFC2119" class="ref">[RFC 2119]</a>. All reference documents are recorded in <a href="#appendix_A">Appendix A, <em>References</em>, below</a>.</p></div><div class="section"><a name="section_2.2"></a><div class="heading">2.2. Formatting</div><p>In addition to special formatting for definitions, principles, and rules, this document uses consistent formatting to identify NIEM components.</p><p><code>Courier</code>: All words appearing in <code>Courier</code> font are values, objects, keywords, or literal XML text.</p><p><em>Italics</em>: All words appearing in <em>italics</em>, when not titles or used for emphasis, are special terms with definitions appearing in this document.</p><p>Throughout the document, fragments of XML Schema or XML instances are used to clarify a principle or rule. These fragments are specially formatted in <code>Courier</code> font and appear in text boxes. An example of such a fragment follows:</p><div class="figure"><a name="figure_2-1"></a><div class="caption">Figure 2-1: Example of an XML fragment</div><div class="box"><pre>&lt;xsd:complexType name="PersonType"&gt;
  ...
&lt;/xsd:complexType&gt;</pre></div></div></div><div class="section"><a name="section_2.3"></a><div class="heading">2.3. Clark notation and qualified names</div><p>This document uses both Clark notation and QName notation to represent qualified names.</p><p>QName notation is defined by <a href="#XMLNamespaces" class="ref">[XML Namespaes]</a> <a target="_blank" href="http://www.w3.org/TR/2009/REC-xml-names-20091208/#NT-QName">§4, <em>Qualified Names</em></a>. A QName for the XML Schema string datatype is <code>xs:string</code>. Namespace prefixes used within this specification are listed in <a href="#section_2.4">Section 2.4, <em>Use of namespaces</em>, below</a>.</p><p>This document sometimes uses Clark notation to represent qualified names in normative text. Clark notation is described by <a href="#ClarkNS" class="ref">[ClarkNS]</a>, and provides the information in an XML qualified name (as defined by <a href="#XMLNamespaces" class="ref">[XML Namespaes]</a>) without the need to define a namespace prefix and then reference that namespace prefix. A Clark notation representation for the qualified name for the XML Schema string datatype is <code>{http://www.w3.org/2001/XMLSchema}string</code>.</p><p>Each Clark notation value consists of a namespace URI surrounded by curly braces, concatenated with a local name. Clark notation is frequently used to represent the qualified name for an attribute with no namespace, which is ambiguous when represented using QName notation. For example, the element <code>targetNamespace</code>, which has no [namespace name] property, is represented in Clark notation as <code>{}targetNamespace</code>.</p></div><div class="section"><a name="section_2.4"></a><div class="heading">2.4. Use of namespaces</div><p>The following namespace prefixes are used consistently within this specification. These prefixes are not normative; this document issues no requirement that these prefixes be used in any conformant artifact.</p><ul><li><code>xs</code>: The namespace for the XML Schema definition language as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> and <a href="#XMLSchema-2" class="ref">[XML Schema Datatypes]</a>, <q><code>http://www.w3.org/2001/XMLSchema</code></q>.</li><li><code>xsi</code>: The XML Schema instance namespace, defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Instance_Document_Constructions">§2.6, <em>Schema-Related Markup in Documents Being Validated</em></a>, for use in XML documents, <q><code>http://www.w3.org/2001/XMLSchema-instance</code></q>.</li><li><code>sch</code>: The Schematron namespace URI, as defined by <a href="#Schematron" class="ref">[Schematron]</a>, <q><code>http://purl.oclc.org/dsdl/schematron</code></q>.</li><li><code>nf</code>: The namespace defined by this specification for XPath functions, <q><code>http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#NDRFunctions</code></q>.</li><li><code>ct</code>: The namespace defined by <a href="#CTAS" class="ref">[CTAS]</a> for the <code>conformanceTargets</code> attribute, <q><code>http://release.niem.gov/niem/conformanceTargets/3.0/</code></q>.</li><li><code>appinfo</code>: The namespace for the <span class="termRef"><a name="d3e396" href="#definition_appinfo_namespace">[appinfo namespace]</a></span>, <q><code>http://release.niem.gov/niem/appinfo/3.0/</code></q>.</li><li><code>structures</code>: The namespace for the <span class="termRef"><a name="d3e409" href="#definition_structures_namespace">[structures namespace]</a></span>, <q><code>http://release.niem.gov/niem/structures/3.0/</code></q>.</li></ul></div><div class="section"><a name="section_2.5"></a><div class="heading">2.5. Normative and informative content</div><p>This document includes a variety of content. Some content is normative (binding and enforceable in implementations), while other content is informative (explanatory, but not part of the NIEM specification). In general, the informative material appears as supporting text and specific rationales for the normative material.</p><p>Conventions used within this document include:</p><div class="box"><a name="d3e431"></a><div class="normativeHead">[Definition: &lt;term&gt;]</div><div class="sub"><p>A formal definition of a term associated with NIEM.</p></div></div><p>Definitions are normative.</p><div class="box"><div class="normativeHead">[Principle &lt;number&gt;]</div><div class="sub"><p>A guiding principle for NIEM.</p></div></div><p>The principles represent the requirements, concepts, and goals that have helped shape the NIEM. Principles are informative, not normative, but act as the basis on which the rules are defined.</p><p>Accompanying each principle is a short discussion section that justifies the application of the principle to NIEM design.</p><p>Principles are numbered in the order in which they appear in the document.</p><div class="section"><a name="section_2.5.1"></a><div class="heading">2.5.1. Rules</div><p>Rules state specific requirements on artifacts or on the interpretation of artifacts. The classes of artifacts are identified by <span class="termRef"><a name="d3e463" href="#definition_conformance_target">[conformance targets]</a></span> that are enumerated by this document in <a href="#section_4.1">Section 4.1, <em>Conformance targets defined</em>, below</a>. The rules are normative.</p><div class="box"><div class="normativeHead">[Rule &lt;section&gt;-&lt;number&gt;] (&lt;applicability&gt;) (&lt;class&gt;)</div><div class="sub"><p>An enforceable rule for NIEM.</p></div></div><p>Each rule has a classification, which is either <q>Constraint</q> or <q>Interpretation</q>. If the classification is <q>Constraint</q>, then the rule is a <span class="termRef"><a name="d3e486" href="#definition_constraint_rule">[constraint rule]</a></span>. If the classification is <q>Interpretation</q>, then the rule is an <span class="termRef"><a name="d3e493" href="#definition_interpretation_rule">[interpretation rule]</a></span>.</p><div class="box"><a name="definition_constraint_rule"></a><div class="normativeHead">[Definition: <dfn>constraint rule</dfn>]</div><div class="sub"><p>A <strong>constraint rule</strong> is a rule that sets a requirement on an artifact with respect to its conformance to a <span class="termRef"><a name="d3e504" href="#definition_conformance_target">[conformance target]</a></span>.</p></div></div><div class="box"><a name="definition_interpretation_rule"></a><div class="normativeHead">[Definition: <dfn>interpretation rule</dfn>]</div><div class="sub"><p>An <strong>interpretation rule</strong> is a rule that sets the methodology, pattern, or procedure for understanding using some aspect of an instance of a conformance target.</p></div></div><p>Each rule has description of its applicability. This identifies the conformance target to which the rule applies. Each entry in the list is a code from <a href="#table_4-1">Table 4-1, <em>Codes representing conformance targets</em>, below</a>. If a code appears in the applicability list for a rule, then the rule applies to the corresponding conformance target. The conformance targets are defined in <a href="#section_4">Section 4, <em>Conformance targets</em>, below</a>.</p><p>Rules are stated with the help of XML Infoset terminology (elements and attributes), described by <a href="#section_3.3">Section 3.3, <em>XML Information Set terminology</em>, below</a>, and XML Schema terminology (e.g., schema components), described by <a href="#section_3.4">Section 3.4, <em>XML Schema terminology</em>, below</a>. The choice of terminology is driven by which terminology best expresses the rule. Certain concepts are more clearly expressed using XML Infoset information items, others using the XML Schema data model; still others are best expressed using a combination of terminology drawn from each standard.</p><p>Rules are numbered according to the section in which they appear and the order in which they appear within that section. For example, Rule 6-1 is the first rule in Section 6.</p></div></div><div class="section"><a name="section_2.6"></a><div class="heading">2.6. Use of normative Schematron</div><p>This document defines many normative rules using Schematron rule-based validation syntax, as defined by <a href="#Schematron" class="ref">[Schematron]</a>. Effort has been made to make the rules precise and unambiguous. Very detailed text descriptions of rules can introduce ambiguity, and they are not directly executable by users. Providing NDR rules that are expressed as Schematron rules ensures that the rules are precise, and that they are directly executable through commercially-available and free tools.</p><p>Many rules herein do not have executable Schematron supporting them. Some are not fit for automatic validation, and others may be difficult or cumbersome to express in Schematron. In neither case are such rules be any less normative. A rule that has no Schematron is just as normative as a rule that does have Schematron.</p><p>The Schematron rules are written using XPath2 as defined by <a href="#XPath2" class="ref">[XPath 2]</a>. These executable rules are normative.</p><p>An execution of a Schematron pattern that issues a failed assert represents a validation error, and signfies that the assessed artifact vioates a requirement of a conformance rule. </p><p>An execution of a Schematron pattern that issues a report indicates cause for concern. This may be:</p><ul><li>An indication that the automated rules are not sufficient to validate a conformance rule, and that another means is required to ensure conformance. This is frequently a reference to another specification.</li><li>an indication that an automated rule has found that the assessed artifact violates a recommendation of the specification (e.g., a SHOULD, rather than a MUST), and that attention should be paid to ensure that the artifact maintains the spirit of the specification.</li></ul><p>In either case, the Schematron reporting mechanism may be used to identify specific location within artifacts that need further attention. </p></div><div class="section"><a name="section_2.7"></a><div class="heading">2.7. Normative XPath functions</div><p>The Schematron within this document is supported by functions, to make the rules more comprehensible, and to abstract away process-specific operations. Each function has a normative XPath interface and a normative text definition. Any implementation provided for these functions should be considered informative, not normative, but may be useful for certain implementations of the rules.</p><p>The following XPath functions are defined normatively when used within Schematron by this specification:</p><ul><li><pre>nf:get-document-element($context as element()) as element()</pre><p>Yields the document element for the XML document in which <code>$context</code> occurs.</p><p>This function provides the ability for a validator to consolidate multiple XML Schema documents and XML instance documents into a single XML document, which may simplify validation, and allow for preprocessing of <code>xs:include</code> elements.</p></li><li><pre>nf:get-target-namespace($element as element()) as xs:anyURI?</pre><p>Yields the target namespace of the XML Schema document in which $element appears. If it is an XML Schema document schema with no target namespace defined, then it yields the zero-length xs:anyURI value (<code>xs:anyURI('')</code>). If it is not an XML Schema document, then it yields the empty sequence (<code>()</code>).</p></li><li><pre>nf:resolve-namespace($context as element(), $namespace-uri as xs:anyURI) as element(xs:schema)?</pre><p>Yields the first available <code>xs:schema</code> document element that has the target namespace <code>$namespace-uri</code>. If there is no such XML Schema document available, it yields the empty sequence.</p></li><li><pre>nf:resolve-type($context as element(), $qname as xs:QName) as element()?</pre><p>Yields the first available occurence of an element <code>xs:simpleType</code> or <code>xs:complexType</code> that has a name matching <code>$qname</code>. If there is no occurrence available, it yields the empty sequence. </p></li><li><pre>nf:resolve-element($context as element(), $qname as xs:QName) as element(xs:element)?</pre><p>Yields the first available occurrence of an element <code>xs:element</code> with a name matching <code>$qname</code>. If there is no occurrence available, it yields the empty sequence.</p></li><li><pre>nf:has-effective-conformance-target-identifier($context as element(), $match as xs:anyURI) as xs:boolean</pre><p>Yields true if and only if an <span class="termRef"><a name="d3e679" href="#definition_effective_conformance_target_identifier">[effective conformance target identifier]</a></span> of the XML document containing <code>$context</code> is <code>$match</code>.</p></li></ul></div><div class="section"><a name="section_2.8"></a><div class="heading">2.8. Normative Schematron namespace declarations</div><p>The following Schematron namespace declarations are normative for the Schematron rules and supporting code within this specification:</p><div class="figure"><a name="figure_2-2"></a><div class="caption">Figure 2-2: Normative Schematron namespace declarations</div><div class="box"><pre>&lt;sch:ns prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/&gt;
&lt;sch:ns prefix="xsl" uri="http://www.w3.org/1999/XSL/Transform"/&gt;
&lt;sch:ns prefix="nf" uri="http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#NDRFunctions"/&gt;
&lt;sch:ns prefix="ct" uri="http://release.niem.gov/niem/conformanceTargets/3.0/"/&gt;
&lt;sch:ns prefix="xsi" uri="http://www.w3.org/2001/XMLSchema-instance"/&gt;
&lt;sch:ns prefix="appinfo" uri="http://release.niem.gov/niem/appinfo/3.0/"/&gt;
&lt;sch:ns prefix="structures" uri="http://release.niem.gov/niem/structures/3.0/"/&gt;
&lt;sch:ns prefix="term" uri="http://release.niem.gov/niem/localTerminology/3.0/"/&gt;</pre></div></div><p>Note that the binding of the prefix <code>xml</code> to the XML namespace (<q><code>http://www.w3.org/XML/1998/namespace</code></q>) is implicit.</p></div></div><div class="section"><a name="section_3"></a><div class="heading">3. Terminology</div><p>This document uses standard terminology to explain the principles and rules that describe NIEM.</p><div class="section"><a name="section_3.1"></a><div class="heading">3.1. RFC 2119 terminology</div><p>Within normative content (rules and definitions), the key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this document are to be interpreted as described in <a href="#RFC2119" class="ref">[RFC 2119]</a>.</p></div><div class="section"><a name="section_3.2"></a><div class="heading">3.2. XML terminology</div><div class="box"><a name="definition_XML_document"></a><div class="normativeHead">[Definition: <dfn>XML document</dfn>]</div><div class="sub"><p>The term <q>XML document</q> is as defined by <a href="#XML" class="ref">[XML]</a> <a target="_blank" href="http://www.w3.org/TR/2008/REC-xml-20081126/#dt-xml-doc">§2, <em>Documents</em></a>.</p></div></div></div><div class="section"><a name="section_3.3"></a><div class="heading">3.3. XML Information Set terminology</div><p>When discussing XML documents, this document uses terminology and language as defined by <a href="#XMLInfoset" class="ref">[XML Infoset]</a>.</p><p><a href="#XMLInfoset" class="ref">[XML Infoset]</a> uses the term <q>information item</q> to describe pieces of XML documents. Documents, elements, and attributes are types of information items. The use of the term <q>element information item</q>, for example, refers to the term as defined by <a href="#XMLInfoset" class="ref">[XML Infoset]</a>. Shorthand terms may also be used to refer to information items, such as <q>element</q>, as described within this section. The element information items are identified and defined by <a href="#XMLInfoset" class="ref">[XML Infoset]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoset">§2, <em>Information Items</em></a>.</p><p><a href="#XMLInfoset" class="ref">[XML Infoset]</a> also describes properties of information items. Each class of information item carries a set of properties. Each property has a name, and the property is identified by putting the name into square brackets. For example, the element that contains an attribute is described as the [owner element] of an attribute information item.</p><p>Shorthand terms for information items include:</p><ul><li><a name="d3e826">element</a>: an <em><a name="d3e830">element information item</a></em></li><li><a name="d3e835">attribute</a>: an <em><a name="d3e839">attribute information item</a></em></li><li>document element: the [document element] property of a document information item, preferred over the common term <q>root element</q>.</li></ul><p>Shorthand terms for properties of information items include:</p><ul><li>parent (of an element): the [parent] property of an element information item</li><li>child (of an element): a member of the [children] property of an element information item</li><li>owner (of an attribute): the [owner element] property of an attribute information item</li></ul></div><div class="section"><a name="section_3.4"></a><div class="heading">3.4. XML Schema terminology</div><p>This document uses many terms from <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> and <a href="#XMLSchema-2" class="ref">[XML Schema Datatypes]</a> in a normative way.</p><div class="box"><a name="definition_schema_component"></a><div class="normativeHead">[Definition: <dfn>schema component</dfn>]</div><div class="sub"><p>The term <q>schema component</q> is as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-component">§2.2, <em>XML Schema Abstract Data Model</em></a>, which states:</p><blockquote><p><strong>Schema component</strong> is the generic term for the building blocks that comprise the abstract data model of the schema.</p></blockquote></div></div><div class="box"><a name="definition_XML_Schema"></a><div class="normativeHead">[Definition: <dfn>XML Schema</dfn>]</div><div class="sub"><p>The term <q>XML Schema</q> is as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-schema">§2.2, <em>XML Schema Abstract Data Model</em></a>, which states:</p><blockquote><p>An <strong>XML Schema</strong> is a set of schema components.</p></blockquote></div></div><div class="box"><a name="definition_base_type_definition"></a><div class="normativeHead">[Definition: <dfn>base type definition</dfn>]</div><div class="sub"><p>The term <q>base type definition</q> is as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-baseTypeDefinition">§2.2.1.1, <em>Type Definition Hierarchy</em></a>.</p></div></div><div class="box"><a name="definition_simple_type_definition"></a><div class="normativeHead">[Definition: <dfn>simple type definition</dfn>]</div><div class="sub"><p>The term <q>simple type definition</q> is as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Simple_Type_Definition">§2.2.1.2, <em>Simple Type Definition</em></a>.</p></div></div><div class="box"><a name="definition_complex_type_definition"></a><div class="normativeHead">[Definition: <dfn>complex type definition</dfn>]</div><div class="sub"><p>The term <q>complex type definition</q> is as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Complex_Type_Definition">§2.2.1.3, <em>Complex Type Definition</em></a>.</p></div></div><div class="box"><a name="definition_element_declaration_schema_component"></a><div class="normativeHead">[Definition: <dfn>element declaration schema component</dfn>]</div><div class="sub"><p>The term <q>element declaration</q> is as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Element_Declaration">§2.2.2.1, <em>Element Declaration</em></a>.</p></div></div><div class="box"><a name="definition_element_declaration"></a><div class="normativeHead">[Definition: <dfn>element declaration</dfn>]</div><div class="sub"></div></div><ul><li>the XML Schema definition language: as described by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a>.</li><li>a schema document: as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a>.</li><li>valid: as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a>.</li><li>an XML Schema document set: a set of schema documents that together define an XML schema suitable for assessing the validity of an XML document.</li></ul><p>In this document, the name of the referenced schema component may appear without the suffix <q>schema component</q> (e.g., the term <q>complex type definition</q> may be used instead of <q>complex type definition schema component</q>) to enhance readability of the text.</p></div><div class="section"><a name="section_3.5"></a><div class="heading">3.5. XML Namespaces terminology</div><p>This document uses XML Namespaces as defined by <a href="#XMLNamespaces" class="ref">[XML Namespaes]</a> and <a href="#XMLNamespacesErrata" class="ref">[XML Namespaces Errata]</a>.</p></div><div class="section"><a name="section_3.6"></a><div class="heading">3.6. Conformance Targets Attribute Specification terminology</div><p><a href="#CTAS" class="ref">[CTAS]</a> defines several terms used normatively within this specification.</p><div class="box"><a name="definition_conformance_target"></a><div class="normativeHead">[Definition: <dfn>conformance target</dfn>]</div><div class="sub"><p>The term <q>conformance target</q> is as defined by <a href="#CTAS" class="ref">[CTAS]</a>, which states:</p><blockquote><p>A <em>conformance target</em> is a class of artifact, such as an interface, protocol, document, platform, process or service, that is the subject of conformance clauses and normative statements. There may be several conformance targets defined within a specification, and these targets may be diverse so as to reflect different aspects of a specification. For example, a protocol message and a protocol engine may be different conformance targets.</p></blockquote></div></div><div class="box"><a name="definition_conformance_target_identifier"></a><div class="normativeHead">[Definition: <dfn>conformance target identifier</dfn>]</div><div class="sub"><p>The term <q>conformance target identifier</q> is as defined by <a href="#CTAS" class="ref">[CTAS]</a>, which states:</p><blockquote><p>A <em>conformance target identifier</em> is an internationalized resource identifier that uniquely identifies a conformance target.</p></blockquote></div></div><div class="box"><a name="definition_effective_conformance_target_identifier"></a><div class="normativeHead">[Definition: <dfn>effective conformance target identifier</dfn>]</div><div class="sub"><p>The term <q>effective conformance target identifier</q> is as defined by <a href="#CTAS" class="ref">[CTAS]</a> <a target="_blank" href="http://reference.niem.gov/niem/specification/conformance-target-attribute/3.0beta2/NIEM-CTAS-3.0beta2.html#definition_effective_conformance_target_identifier">§4, <em>Semantics and Use</em></a>, which states:</p><blockquote><p>An <em>effective conformance target identifier</em> of a conformant document is an internationalized resource identifier reference that occurs in the document’s effective conformance targets attribute.</p></blockquote></div></div></div></div><div class="section"><a name="section_4"></a><div class="heading">4. Conformance targets</div><div class="section"><a name="section_4.1"></a><div class="heading">4.1. Conformance targets defined</div><p>This section defines and describes conformance targets of this specification. Each conformance target has a formal definition, along with a notional description of the characterstics and intent of each. These include:</p><ul><li><a href="#section_4.1.1">Section 4.1.1, <em>Reference schema document</em></a></li><li><a href="#section_4.1.2">Section 4.1.2, <em>Extension schema document</em></a></li><li><a href="#section_4.1.3">Section 4.1.3, <em>Schema document set</em></a></li><li><a href="#section_4.1.4">Section 4.1.4, <em>Instance documents and elements</em></a></li></ul><div class="section"><a name="section_4.1.1"></a><div class="heading">4.1.1. Reference schema document</div><div class="box"><a name="definition_conformant_reference_schema_document"></a><div class="normativeHead">[Definition: <dfn>conformant reference schema document</dfn>]</div><div class="sub"><p>A <strong>conformant reference schema document</strong> is a schema document that is intended to provide the authoritative definitions of broadly reusable data components. It is a conformance target of this specification. A reference schema document MUST conform to all rules of this specification that apply to this conformance target. An XML document with a conformance target identifier of <code>http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument</code> MUST be a conformant reference schema document.</p></div></div><p>A conformant reference schema document is a schema document that is intended to be the authoritative definition schema for a namespace. Examples include NIEM Core and NIEM domains.</p><p>Some characteristics of a reference schema document:</p><ul><li>It is explicitly designated as a reference schema via the conformance targets attribute (<code>ct:conformanceTargets</code>), as defined by <a href="#CTAS" class="ref">[CTAS]</a>.</li><li>It provides the broadest, most fundamental definitions of components in its namespace.</li><li>It provides the authoritative definition of business semantics for components in its namespace.</li><li>It is intended to serve as the basis for components in information exchanges and extension schema documents.</li><li>It satisfies all rules specified in the Naming and Design Rules for reference schemas.</li></ul><p>Any schema that defines components that are intended to be incorporated into NIEM Core or a NIEM domain may be defined as a reference schema.</p><p>The rules for reference schema documents are more stringent than are the rules for other classes of NIEM-conformant schemas. Reference schema documents are intended to support the broadest reuse. They are very uniform in their structure. As they are the primary definitions for data components, they do not need to restrict other data definitions, and they are not allowed to use XML Schema’s restriction mechanisms. Reference schema documents are intended to be as regular and simple as possible.</p></div><div class="section"><a name="section_4.1.2"></a><div class="heading">4.1.2. Extension schema document</div><div class="box"><a name="definition_conformant_extension_schema_document"></a><div class="normativeHead">[Definition: <dfn>conformant extension schema document</dfn>]</div><div class="sub"><p>A <strong>conformant extension schema document</strong> is a schema document that is intended to provide definitions of data components that are intended for reuse within a more narrow scope than reference schema documents. It is a conformance target of this specification. An extension schema document MUST conform to all rules of this specification that apply to this conformance target. An XML document with a conformance target identifier of <code>http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument</code> MUST be a conformant reference schema document.</p></div></div><p>An extension schema is an XML Schema document that meets all of the following criteria:</p><ul><li>It is explicitly designated as an extension schema document via the conformance targets attribute.</li><li>It provides the broadest, most fundamental definitions of components in its namespace.</li><li>It provides the authoritative definition of business semantics for components in its namespace.</li><li>It contains components that, when appropriate, use or are derived from the components in reference schema documents.</li><li>It is intended to express the additional vocabulary required for an information exchange, above and beyond the vocabulary available from reference schemas, and to also support additional XML Schema validation requirements for an exchange.</li><li>It satisfies all rules specified in the Naming and Design Rules for extension schemas.</li></ul><p>An extension schema in an information exchange specification serves several functions. First, it defines new content within a new namespace, which may be an exchange-specific namespace or a namespace shared by several exchanges. This content is NIEM-conformant but has fewer restrictions on it than do <span class="termRef"><a name="d3e1262" href="#definition_conformant_reference_schema_document">[conformant reference schema documents]</a></span>. Second, the extension schema document bases its content on content from reference schemas documents, where appropriate. Methods of deriving content include using (by reference) existing components, as well as creating extensions and restrictions of existing components.</p><p>For example, an information exchange specification may define a type for an exchange-specific phone number and base that type on a type defined by the NIEM Core reference schema document. This exchange-specific phone number type may restrict the NIEM Core type to limit those possibilities that are permitted of the base type. Exchange extensions and restrictions must include annotations and documentation to be conformant, but they are allowed to use restriction, choice, and some other constructs that are not allowed in reference schema documents.</p><p>Note that exchange specifications may define schemas that meet the criteria of reference schemas for those components that its developers wish to nominate for later inclusion in NIEM Core or in domains.</p></div><div class="section"><a name="section_4.1.3"></a><div class="heading">4.1.3. Schema document set</div><div class="box"><a name="definition_conformant_schema_document_set"></a><div class="normativeHead">[Definition: <dfn>conformant schema document set</dfn>]</div><div class="sub"><p>A <strong>conformant schema document set</strong> is a collection of XML Schema documents that together are capable of validating a conformant instance XML document. It is a conformance target of this specification. A conformant schema document set MUST conform to all rules of this specification that apply to this conformance target.</p></div></div></div><div class="section"><a name="section_4.1.4"></a><div class="heading">4.1.4. Instance documents and elements</div><p>This document has specific rules about how NIEM content should be used in XML documents. As well as containing rules for XML Schema documents, this NDR contains rules for NIEM-conformant XML content at a finer granularity than the XML document.</p><div class="box"><a name="definition_conformant_instance_XML_document"></a><div class="normativeHead">[Definition: <dfn>conformant instance XML document</dfn>]</div><div class="sub"><p>A <strong>conformant instance XML document</strong> is an XML document that is an instance of a conformant schema document set. It is a conformance target of this specification. A conformant instance XML document MUST conform to all rules of this specification that apply to this conformance target.</p></div></div><p>A conformant instance XML document is an XML document that satisfies all of the following criteria:</p><ul><li>The document element is locally schema-valid.</li><li>Each element information item within the XML document that has a namespace name matching the target namespace of a <span class="termRef"><a name="d3e1318" href="#definition_conformant_reference_schema_document">[conformant reference schema document]</a></span> or <span class="termRef"><a name="d3e1321" href="#definition_conformant_extension_schema_document">[conformant extension schema document]</a></span> is a <span class="termRef"><a name="d3e1324" href="#definition_conformant_element_information_item">[conformant element information item]</a></span>.</li></ul><p class="todo">Just make these term references</p><p>In this definition and the next definition below, the term <em>XML document</em> is as specified in <a href="#XML" class="ref">[XML]</a>. The terms <em>document information item</em>, <em>document element</em>, <em>element information item</em>, <em>namespace name</em>, and <em>local name</em> are as specified in <a href="#XMLInfoset" class="ref">[XML Infoset]</a>. The term <em>valid</em> is as specified in <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a>.</p><p>Schema-validity may be assessed against a single set of schemas or against multiple sets of schemas. Assessment against schemas is as directed by an IEPD, other instructions, or tools.</p><p>Note that the document element (root element) of a NIEM-conformant XML document is not required to be a NIEM-conformant element information item. Other specifications, such as the IEPD specification, may add additional constraints to these to specify IEPD or exchange conformance.</p><div class="box"><a name="definition_conformant_element_information_item"></a><div class="normativeHead">[Definition: <dfn>conformant element information item</dfn>]</div><div class="sub"><p>A <em>conformant element information item</em> is an element information item that satisfies all of the following criteria:</p><ul><li>Its namespace name and local name matches an element declared by a <span class="termRef"><a name="d3e1383" href="#definition_conformant_reference_schema_document">[conformant reference schema document]</a></span> or <span class="termRef"><a name="d3e1386" href="#definition_conformant_extension_schema_document">[conformant extension schema document]</a></span>.</li><li>It occurs within a <span class="termRef"><a name="d3e1393" href="#definition_conformant_instance_XML_document">[conformant instance XML document]</a></span>.</li><li>It is locally schema-valid.</li><li>It satisfies all rules specified in the Naming and Design Rules for NIEM-conformant element information items.</li></ul></div></div><p>Because each NIEM-conformant element information item must be locally schema-valid, each element must validate against the schema definition of the element, even if the element information item is allowed within the document because of a wildcard with <code>processContents</code> of <q>skip</q>. Within a NIEM-conformant XML document, each element that is from a NIEM namespace conforms to its schema specification.</p></div></div><div class="section"><a name="section_4.2"></a><div class="heading">4.2. Applicability of rules to conformance targets</div><p>Rules within this document are annotated with conformance target codes. Each rule may be annotated with one or more codes for a conformance target. A rule within this document that is annotated with one of the following codes applies to the corresponding conformance target.</p><div class="table"><a name="table_4-1"></a><div class="caption">Table 4-1: Codes representing conformance targets</div><table><thead><tr><th>Code</th><th>Conformance target</th></tr></thead><tbody><tr><td>REF</td><td>conformant reference schema document</td></tr><tr><td>EXT</td><td>conformant extension schema document</td></tr><tr><td>SET</td><td>Conformant schema document set</td></tr><tr><td>INS</td><td>Conformant instance XML document</td></tr></tbody></table></div></div><div class="section"><a name="section_4.3"></a><div class="heading">4.3. Conformance target identifiers</div><p>The term <span class="termRef"><a name="d3e1485" href="#definition_conformance_target_identifier">[conformance target identifier]</a></span> is defined by <a href="#CTAS" class="ref">[CTAS]</a>.</p><div class="section"><a name="section_4.3.1"></a><div class="heading">4.3.1. Schema is CTAS-conformant</div><div class="box"><a name="rule_4-1"></a><div class="normativeHead">[Rule 4-1] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[. is nf:get-document-element(.)]"&gt;
    &lt;sch:report test="true()"&gt;The document MUST be a conformant document as defined by the NIEM Conformance Targets Attribute Specification.&lt;/sch:report&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The term <q>conformant document</q> is defined by <a href="#CTAS" class="ref">[CTAS]</a> <a target="_blank" href="http://reference.niem.gov/niem/specification/conformance-target-attribute/3.0beta2/NIEM-CTAS-3.0beta2.html#section_3.2">§3.2, <em>Conformance to this Specification</em></a>.</p></div><div class="section"><a name="section_4.3.2"></a><div class="heading">4.3.2. Document element has conformanceTargets</div><div class="box"><a name="rule_4-2"></a><div class="normativeHead">[Rule 4-2] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[. is nf:get-document-element(.)
                       or exists(@ct:conformanceTargets)]"&gt;
    &lt;sch:assert test="(. is nf:get-document-element(.)) = exists(@ct:conformanceTargets)"
      &gt;An element MUST own an attribute {http://release.niem.gov/niem/conformanceTargets/3.0/}conformanceTargets if and only if it is a [document element].&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The term <q>document element</q> is as described by <a href="#section_3.3">Section 3.3, <em>XML Information Set terminology</em>, above</a>.</p></div><div class="section"><a name="section_4.3.3"></a><div class="heading">4.3.3. Schema claims reference schema conformance target.</div><div class="box"><a name="rule_4-3"></a><div class="normativeHead">[Rule 4-3] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[. is nf:get-document-element(.)]"&gt;
    &lt;sch:assert test="nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))"
      &gt;The document MUST have an effective conformance target identifier of http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_4.3.4"></a><div class="heading">4.3.4. Schema claims extension conformance target</div><div class="box"><a name="rule_4-4"></a><div class="normativeHead">[Rule 4-4] (EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[. is nf:get-document-element(.)]"&gt;
    &lt;sch:assert test="nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument'))"
      &gt;The document MUST have an effective conformance target identifier of http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_5"></a><div class="heading">5. The NIEM conceptual model</div><p>NIEM provides a concrete data model, in the form of a set of XML Schema documents. These schemas may be used to build messages and information exchanges. The schemas spell out what kinds of objects exist and how those objects may be related. XML data that follows the rules of NIEM imply specific meaning. The varieties of XML Schema components used within NIEM-conformant schemas are selected to clarify the meaning of XML data. That is, schema components that do not have a clear meaning have been avoided. NIEM provides a framework within which XML data has a specific meaning.</p><p>One limitation of XML and XML Schema is that they do not describe the meaning of an XML document. The XML specification defines XML documents and defines their syntax but does not address the meaning of those documents. The XML Schema specification defines the XML Schema definition language, which describes the structure and constrains the contents of XML documents (schemas).</p><p>In a schema, the meaning of a schema component (e.g., element, attribute, or type) may be described using the <code>xs:documentation</code> element. Or, additional information may be included via the <code>xs:appinfo</code> element. Although this may enable humans to understand XML data, more information is needed to support the machine-understandable meaning of XML data. In addition, inconsistency among the ways that schema components may be put together may be a source of confusion.</p><p>The RDF Core Working Group of the World Wide Web consortium has developed a simple, consistent conceptual model, the RDF model. The RDF model is described and specified through a set of W3C Recommendations, the Resource Description Framework (RDF) specifications, making it a very well defined standard. The NIEM model and the rules contained in this NDR are based on the RDF model. This provides numerous advantages:</p><ul><li>NIEM’s conceptual model is defined by a recognized standard.</li><li>NIEM’s conceptual model is very well defined.</li><li>NIEM’s conceptual model provides a consistent basis for relating attributes, elements, types, and other XML Schema components.</li><li>NIEM’s use of the RDF model defines what a set of NIEM data means. The RDF specification provides a detailed description of what a statement means. See <a href="#RDFSemantics" class="ref">[RDF Semantics]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/#interp">§1.3, <em>Intepretations</em></a>. This meaning is leveraged by NIEM.</li><li>NIEM’s use of the RDF model provides a basis for inferencing and reasoning about XML data that uses NIEM. That is, using the rules defined for the RDF model, programs can determine implications of relationships between NIEM-defined objects.</li></ul><p>With the exception of Section 2, NIEM rules are explained in this document without reference to RDF or RDF concepts. Understanding RDF is not required to understand NIEM-conformant schemas or data based on NIEM. However, understanding RDF concepts may deepen understanding of NIEM.</p><p>The goal of this section is to clarify the meaning of XML data that is NIEM-conformant and to outline the implications of various modeling constructs in NIEM. The rules for NIEM- conformant schemas and instances are in place to ensure that a specific meaning can be derived from data. That is, the data makes specific assertions, which are well understood since they are derived from the rules for NIEM.</p><p>The key concepts underpinning the NIEM conceptual model are discussed in the remainder of this section:</p><ul><li>NIEM and the RDF Model</li><li>NIEM Properties</li><li>Unique Identification of Data Objects</li><li>NIEM Data Model Is Explicit, Not Implicit</li><li>NIEM Data Model Implementation in XML Schema</li></ul><div class="section"><a name="section_5.1"></a><div class="heading">5.1. NIEM and the RDF model</div><p>NIEM has its foundation in the RDF model. This helps to ensure that NIEM-conformant data has precise meaning. The RDF view of what data means is clarified by <a href="#RDFSemantics" class="ref">[RDF Semantics]</a>:</p><blockquote><p>…asserting a sentence makes a claim about the world…an assertion amounts to stating a constraint on the possible ways the world might be.</p></blockquote><p>The RDF view of the meaning of data carries into NIEM: NIEM elements form statements that make claims about the world: that a person has a name, a residence location, a spouse, etc. The assertion of one set of facts does not necessarily rule out other statements: A person could have multiple names, could have moved, or could be divorced. Each statement is a claim asserted to be true by the originator of the statement.</p><p>This NDR discusses NIEM data in terms of objects, a term more accessible than the word used by RDF, resources. RDF defines the world in terms of resources. <a href="#RDFSemantics" class="ref">[RDF Semantics]</a> describes what may constitute a resource:</p><blockquote><p>…no assumptions are made here about the nature of resources; <q>resource</q> is treated here as synonymous with <q>entity</q>, i.e., as a generic term for anything in the universe of discourse.</p></blockquote><p>RDF resources coincide with NIEM objects and associations. That is, both objects and associations in NIEM are RDF resources with the additional constraints:</p><ul><li>A NIEM object or association is an instance of a complex type defined by an XML Schema document.</li><li>The XML Schema document that defines a NIEM object is a NIEM-conformant schema.</li></ul><p>NIEM associations are defined as n-ary properties, as described in <a href="#N-ary" class="ref">[N-ary]</a>, <a target="_blank" href="http://www.w3.org/TR/2006/NOTE-swbp-n-aryRelations-20060412/#useCase3"><q>Use Case 3: N-ary relation with no distinguished participant</q></a>. NIEM defines the terms <span class="termRef"><a name="d3e1757" href="#definition_object_type">[object type]</a></span>, <span class="termRef"><a name="d3e1760" href="#definition_association_type">[association type]</a></span>NIEM associations are defined in Section 7.4.3, Association Types. Assertions are made via NIEM-conformant XML data, described by Section 8, XML Instance Rules.</p><p>The XML Schema types that define NIEM objects and associations are related to each other via elements and attributes. That is, a type contains elements and attributes, and an element or attribute has a value that is an instance of an XML Schema type. In NIEM, these elements and attributes are XML Schema representations of RDF properties, which are described by <a href="#RDFPrimer" class="ref">[RDF Primer]</a>, <q>2.1 Basic Concepts</q>:</p><blockquote><p><q>RDF is based on the idea that the things being described have properties which have values, and that resources can be described by making statements…that specify those properties and values.</q></p></blockquote><p>This describes how NIEM works: schemas describe things and their properties. NIEM- conformant data specifies objects, the values of their properties, and the relationships between them.</p><p>There are several kinds of assertions that may be made with NIEM-conformant data. Examples include:</p><ul><li><p>An assertion that <strong>an object exists</strong>. An occurrence of an element commonly establishes the existence of an object. Such an object may be tangible or intangible. For example, the element <code>nc:Person</code> in an exchange implies that a person does or did exist. An element may also express that an object does not exist (e.g., the license plate ABC123 was never issued), but this is an uncommon case.</p><p>Descriptions of objects may carry an implicit assumption that objects exist. Such an assumption is dependent on the message in which such descriptions are made. If an object that is described does not exist, it should be made explicit in the definition of an element containing or referring to the object.</p></li><li>An assertion that <strong>an object has a characteristic</strong>. A feature or quality of an object is commonly represented by an element appearing within the element that establishes the object. For example, the height of a person is described by the <code>nc:PersonHeightMeasure</code> element. The <code>nc:PersonHeightMeasure</code> element occurs as XML content of the <code>nc:Person</code> element. In some cases, a characteristic may be represented by an attribute owned by an element.</li><li><p>An assertion that <strong>an object participates in a relationship</strong>. A relationship between objects may be established in any of several ways:</p><ul><li>Both objects may be referenced from an <a name="d3e1834">association</a> that establishes the relationship. Associations are also useful for expressing n-ary relationships, as well as relationships supported by additional data.</li><li>An element may occur within one object that indicates the relationship with the other object. This element may be either a content element or a reference element.</li></ul><p>The NIEM Core schema and some domain schemas have been normalized such that a minimum number of reference or content elements establish relationships. In these cases, use of an association is the more common method for establishing a relationship. However, in an exchange, using a reference or content element to express a relationship may be the simpler, preferred method for expressing a relationship.</p></li></ul></div><div class="section"><a name="section_5.2"></a><div class="heading">5.2. NIEM properties</div><p>NIEM-conformant data describes characteristics of objects and relationships between objects. In RDF, these characteristics and relationships are called <strong>properties</strong> of objects, which is also how NIEM refers to them. NIEM represents properties with element declarations and attribute declarations.</p><p>Within data, a property relates XML data much as a verb relates nouns in a sentence: a verb has a subject and an object.</p><ul><li>The <strong>property</strong> itself: What relationship is being asserted? For example, the property may say that a weapon has a user, or that someone has hair of a particular color.</li><li>The <strong>subject</strong>: About what object is the property being asserted? This would be the weapon that has the user, or the person whose hair is being described.</li><li>The <strong>object</strong>: What is the value of the property, or with what other object does the relationship exist? This would be the person who is the user of the weapon or the person whose hair has the color brown.</li></ul><p>A property relates <em>two</em> objects. Data will describe an object having a characteristic with a specific value or will describe an object with a particular relationship to another object. All properties are pair-wise: between two objects, or between an object and a value.</p><p>In theory, any relationship that involves more than two objects may be modeled as a set of binary properties. In NIEM, such relationships may be expressed either as a set of properties (i.e., as element and attribute declarations) or as a complex type defining an association.</p></div><div class="section"><a name="section_5.3"></a><div class="heading">5.3. Unique identification of data objects</div><p>In NIEM, an exchange is generally adhoc. That is, a message may be generated without any persistence. It exists only to exchange data and may not have any universal meaning beyond that specific exchange. As such, a message may or may not have a URI as an identifier. NIEM was designed with the assumption that a given exchange need not have any unique identifier; NIEM does not require a unique identifier. NIEM also does not require any object (data instance) to be identified by a URI. This differs from RDF, in which all entities (other than literal values) are identified by globally meaningful URIs.</p><p>A NIEM-conformant instance uses XML IDs to identify objects within an XML document; The NIEM XML ID is an attribute <code>structures:id</code> of type <code>xs:ID</code>. These IDs are not assumed by NIEM to have any universal significance; they need only be unique within the XML document. The use of an ID is required only when an object must be referenced within the document. NIEM recognizes no correlation between these local IDs and any URI.</p><p>Any given implementation, message, or IEPD may be defined to apply a URI or other universally meaningful identifier to an object or message. However, NIEM has no such requirement.</p></div><div class="section"><a name="section_5.4"></a><div class="heading">5.4. NIEM data model is explicit, not implicit</div><p>In NIEM data, that which is not stated is not implied. If data says a person’s name is <q>John,</q> it is not implicitly saying that he does not have other names, or that <q>John</q> is his legal name, or that he is different from a person known as <q>Bob.</q> The only assertion being made is that one of the names by which this person is known is <q>John</q>.</p><p>This is one reason that definitions of NIEM content are so important. The definitions must state exactly what any given statement implies. The concept of <q>legal name</q> may be defined that makes additional assertions about a name of a person. Such assertions must be made explicit in the definition of the relationship.</p></div><div class="section"><a name="section_5.5"></a><div class="heading">5.5. NIEM data model implementation in XML Schema</div><p>NIEM defines rules for XML Schema documents that enforce the NIEM conceptual model. The schemas that follow these rules are referred to as <strong>NIEM-conformant schemas</strong>.</p><p>As discussed above, NIEM classes and properties are mapped onto XML Schema components. The following is an example of how a NIEM class for a <em>person</em> is rendered as an XML Schema complex type definition:</p><div class="figure"><a name="figure_5-1"></a><div class="caption">Figure 5-1: Conceptual class rendered as XML Schema complex type</div><div class="box"><pre>&lt;xs:complexType name="PersonType"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A data type for a human being.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="structures:ObjectType"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="nc:PersonBirthDate" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="nc:PersonBirthLocation" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="nc:PersonHeightMeasure" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="nc:PersonName" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="nc:PersonRace" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="nc:PersonSex" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="nc:PersonWeightMeasure" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;</pre></div></div><p>Note that the complex type definition incorporates not only the class itself, but also identifies properties that have a range (e.g., <code>rdfs:range</code>) of the class.</p><p>The following is an example of how a property for a <em>conveyance operator</em> is rendered as a NIEM element declaration:</p><div class="figure"><a name="figure_5-2"></a><div class="caption">Figure 5-2: Conceptual property rendered as element declaration</div><div class="box"><pre>&lt;xs:element name="ConveyanceOperator" type="nc:PersonType" nillable="true"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A person who operates or drives a conveyance.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</pre></div></div><p>NIEM also defines rules for XML documents that enforce the NIEM conceptual model. An XML document is a <span class="termRef"><a name="d3e2042" href="#definition_conformant_instance_XML_document">[conformant instance XML document]</a></span> if it follows the rules specified by the NIEM-conformant schema, as well as additional rules that are NIEM-specific. For example, in a NIEM-conformant XML document, a reference (<code>structures:ref</code>) must refer to a data element that is of an appropriate XML Schema type. If this is not the case, the document may be valid according to the schema, but it will not be a <span class="termRef"><a name="d3e2048" href="#definition_conformant_instance_XML_document">[conformant instance XML document]</a></span>.</p></div></div><div class="section"><a name="section_6"></a><div class="heading">6. Guiding principles</div><p>Principles in this specification provide a foundation for the rules. These principles are generally applicable in most cases. They should not be used as a replacement for common sense or appropriate special cases.</p><p>The principles are not operationally enforceable; they do not specify constraints on XML Schema documents and instances. The rules are the normative and enforceable manifestation of the principles.</p><p>The principles discussed in this section are categorized as follows:</p><ul><li>Specification Guidelines</li><li>XML Schema Design Guidelines</li><li>Modeling Design Guidelines</li><li>Implementation Guidelines</li></ul><div class="section"><a name="section_6.1"></a><div class="heading">6.1. Specification guidelines</div><p>The principles in this section address what material should be included in this NDR and how it should be represented.</p><div class="section"><a name="section_6.1.1"></a><div class="heading">6.1.1. Keep specification to a minimum</div><p>This specification should state what is required for interoperability, not all that could be specified. Certain decisions (such as normative XML comments) could create roadblocks for interoperability, making heavy demands on systems for very little gain. The goal is not standardization for standardization’s sake. The goal is to maximize interoperability and reuse.</p><div class="box"><a name="principle_1"><div class="normativeHead">[Principle 1]</div><div class="sub"><p>This specification SHOULD specify what is necessary for semantic interoperability and no more.</p></div></a></div><p>The term <strong>semantic interoperability</strong> is here defined as <q>the ability of two or more computer systems to exchange information and have the meaning of that information automatically interpreted by the receiving system accurately enough to produce useful results.</q> </p></div><div class="section"><a name="section_6.1.2"></a><div class="heading">6.1.2. Focus on rules for schemas</div><p>This specification should try, as much as is possible, to specify schema-level content. This is a specification for schemas, and so it should specify schemas. It should avoid specifying complex data models or data dictionaries.</p><div class="box"><a name="principle_2"><div class="normativeHead">[Principle 2]</div><div class="sub"><p>This specification SHOULD focus on providing rules for specifying schemas.</p></div></a></div></div><div class="section"><a name="section_6.1.3"></a><div class="heading">6.1.3. Use specific, concise rules</div><p>A rule should be as precise and specific as possible to avoid broad, hard-to-modify rules. Putting multiple clauses in a rule makes it harder to enforce. Using separate rules allows specific conditions to be clearly stated.</p><div class="box"><a name="principle_3"><div class="normativeHead">[Principle 3]</div><div class="sub"><p>This specification SHOULD feature rules thatare as specific, precise, and concise as possible.</p></div></a></div></div></div><div class="section"><a name="section_6.2"></a><div class="heading">6.2. XML Schema design guidelines</div><p>The principles in this section address how XML Schema technology should be used in designing NIEM-conformant schemas and instances.</p><div class="section"><a name="section_6.2.1"></a><div class="heading">6.2.1. Disallow content modification with XML processors</div><p>XML Schema has constructs that can make the data provided by XML processors different before and after schema processing. Anexample of this is the use of XML Schema attribute declarations with default values. Before schema validation, there may be no attribute value, but after processing, the attribute value exists.</p><p>Within NIEM, the purpose of processing instances against schemas is solely validation: testing that data instances match desired constraints and guidelines. It should not be used to change the content of data instances.</p><div class="box"><a name="principle_4"><div class="normativeHead">[Principle 4]</div><div class="sub"><p>The content of a NIEM-conformant data instance SHOULD NOT be modified by processing against XML Schema documents.</p></div></a></div></div><div class="section"><a name="section_6.2.2"></a><div class="heading">6.2.2. Use XML validating parsers for content validation</div><p>NIEM is designed for XML Schema validation. A primary goal is to maximize the amount of validation that may be performed by XML Schema-validating parsers.</p><p>XML Schema validates content using content models: descriptions of what elements and attributes may be contained within an element, and what values are allowable. It is the XML element hierarchy (elements with attributes and unstructured content, contained by other elements) that the XML Schema definition language specifies and that XML Schema validating parsers can validate.</p><p>Mechanisms involving linking using attribute and element values are useful, but they should only be relied on when absolutely necessary, as XML Schema-validating parsers cannot readily validate them. For example, if a link is established via attribute values, an XML Schema- validating parser cannot determine that participants have appropriate type definitions. Whenever possible, NIEM content should rely on XML syntax that can be validated with XML Schema.</p><div class="box"><a name="principle_5"><div class="normativeHead">[Principle 5]</div><div class="sub"><p>NIEM-conformant schemas and NIEM-conformant XML documents SHOULD use XML Schema validating parsers for validation of XML content.</p></div></a></div></div><div class="section"><a name="section_6.2.3"></a><div class="heading">6.2.3. Validate for conformance to reference schemas</div><p>Systems that operate on XML data have the opportunity to perform multiple layers of processing. Middleware, XML libraries, schemas, and application software may process data. The primary purpose of XML Schema validation is to restrict processed data to that data that conforms to agreed-upon rules. This restriction is achieved by marking as invalid that data that does not conform to the rules defined by the schema.</p><div class="box"><a name="principle_6"><div class="normativeHead">[Principle 6]</div><div class="sub"><p>Systems that use NIEM-conformant data SHOULD mark as invalid data that does not conform to the rules defined by applicable XML Schema documents.</p></div></a></div></div><div class="section"><a name="section_6.2.4"></a><div class="heading">6.2.4. Allow multiple schemas for XML constraints</div><p>The NIEM does not attempt to create a one-size-fits-all schema to perform all validation. Instead, it creates a set of reference schemas, on which additional constraints may be placed. It also does not focus on language-binding XML Schema implementations, which convert XML Schema definitions into working programs. It is, instead, focused on normalizing language and preserving the meaning of data.</p><div class="box"><a name="principle_7"><div class="normativeHead">[Principle 7]</div><div class="sub"><p>Constraints on XML instances MAY be validated by multiple schema validation passes, using multiple schemas for a single namespace.</p></div></a></div></div><div class="section"><a name="section_6.2.5"></a><div class="heading">6.2.5. Define one reference schema per namespace</div><p>NIEM uses the concept of a <em>reference schema</em>, which defines the structure and content of a namespace. For each NIEM-conformant namespace, there is exactly one NIEM reference schema. A user may use a subset schema or constraint schema in place of a reference schema, but all NIEM-conformant XML documents must validate against a single reference schema for each namespace.</p><div class="box"><a name="principle_8"><div class="normativeHead">[Principle 8]</div><div class="sub"><p>Each NIEM-conformant namespace SHOULD be defined by exactly one reference schema.</p></div></a></div></div><div class="section"><a name="section_6.2.6"></a><div class="heading">6.2.6. Disallow mixed content</div><p>XML data that use mixed content are difficult to specify and complicate the task of data processing. Much of the payload carried by mixed content is unchecked and does not facilitate data standardization or validation.</p><div class="box"><a name="principle_9"><div class="normativeHead">[Principle 9]</div><div class="sub"><p>NIEM-conformant schemas SHOULD NOT specify data that uses mixed content.</p></div></a></div></div><div class="section"><a name="section_6.2.7"></a><div class="heading">6.2.7. Specify types for all constructs</div><p>Schema components within NIEM all have names. This means that there are no anonymous types, elements, or other components defined by NIEM. Once an application has determined the name (i.e., namespace and local name) of an attribute or element used in NIEM-conformant instances, it will also know the type of that attribute or element.</p><p>There are no local attributes or elements defined by NIEM, only global attributes and elements. This maximizes the ability of application developers to extend, restrict, or otherwise derive definitions of local components from NIEM-conformant components. Using named global components in schemas maximizes the capacity for reuse.</p><div class="box"><a name="principle_10"><div class="normativeHead">[Principle 10]</div><div class="sub"><p>NIEM-conformant schemas SHOULD NOT use or define local or anonymous components, as they adversely affect reuse.</p></div></a></div></div><div class="section"><a name="section_6.2.8"></a><div class="heading">6.2.8. Avoid wildcards in reference schemas</div><p>Wildcards in NIEM-conformant schemas work in opposition to standardization. The goal of creating harmonized, standard schemas is to standardize definitions of data. The use of wildcard mechanisms (such as <code>xs:any</code>, which allows insertion of an arbitrary number of elements from any namespace) allows nonstandard data to be passed via otherwise standardized exchanges.</p><p>Avoidance of wildcards in the standard schemas encourages the separation of standardized and nonstandardized data. It encourages users to incorporate their data into NIEM in a standardized way. It also encourages users to extend in a way that may be readily incorporated into NIEM.</p><div class="box"><a name="principle_11"><div class="normativeHead">[Principle 11]</div><div class="sub"><p>NIEM-conformant components SHOULD NOT incorporate wildcards unless absolutely necessary, as they hinder standardization by encouraging use of nonstandardized data rather than standardized data.</p></div></a></div></div><div class="section"><a name="section_6.2.9"></a><div class="heading">6.2.9. Provide default reference schema locations</div><p> <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> provides three ways to specify the physical location of an XML Schema document: <code>schemaLocation</code>, an attribute of the element <code>xs:import</code>, along with <code>xsi:schemaLocation</code> and <code>xsi:noNamespaceSchemaLocation</code>, attributes of an XML Schema document element. In all of these uses, the specification explicitly maintains that the schema location specified is a hint, which may be overridden by applications.</p><div class="box"><a name="principle_12"><div class="normativeHead">[Principle 12]</div><div class="sub"><p>Schema locations specified within NIEM-conformant reference schemas SHOULD be interpreted as hints and as default values by processing applications.</p></div></a></div></div><div class="section"><a name="section_6.2.10"></a><div class="heading">6.2.10. Use open standards</div><p>The cooperative efforts of many knowledgeable individuals have resulted in many important published information standards. Where appropriate and applicable, NIEM ought to leverage these standards.</p><div class="box"><a name="principle_13"><div class="normativeHead">[Principle 13]</div><div class="sub"><p>NIEM standards and schemas SHOULD leverage and enable use of other open standards.</p></div></a></div></div></div><div class="section"><a name="section_6.3"></a><div class="heading">6.3. Modeling design guidelines</div><p>The principles in this section address the design philosophy used in designing the NIEM conceptual model.</p><div class="section"><a name="section_6.3.1"></a><div class="heading">6.3.1. Namespaces enhance reuse</div><p>NIEM is designed to maximize reuse of namespaces and the schemas that define them. When referring to a concept defined by NIEM, a user should ensure that instances and schemas refer to the namespace defined by NIEM. User-defined namespaces should be used for specializations and extension of NIEM constructs but should not be used when the NIEM structures are sufficient.</p><div class="box"><a name="principle_14"><div class="normativeHead">[Principle 14]</div><div class="sub"><p>NIEM-conformant instances and schemas SHOULD reuse components from NIEM distribution schemas when possible.</p></div></a></div><p>NIEM relies heavily on XML namespaces to prevent naming conflicts and clashes. Reuse of any component is always by reference to both its namespace and its local name. All NIEM component names have global scope. Therefore, validation always occurs against the reference schemas or subsets thereof.</p><p><strong>Example:</strong></p><div class="figure"><a name="figure_6-1"></a><div class="caption">Figure 6-1: Example of the use of a namespace</div><div class="box"><pre>&lt;xsd:element ref="nc:BinaryCaptureDate" minOccurs="0" maxOccurs="unbounded"/&gt;</pre></div></div><p>In this example, <code>nc:BinaryCaptureDate</code> is reused by referencing its element declaration through both its namespace (which is bound to the prefix <code>nc:</code>) and its local name (<code>BinaryCaptureDate</code>). If an element named <code>BinaryCaptureDate</code> is declared in another namespace, it is an entirely different element than <code>nc:BinaryCaptureDate</code>. There is no implicit relationship to <code>nc:BinaryCaptureDate</code>.</p><p>From a business perspective, the two elements are likely to be <em>related</em> in the sense that they may have very similar semantic meanings. They may have essentially the same meaning, but slightly different properties. Such a relationship may commonly exist. However, any relationship between the two elements must be made explicit using methods outlined in this document.</p><div class="box"><a name="principle_15"><div class="normativeHead">[Principle 15]</div><div class="sub"><p>A component SHOULD be identified by its local name together with its namespace. A namespace SHOULD be a required part of the name of a component. A component’s local name SHOULD NOT imply a relationship to components with similar names from other namespaces.</p></div></a></div></div><div class="section"><a name="section_6.3.2"></a><div class="heading">6.3.2. Design NIEM for extensibility</div><p>NIEM is designed to be extended. Numerous methods are considered acceptable in creating extended and specialized components.</p><div class="box"><a name="principle_16"><div class="normativeHead">[Principle 16]</div><div class="sub"><p>NIEM-conformant schemas and standards SHOULD be designed to encourage and ease extension and augmentation by users and developers outside the standardization process.</p></div></a></div></div></div><div class="section"><a name="section_6.4"></a><div class="heading">6.4. Implementation guidelines</div><p>The principles in this section address issues pertaining to the implementation of applications that use NIEM.</p><div class="section"><a name="section_6.4.1"></a><div class="heading">6.4.1. Avoid displaying raw XML data</div><p>XML data should be made human-understandable when possible, but it is not targeted at human consumers. HTML is intended for browsers. Browsers and similar technology provide human interfaces to XML and other structured content. As such, structured XML content does not belong in places targeting humans. Human-targeted information should be of a form suitable for presentation.</p><div class="box"><a name="principle_17"><div class="normativeHead">[Principle 17]</div><div class="sub"><p>XML data SHOULD be designed for automatic processing. XML data SHOULD NOT be designed for literal presentation to people. NIEM standards and schemas SHOULD NOT use literal presentation to people as a design criterion.</p></div></a></div></div><div class="section"><a name="section_6.4.2"></a><div class="heading">6.4.2. Leave implementation decisions to implementers</div><p>NIEM is intended to be an open specification supported by many diverse implementations. It was designed from data requirements and not from or for any particular system or implementation. Use of NIEM should not depend on specific software, other than XML Schema-validating parsers.</p><div class="box"><a name="principle_18"><div class="normativeHead">[Principle 18]</div><div class="sub"><p>NIEM SHOULD NOT depend on specific software packages, software frameworks, or software systems for interpretation of XML instances.</p></div></a></div><div class="box"><a name="principle_19"><div class="normativeHead">[Principle 19]</div><div class="sub"><p>NIEM schemas and standards SHOULD be designed such that software systems that use NIEM may be built with a variety of off-the-shelf and free software products.</p></div></a></div></div></div><div class="section"><a name="section_6.5"></a><div class="heading">6.5. Modeling guidelines</div><p>The NIEM Naming and Design Rules (NDR) specify NIEM-conformant components, schemas, and instances. These guidelines influence and shape the more-specific principles and rules in this document. They are derived from best practices and from discussions within the NIEM Business Architecture Committee (NBAC) and the NIEM Technical Architecture Committee (NTAC). This list may grow and evolve as NIEM matures.</p><p>The principles in this section address decisions that data modelers must face when creating NIEM-conformant schema representations of domain data. These guidelines are not absolute (the key word is SHOULD). It may not be possible to apply all guidelines in every case. However, they should always be considered.</p><div class="section"><a name="section_6.5.1"></a><div class="heading">6.5.1. Documentation</div><p>As will be described in later sections of this document, all NIEM components are documented through their definitions and names. Although it is often very difficult to apply, a data component definition should be drafted before the data component name is finalized.</p><p>Drafting the definition for a data component first ensures that the author understands the exact nature of the entity or concept that the data component represents. The component name should subsequently be composed to summarize the definition. Reversing this sequence often results in <span class="termRef"><a name="d3e2513" href="#definition_data_definition">[data definitions]</a></span> that very precisely describe the component name but do not adequately describe the entity or concept that the component is designed to represent. This can lead to the ambiguous use of such components.</p><div class="box"><a name="principle_20"><div class="normativeHead">[Principle 20]</div><div class="sub"><p>A data component definition SHOULD be drafted before the associated data element name is composed.</p></div></a></div></div><div class="section"><a name="section_6.5.2"></a><div class="heading">6.5.2. Consistent naming</div><p>Components in NIEM should be given names that are consistent with names of other NIEM components. Having consistent names for components has several advantages:</p><ol><li>It is easier to determine the nature of a component when it has a name that conveys the meaning and use of the component.</li><li>It is easier to find a component when it is named predictably.</li><li>It is easier to create a name for a component when clear guidelines exist.</li></ol><div class="box"><a name="principle_21"><div class="normativeHead">[Principle 21]</div><div class="sub"><p>Components in NIEM SHOULD be given names that are consistent with names of other NIEM components. Such names SHOULD be based on simple rules.</p></div></a></div></div><div class="section"><a name="section_6.5.3"></a><div class="heading">6.5.3. Reflect the real world</div><p>NIEM provides a standard for data exchange. To help facilitate unambiguous understanding of NIEM reusable components, the names and structures should represent and model the informational aspects of objects and concepts that users are most familiar with. Types should not simply model collections of data.</p><div class="box"><a name="principle_22"><div class="normativeHead">[Principle 22]</div><div class="sub"><p>Component definitions in NIEM-conformant schemas SHOULD reflect real-world concepts.</p></div></a></div></div><div class="section"><a name="section_6.5.4"></a><div class="heading">6.5.4. Be consistent</div><p>There should be no conflicts of meaning among types. This holds for types within a namespace, as well as types in different namespaces. A type should be used consistently in similar situations for similar purposes. Types should be defined for clear understanding and ease of intended use.</p><div class="box"><a name="principle_23"><div class="normativeHead">[Principle 23]</div><div class="sub"><p>Component definitions in NIEM-conformant schemas SHOULD have semantic consistency.</p></div></a></div></div><div class="section"><a name="section_6.5.5"></a><div class="heading">6.5.5. Reserve inheritance for specialization</div><p>Specialization should not be applied simply for the sake of achieving property inheritance. Specialization should be applied only where it is meaningful and appropriate to model permanent sibling subclasses of a base class that are mutually exclusive of one another.</p><div class="box"><a name="principle_24"><div class="normativeHead">[Principle 24]</div><div class="sub"><p>Complex type definitions in NIEM-conformant schemas SHOULD use type inheritance only for specialization.</p></div></a></div><p>Note that application of type augmentations is a well-defined exception to this guideline.</p></div><div class="section"><a name="section_6.5.6"></a><div class="heading">6.5.6. Do not duplicate definitions</div><p>A real-world entity should be modeled in only one way. The definition of a type or element should appear once and only once. Multiple components of identical or closely similar semantics hinder interoperability because too many valid methods exist for representing the same data. For each data concept that must be represented, there should be only one component (and associated type) to represent it.</p><p>Components with very similar semantics may exist in different contexts. For example, a complex type created for a particular exchange may appear to have identical or closely similar semantics to a complex type defined in the NIEM Core schema. However, the type defined at the exchange level will have much more precise business requirements and syntax, compared with the broad definitions that are heavily reused. Specific contextual definitions should be considered semantic changes. This includes the application of augmentations to create a specialized type for a specific use.</p><p>Two components may have the same definition while having different representations. For example, a string may hold the complete name of a person, or the name may be represented by a structure that separates the components of the name into first, last, etc. The definition of alternative representations should not be considered duplication.</p><div class="box"><a name="principle_25"><div class="normativeHead">[Principle 25]</div><div class="sub"><p>Multiple components with identical or undifferentiated semantics SHOULD NOT be defined. Component definitions SHOULD have clear, explicit distinctions.</p></div></a></div></div><div class="section"><a name="section_6.5.7"></a><div class="heading">6.5.7. Keep it simple</div><p>All NIEM content and structure is fundamentally based on business requirements for information exchange. To encourage adoption and use in practice, NIEM must implement business requirements in simple, consistent, practical ways.</p><div class="box"><a name="principle_26"><div class="normativeHead">[Principle 26]</div><div class="sub"><p>NIEM-conformant schemas SHOULD have the simplest possible structure, content, and architecture consistent with real business requirements.</p></div></a></div></div><div class="section"><a name="section_6.5.8"></a><div class="heading">6.5.8. Be aware of scope</div><p>The scope of components defined in NIEM-conformant schemas should be carefully considered. Some components represent simple data values, while others represent complex objects with many parts and relationships. Components should exist in layers. Components should exist as small, narrowly scoped, atomic entities that are used to consistently construct more broadly scoped, complex components (and so on).</p><div class="box"><a name="principle_27"><div class="normativeHead">[Principle 27]</div><div class="sub"><p>Components defined by NIEM-conformant schemas SHOULD be defined appropriate for their scope.</p></div></a></div></div><div class="section"><a name="section_6.5.9"></a><div class="heading">6.5.9. Be mindful of namespace cohesion</div><p>Namespaces should maximize cohesion. The namespace methodology helps prevent name clashes among communities or domains that have different business perspectives and may choose identical data names to represent different data concepts. A namespace should be designed so that its components are consistent, may be used together, and may be updated at the same time.</p><div class="box"><a name="principle_28"><div class="normativeHead">[Principle 28]</div><div class="sub"><p>XML namespaces defined by NIEM-conformant schemas SHOULD encapsulate data components that are coherent, consistent, and internally related as a set. A namespace SHOULD encapsulate components that tend to change together.</p></div></a></div></div></div></div><div class="section"><a name="section_7"></a><div class="heading">7. Conformance to standards</div><div class="section"><a name="section_7.1"></a><div class="heading">7.1. Conformance to XML</div><div class="box"><a name="rule_7-1"></a><div class="normativeHead">[Rule 7-1] (REF, EXT, INS) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[. is nf:get-document-element(.)]"&gt;
    &lt;sch:report test="true()"&gt;The document MUST be a well-formed XML document, as defined by Extensible Markup Language.&lt;/sch:report&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>See <a href="#XML" class="ref">[XML]</a> for the normative definition of <em>well-formed XML document</em>.</p></div><div class="section"><a name="section_7.2"></a><div class="heading">7.2. Conformance to XML Namespaces</div><div class="box"><a name="rule_7-2"></a><div class="normativeHead">[Rule 7-2] (REF, EXT, INS) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[. is nf:get-document-element(.)]"&gt;
    &lt;sch:report test="true()"&gt;The document MUST be namespace-well-formed.&lt;/sch:report&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;            </pre></div><p>The term <em>namespace-well-formed</em> is normatively defined by <a href="#XMLNamespaces" class="ref">[XML Namespaes]</a> and <a href="#XMLNamespacesErrata" class="ref">[XML Namespaces Errata]</a>.</p><div class="box"><a name="rule_7-3"></a><div class="normativeHead">[Rule 7-3] (REF, EXT, INS) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[. is nf:get-document-element(.)]"&gt;
    &lt;sch:report test="true()"&gt;The document MUST be namespace-valid.&lt;/sch:report&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;            </pre></div><p>The term <em>namespace-valid</em> is normatively defined by <a href="#XMLNamespaces" class="ref">[XML Namespaes]</a> and <a href="#XMLNamespacesErrata" class="ref">[XML Namespaces Errata]</a>.</p></div><div class="section"><a name="section_7.3"></a><div class="heading">7.3. Conformance to XML Schema</div><div class="box"><a name="rule_7-4"></a><div class="normativeHead">[Rule 7-4] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[. is nf:get-document-element(.)]"&gt;
    &lt;sch:report test="true()"&gt;The document MUST be a schema document.&lt;/sch:report&gt;
    &lt;sch:assert test="self::xs:schema"
      &gt;The document element of the XML document must be xs:schema.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;            </pre></div><p>The term <em>schema document</em> is defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a>.</p></div><div class="section"><a name="section_7.4"></a><div class="heading">7.4. ISO 11179 Part 4</div><p>Good data definitions are fundamental to data interoperability. You cannot effectively exchange what you cannot understand. NIEM employs the guidance of <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> as a baseline for its data component definitions. <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> All NIEM components are documented.</p><p>To advance the goal of creating semantically rich NIEM-conformant schemas, it is necessary that data definitions be descriptive, meaningful, and precise. <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> provides standard structure and rules for defining data definitions. NIEM uses this standard for component definitions.</p><p>Note that the metadata maintained for each NIEM component contains additional details, including domain-specific usage examples and keywords. Such metadata is used to enhance search and discovery of components in a registry, and therefore, is not included in schemas.</p><p>For convenience and reference, the summary requirements and recommendations in <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> are reproduced here:</p><blockquote><p><strong>ISO 11179 Requirements</strong></p><p>A data definition SHALL:</p><ul><li>Be stated in the singular.</li><li>State what the concept is, not only what it is not.</li><li>Be stated as a descriptive phrase or sentence(s).</li><li>Contain only commonly understood abbreviations.</li><li>Be expressed without embedding definitions of other data or underlying concepts.</li></ul><p><strong>ISO 11179 Recommendations</strong></p><p>A data definition SHOULD:</p><ul><li>State the essential meaning of the concept.</li><li>Be precise and unambiguous.</li><li>Be concise.</li><li>Be able to stand alone.</li><li>Be expressed without embedding rationale, functional usage, or procedural information.</li><li>Avoid circular reasoning.</li><li>Use the same terminology and consistent logical structure for related definitions.</li><li>Be appropriate for the type of metadata item being defined.</li></ul></blockquote><p>In addition to the requirements and recommendations of <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a>, NIEM applies additional rules to data definitions. These rules are detailed in <a href="#section_11.4.1">Section 11.4.1, <em>Human-readable documentation</em>, below</a>.</p><p>These definitions leverage the term <q>definition</q> as defined by <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a>:</p><blockquote><p>representation of a concept by a descriptive statement which serves to differentiate it from related concepts</p></blockquote><div class="box"><a name="definition_data_definition"></a><div class="normativeHead">[Definition: <dfn>data definition</dfn>]</div><div class="sub"><p>The <strong>data definition</strong> of a schema component is the content of the first occurrence of the element <code>xs:documentation</code> that is an immediate child of an occurrence of an element <code>xs:annotation</code> that is an immediate child of the element that defines the component.</p></div></div><div class="box"><a name="definition_documented_component"></a><div class="normativeHead">[Definition: <dfn>documented component</dfn>]</div><div class="sub"><p>In a NIEM-conformant schema, a <strong>documented component</strong> is an XML Schema component that has an associated <span class="termRef"><a name="d3e2949" href="#definition_data_definition">[data definition]</a></span>. Each documented component has a textual definition, so that the component may be well-understood.</p></div></div><p>An example of a data definition is provided in <a href="#figure_7-1">Figure 7-1, <em>Example of data definition of element <code>nc:Activity</code></em>, below</a>.</p><div class="figure"><a name="figure_7-1"></a><div class="caption">Figure 7-1: Example of data definition of element <code>nc:Activity</code></div><div class="box"><pre>&lt;xs:element name="Activity" type="nc:ActivityType" nillable="true"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A single or set of related actions, events, or process steps.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</pre></div></div><p>See <a href="#rule_11-29"><strong>[Rule 11-29]</strong>, below,</a> and <a href="#rule_11-30"><strong>[Rule 11-30]</strong>, below,</a> for application of <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> to constrain NIEM <span class="termRef"><a name="d3e2989" href="#definition_data_definition">[data definitions]</a></span>.</p></div><div class="section"><a name="section_7.5"></a><div class="heading">7.5. ISO 11179 Part 5</div><p>Names are a simple but incomplete means of providing semantics to data components. Data definitions, structure, and context help to fill the gap left by the limitations of naming. The goals for data component names should be syntactic consistency, semantic precision, and simplicity. In many cases, these goals conflict and it is sometimes necessary to compromise or to allow exceptions to ensure clarity and understanding. To the extent possible, NIEM applies <a href="#ISO11179-5" class="ref">[ISO 11179-5]</a> to construct NIEM data component names.</p><p>The set of NIEM data components is a collection of data representations for real-world objects and concepts, along with their associated properties and relationships. Thus, names for these components would consist of the terms (words) for object classes or that describe object classes, their characteristic properties, subparts, and relationships.</p><div class="section"><a name="section_7.5.1"></a><div class="heading">7.5.1. Component names follow ISO 11179 Part 5 Annex A</div><div class="box"><a name="rule_7-5"></a><div class="normativeHead">[Rule 7-5] (REF, EXT) (Constraint)</div><p>A NIEM component name SHALL be formed by applying the informative guidelines and examples detailed in Annex A of <a href="#ISO11179-5" class="ref">[ISO 11179-5]</a>, with exceptions as specified in this document, most notably those specified in Section 9, Naming Rules.</p></div><p>The guidelines and examples of <a href="#ISO11179-5" class="ref">[ISO 11179-5]</a> provide a simple, consistent syntax for data names that captures context and thereby imparts a reasonable degree of semantic precision.</p><p>NIEM uses the guidelines and examples of <a href="#ISO11179-5" class="ref">[ISO 11179-5]</a> as a baseline for normative naming rules. However, some NIEM components require bending of these rules. Special naming rules for these classes of components are presented and discussed in Section 9. In spite of these exceptions, most NIEM component names can be disassembled into their <a href="#ISO11179-5" class="ref">[ISO 11179-5]</a> constituent words or terms.</p></div><p><strong>Example:</strong></p><p>The NIEM component name <code>AircraftFuselageColorCode</code> disassembles as follows:</p><ul><li>Object class term = <q><code>Aircraft</code></q></li><li>Qualifier term = <q><code>Fuselage</code></q></li><li>Property term = <q><code>Color</code></q></li><li>Representation term = <q><code>Code</code></q></li></ul><p>Section 9, Naming Rules, details the specific rules for each kind of term and how to construct NIEM component names from it. Exceptions for special components are also described in Section 9.</p></div></div><div class="section"><a name="section_8"></a><div class="heading">8. Strategy for a NIEM profile of XML Schema</div><div class="section"><a name="section_8.1"></a><div class="heading">8.1. Wildcards</div><p>There are many constructs within XML Schema that act as wildcards. That is, they introduce buckets that may carry arbitrary or otherwise nonvalidated content. Such constructs violate [Principle 11], and as such provide implicit workarounds for the difficult task of agreeing on the content of data models. Such workarounds should be made explicitly, outside the core data model.</p><p>The following restrictions help to ban wildcards and arbitrary data:</p><ul><li>Use of the type <code>xs:anyType</code> is prohibited.</li><li>Use of the type <code>xs:anySimpleType</code> is prohibited in most cases.</li><li>Use of the element <code>xs:any</code> is prohibited in reference schemas.</li><li>Use of the element <code>xs:anyAttribute</code> is prohibited in reference schemas.</li></ul></div><div class="section"><a name="section_8.2"></a><div class="heading">8.2. Components are globally reusable</div><p>Each component defined by a NIEM-conformant schema may be reused from outside the schema document. Every NIEM component has a name. That is, type definitions, and element and attribute declarations are given explicit names; local and anonymous component definition is not allowed.</p><p>This is supported by the following restrictions:</p><ul><li>Each declaration of an element, attribute, or type is a top-level component (child of <code>xs:schema</code>, rather than a local component defined within another component.</li><li>There are no anonymous type declarations.</li></ul><p>Additional restrictions ensure that NIEM components are also defined such that new components may be derived from them and substituted for them. Reference schemas are defined to maximize reuse, while extension schemas are defined to enable a developer to customize schema definitions to match her exchange needs. In reference schemas, the following restrictions help enforce reusability through extension and substitution:</p><ul><li>A <span class="termRef"><a name="d3e3168" href="#definition_conformant_reference_schema_document">[conformant reference schema document]</a></span> or <span class="termRef"><a name="d3e3171" href="#definition_conformant_extension_schema_document">[conformant extension schema document]</a></span> may not use <code>blockDefault</code> or <code>finalDefault</code>.</li><li>Element and type declarations in a <span class="termRef"><a name="d3e3186" href="#definition_conformant_reference_schema_document">[conformant reference schema document]</a></span> may not use <code>block</code> or <code>final</code>.</li></ul><p class="todo">Add, to the above, cross-references to specific rules</p></div><div class="section"><a name="section_8.3"></a><div class="heading">8.3. Avoid recursive model groups</div><p>XML Schema provides the capability for model groups to be recursively defined. This means that a sequence may contain a sequence, and a choice may contain a choice. These rules are designed to keep content models simple, comprehensive, and reusable: The content of an element should boil down to a simple list of elements, defined in as straightforward a manner as is possible to meet requirements.</p></div><div class="section"><a name="section_8.4"></a><div class="heading">8.4. Ensure schema processing does not alter processed data</div><p>XML Schema provides the capability for element and attribute declarations to provide default values when XML instances using those components do not provide values. This is done through the use of the attributes <code>default</code> and <code>fixed</code>, both of which provide default values to attributes and element content.</p><p>The use of default values means that the act of validating a schema will insert a value into an XML instance where none existed prior to schema validation. Schema validation is for rejection of invalid instances, not for modifying instance content, as specified in [Principle 4].</p><p>The transparency of validation to data content is ensured through a prohibition on the use of <code>default</code> and <code>fixed</code> attributes in NIEM-conformant schema documents.</p></div><div class="section"><a name="section_8.5"></a><div class="heading">8.5. Use namespaces rigorously</div><p>Require that every component defined by or used in a NIEM schema has a target namespace.</p><p>XML Schema requires that namespaces used in external references be imported using the <code>xs:import</code> element. The <code>xs:import</code> element appears as an immediate child of the <code>xs:schema</code> element. A schema must import any namespace which is not the local namespace, and which is referenced from the schema.</p><p>The behavior of import statements is not necessarily intuitive. In short, the import introduces namespace into the schema in which the import appears; it has no transitive effect. If the namespaces of an import statement are not referenced from the schema, then the import statement has no effect. </p><p>Certain tools have been seen introducing transitive behavior on imports, which is not portable across XML Schema validating parsers. If namespace 1 imports namespace 2 which imports namespace 3, a reference from namespace 1 to namespace 3 is not legal; namespace 1 must explicitly import namespace 3. A tool that imports transitively may allow schema 1 to reference 3 without a direct import of namespace 3. This is prohibited by rules which require imports of namespaces of referenced components.</p></div><div class="section"><a name="section_8.6"></a><div class="heading">8.6. Documentation is for people; appinfo is for machines</div><p>The XML Schema specification defines two types of annotations: <em>user information</em> and <em>application information</em>. It defines that user information is for human consumption, while application information is for automatic processing. </p><p>Annotations in XML Schema <q>provide for human- and machine-targeted annotations of schema components.</q> <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> The two types: human-targeted and machine-targeted, are kept separate by the use of two separate container elements defined by XML Schema: <code>xs:documentation</code> and <code>xs:appinfo</code>.</p><p>XML Schema describes the content of <code>xs:documentation</code> elements as <q>user information.</q> This information is targeted for reading by humans. The XML Schema specification does not say what form human-targeted information should take. Within NIEM, user information is plain text with no formatting or XML structure.</p><p>According to the XML Schema specification, the content of <code>xs:documentation</code> elements is intended for human consumption, whereas other structured XML content is intended for machine consumption. Therefore, the <code>xs:documentation</code> element MUST NOT contain structured XML data. As such, any XML content appearing within a documentation element is in the context of human-targeted examples and should be escaped using <code>&amp;lt;</code> and <code>&amp;gt;</code>. This rule also prohibits comments within documentation elements.</p><p>XML comments are not XML Schema constructs and are not specifically associated with any schema-based components. As such, comments are not considered semantically meaningful by NIEM and may not be retained through processing of NIEM schemas.</p></div></div><div class="section"><a name="section_9"></a><div class="heading">9. Rules for a NIEM profile of XML Schema</div><p>NIEM-conformant schemas use a profile of XML Schema. The W3C XML Schema Language provides many features that allow a developer to represent a data model many different ways. A number of XML Schema constructs are not used within NIEM-conformant schemas. Many of these constructs provide capability that is not currently needed within NIEM. Some of these constructs create problems for interoperability, with tool support, or with clarity or precision of data model definition.</p><p>This section establishes a profile of XML Schema for NIEM-conformant schemas. Because the XML Schema specifications are flexible, comprehensive rules are needed to achieve a balance between establishing uniform schema design and providing developers flexibility to solve novel data modeling problems.</p><p>Note that external schemas (i.e., non-NIEM-conformant schemas) do not need to obey the rules set forth in this section. So long as schema components from external schemas are adapted for use with NIEM according to the modeling rules in Section 7.7, they may be used as they appear in the external standard, even if the schema components themselves violate the rules for NIEM-conformant schemas.</p><p>The following sections are broken down in the order provided by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#concepts-data-model">§2.2, <em>XML Schema Abstract Data Model</em></a>, followed by a section on a schema document as a whole and a section on schema namespaces and assembly:</p><ul><li><a href="#section_9.1">Section 9.1, <em>Type definition components</em></a></li><li><a href="#section_9.2">Section 9.2, <em>Declaration components</em></a></li><li><a href="#section_9.3">Section 9.3, <em>Model group components</em></a></li><li><a href="#section_9.4">Section 9.4, <em>Identity-constraint definition components</em></a></li><li><a href="#section_9.5">Section 9.5, <em>Group definition components</em></a></li><li><a href="#section_9.6">Section 9.6, <em>Annotation components</em></a></li><li><a href="#section_9.7">Section 9.7, <em>Schema as a whole</em></a></li><li><a href="#section_9.8">Section 9.8, <em>Schema assembly</em></a></li></ul><p class="todo">add issue about requiring imports of referenced components</p><div class="section"><a name="section_9.1"></a><div class="heading">9.1. Type definition components</div><div class="section"><a name="section_9.1.1"></a><div class="heading">9.1.1. Type definition hierarchy</div><div class="section"><a name="section_9.1.1.1"></a><div class="heading">9.1.1.1. Types prohibited as base types</div><div class="section"><a name="section_9.1.1.1.1"></a><div class="heading">9.1.1.1.1. No base type of <code>xs:ID</code></div><div class="box"><a name="rule_9-1"></a><div class="normativeHead">[Rule 9-1] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@base)]"&gt;
    &lt;sch:assert test="resolve-QName(@base, .) != xs:QName('xs:ID')"
      &gt;A schema component MUST NOT have an attribute {}base with a value of xs:ID.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.1.1.2"></a><div class="heading">9.1.1.1.2. No base type of <code>xs:IDREF</code></div><div class="box"><a name="rule_9-2"></a><div class="normativeHead">[Rule 9-2] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@base)]"&gt;
    &lt;sch:assert test="resolve-QName(@base, .) != xs:QName('xs:IDREF')"
      &gt;A schema component MUST NOT have an attribute {}base with a value of xs:IDREF.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.1.1.3"></a><div class="heading">9.1.1.1.3. No base type of <code>xs:anyType</code></div><div class="box"><a name="rule_9-3"></a><div class="normativeHead">[Rule 9-3] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@base)]"&gt;
    &lt;sch:assert test="resolve-QName(@base, .) != xs:QName('xs:anyType')"
      &gt;A schema component MUST NOT have an attribute {}base with a value of xs:anyType.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>XML Schema has the concept of the <q>ur-type,</q> a type that is the root of all other types. This type is realized in schemas as <code>xs:anyType</code>.</p><p>NIEM-conformant schemas must not use <code>xs:anyType</code>, because this feature permits the introduction of arbitrary content (i.e., untyped and unconstrained data) into an XML instance. NIEM intends that the schemas describing that instance describe all constructs within the instance.</p></div><div class="section"><a name="section_9.1.1.1.4"></a><div class="heading">9.1.1.1.4. No base type of <code>xs:anySimpleType</code></div><div class="box"><a name="rule_9-4"></a><div class="normativeHead">[Rule 9-4] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@base)]"&gt;
    &lt;sch:assert test="resolve-QName(@base, .) != xs:QName('xs:anySimpleType')"
      &gt;A schema component MUST NOT have an attribute {}base with a value of xs:anySimpleType.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>XML Schema provides a restriction of the <q>ur-type</q> that contains only simple content. This provides a wildcard for arbitrary text. It is realized in XML Schema as <code>xs:anySimpleType</code>.</p><p>NIEM-conformant schemas must not use <code>xs:anySimpleType</code> because this feature is insufficiently constrained to provide a meaningful starting point for content definitions. Instead, content should be based on one of the more specifically defined simple types defined by XML Schema.</p></div><div class="section"><a name="section_9.1.1.1.5"></a><div class="heading">9.1.1.1.5. No base type of <code>xs:NOTATION</code></div><div class="box"><a name="rule_9-5"></a><div class="normativeHead">[Rule 9-5] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@base)]"&gt;
    &lt;sch:assert test="resolve-QName(@base, .) != xs:QName('xs:NOTATION')"
      &gt;A schema component MUST NOT have an attribute {}base with a value of xs:NOTATION.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>XML Schema notations allow the attachment of system and public identifiers on fields of data. The notation mechanism does not play a part in validation of instances and is not supported by NIEM.</p></div></div></div><div class="section"><a name="section_9.1.2"></a><div class="heading">9.1.2. Simple type definition</div><div class="section"><a name="section_9.1.2.1"></a><div class="heading">9.1.2.1. Simple type definition is top-level</div><div class="box"><a name="rule_9-6"></a><div class="normativeHead">[Rule 9-6] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleType"&gt;
    &lt;sch:assert test="exists(parent::xs:schema)"
      &gt;A simple type definition MUST be top-level.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>NIEM does not support anonymous types in NIEM-conformant schemas. All XML Schema <q>top-level</q> types (children of the document element) are required by XML Schema to be named. By requiring NIEM type definitions to be top level, they are forced to be named and are globally reusable.</p></div><div class="section"><a name="section_9.1.2.2"></a><div class="heading">9.1.2.2. Simple type data definitions</div><div class="section"><a name="section_9.1.2.2.1"></a><div class="heading">9.1.2.2.1. Simple type has data definition</div><div class="box"><a name="rule_9-7"></a><div class="normativeHead">[Rule 9-7] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleType"&gt;
    &lt;sch:assert test="exists(xs:annotation/xs:documentation)"
      &gt;A simple type MUST be a documented component.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.2.2.2"></a><div class="heading">9.1.2.2.2. Simple type data definition is not empty</div><div class="box"><a name="rule_9-8"></a><div class="normativeHead">[Rule 9-8] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleType/xs:annotation/xs:documentation[
                         . is (../../xs:annotation/xs:documentation)[1]]"&gt;
    &lt;sch:assert test="string-length(normalize-space(string-join(text(), ''))) &amp;gt; 0"
      &gt;A data definition MUST NOT be empty.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.1.2.3"></a><div class="heading">9.1.2.3. Simple types prohibited as list item types</div><p>There is no explicit prohibition on the use of xs:NOTATION as list item type, because it is prohibited by <a href="#XMLSchema-2" class="ref">[XML Schema Datatypes]</a>.</p><p>There is no prohibition on <code>xs:anyType</code> as a list item type, because xs:anyType is not a simple type.</p><div class="section"><a name="section_9.1.2.3.1"></a><div class="heading">9.1.2.3.1. No list item type of <code>xs:ID</code></div><div class="box"><a name="rule_9-9"></a><div class="normativeHead">[Rule 9-9] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@itemType)]"&gt;
    &lt;sch:assert test="resolve-QName(@itemType, .) != xs:QName('xs:ID')"
      &gt;A schema component MUST NOT have an attribute {}itemType with a value of xs:ID.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.2.3.2"></a><div class="heading">9.1.2.3.2. No list item type of <code>xs:IDREF</code></div><div class="box"><a name="rule_9-10"></a><div class="normativeHead">[Rule 9-10] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@itemType)]"&gt;
    &lt;sch:assert test="resolve-QName(@itemType, .) != xs:QName('xs:IDREF')"
      &gt;A schema component MUST NOT have an attribute {}itemType with a value of xs:IDREF.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.2.3.3"></a><div class="heading">9.1.2.3.3. No list item type of <code>xs:anySimpleType</code></div><div class="box"><a name="rule_9-11"></a><div class="normativeHead">[Rule 9-11] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@itemType)]"&gt;
    &lt;sch:assert test="resolve-QName(@itemType, .) != xs:QName('xs:anySimpleType')"
      &gt;A schema component MUST NOT have an attribute {}itemType with a value of xs:anySimpleType.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.1.2.4"></a><div class="heading">9.1.2.4. Simple types prohibited as union member types</div><p>There is no explicit prohibition on the use of xs:NOTATION as a union member type, because it is prohibited by <a href="#XMLSchema-2" class="ref">[XML Schema Datatypes]</a>.</p><p>There is no prohibition on <code>xs:anyType</code> as a union member type, because xs:anyType is not a simple type.</p><div class="section"><a name="section_9.1.2.4.1"></a><div class="heading">9.1.2.4.1. No union member types of <code>xs:ID</code></div><div class="box"><a name="rule_9-12"></a><div class="normativeHead">[Rule 9-12] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@memberTypes)]"&gt;
    &lt;sch:assert test="every $type-qname 
                      in tokenize(normalize-space(@memberTypes), ' ')
                      satisfies resolve-QName($type-qname, .) != xs:QName('xs:ID')"
      &gt;A schema component MUST NOT have an attribute {}memberTypes that includes a value of xs:ID.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.2.4.2"></a><div class="heading">9.1.2.4.2. No union member types of <code>xs:IDREF</code></div><div class="box"><a name="rule_9-13"></a><div class="normativeHead">[Rule 9-13] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@memberTypes)]"&gt;
    &lt;sch:assert test="every $type-qname 
                      in tokenize(normalize-space(@memberTypes), ' ')
                      satisfies resolve-QName($type-qname, .) != xs:QName('xs:IDREF')"
      &gt;A schema component MUST NOT have an attribute {}memberTypes that includes a value of xs:IDREF.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.2.4.3"></a><div class="heading">9.1.2.4.3. No union member types of <code>xs:anySimpleType</code></div><div class="box"><a name="rule_9-14"></a><div class="normativeHead">[Rule 9-14] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@memberTypes)]"&gt;
    &lt;sch:assert test="every $type-qname 
                      in tokenize(normalize-space(@memberTypes), ' ')
                      satisfies resolve-QName($type-qname, .) != xs:QName('xs:anySimpleType')"
      &gt;A schema component MUST NOT have an attribute {}memberTypes that includes a value of xs:anySimpleType.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.1.2.5"></a><div class="heading">9.1.2.5. No simple type disallowed derivation</div><div class="box"><a name="rule_9-15"></a><div class="normativeHead">[Rule 9-15] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleType"&gt;
    &lt;sch:assert test="empty(@final)"
      &gt;An element xs:simpleType MUST NOT have an attribute {}final.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.2.6"></a><div class="heading">9.1.2.6. Enumeration data definitions</div><div class="section"><a name="section_9.1.2.6.1"></a><div class="heading">9.1.2.6.1. Enumeration has data definition</div><div class="box"><a name="rule_9-16"></a><div class="normativeHead">[Rule 9-16] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:enumeration"&gt;
    &lt;sch:assert test="exists(xs:annotation/xs:documentation)"
      &gt;An enumeration facet MUST be a documented component.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.2.6.2"></a><div class="heading">9.1.2.6.2. Enumeration data definition is not empty</div><div class="box"><a name="rule_9-17"></a><div class="normativeHead">[Rule 9-17] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:enumeration/xs:annotation/xs:documentation[
                         . is (../../xs:annotation/xs:documentation)[1]]"&gt;
    &lt;sch:assert test="string-length(normalize-space(string-join(text(), ''))) &amp;gt; 0"
      &gt;A data definition MUST NOT be empty.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_9.1.3"></a><div class="heading">9.1.3. Complex type definitions</div><div class="section"><a name="section_9.1.3.1"></a><div class="heading">9.1.3.1. Complex type definitions are top-level</div><div class="box"><a name="rule_9-18"></a><div class="normativeHead">[Rule 9-18] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:assert test="exists(parent::xs:schema)"
      &gt;A complex type definition must be top-level.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Note that this implies that every <code>xs:complexType</code> element has a <code>name</code> attribute.</p></div><div class="section"><a name="section_9.1.3.2"></a><div class="heading">9.1.3.2. Complex type data definitions</div><div class="section"><a name="section_9.1.3.2.1"></a><div class="heading">9.1.3.2.1. Complex type has data definition</div><div class="box"><a name="rule_9-19"></a><div class="normativeHead">[Rule 9-19] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:assert test="exists(xs:annotation/xs:documentation)"
      &gt;A complex type MUST be a documented component.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.3.2.2"></a><div class="heading">9.1.3.2.2. Complex type data definition is not empty</div><div class="box"><a name="rule_9-20"></a><div class="normativeHead">[Rule 9-20] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType/xs:annotation/xs:documentation[
                         . is (../../xs:annotation/xs:documentation)[1]]"&gt;
    &lt;sch:assert test="string-length(normalize-space(string-join(text(), ''))) &amp;gt; 0"
      &gt;A data definition MUST NOT be empty.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.1.3.3"></a><div class="heading">9.1.3.3. No mixed content</div><div class="section"><a name="section_9.1.3.3.1"></a><div class="heading">9.1.3.3.1. No mixed content on complex type</div><div class="box"><a name="rule_9-21"></a><div class="normativeHead">[Rule 9-21] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[exists(@mixed)]"&gt;
    &lt;sch:assert test="xs:boolean(@mixed) = false()"
      &gt;A complex type declaration MUST NOT have mixed content.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Mixed content allows the mixing of data tags with text. Languages such as XHTML use this syntax for markup of text. NIEM-conformant schemas define XML that is for data exchange, not text markup. Mixed content creates complexity in processing, defining, and constraining content.</p><p>Well-defined markup languages exist outside NIEM and may be used with NIEM data. External schemas may include mixed content and may be used with NIEM. However, mixed content must not be defined by NIEM-conformant schemas in keeping with [Principle 9].</p></div><div class="section"><a name="section_9.1.3.3.2"></a><div class="heading">9.1.3.3.2. No mixed content on complex content</div><div class="box"><a name="rule_9-22"></a><div class="normativeHead">[Rule 9-22] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexContent[exists(@mixed)]"&gt;
    &lt;sch:assert test="xs:boolean(@mixed) = false()"
      &gt;A complex type declaration MUST NOT have mixed content.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>See <a href="#rule_9-21"><strong>[Rule 9-21]</strong>, above,</a> for the rationale for this rule.</p></div></div><div class="section"><a name="section_9.1.3.4"></a><div class="heading">9.1.3.4. Complex type content is explicitly simple or complex</div><div class="box"><a name="rule_9-23"></a><div class="normativeHead">[Rule 9-23] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:assert test="exists(xs:simpleContent) or exists(xs:complexContent)"
      &gt;An element xs:complexType MUST have a child element xs:simpleContent or xs:complexContent.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>XML Schema provides shorthand to defining complex content of a complex type, which is to define the complex type with immediate children that specify elements, or other groups, and attributes. In the desire to normalize schema representation of types and to be explicit, NIEM forbids the use of that shorthand.</p></div><div class="section"><a name="section_9.1.3.5"></a><div class="heading">9.1.3.5. Complex content</div><p>Within a reference schema, a complex type with complex content can be created in one of two ways:</p><ol><li>By extension of an existing NIEM complex type with complex content.</li><li>By extension of a type defined in the structures namespace.</li></ol><p>Both of these methods use the element <code>xs:extension</code>. Within extension schemas, exchange schemas, and subset schemas, the use of <code>xs:restriction</code> to create complex types with complex content is also allowed.</p><div class="section"><a name="section_9.1.3.5.1"></a><div class="heading">9.1.3.5.1. Complex content uses extension</div><div class="box"><a name="rule_9-24"></a><div class="normativeHead">[Rule 9-24] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexContent"&gt;
    &lt;sch:assert test="exists(xs:extension)"
      &gt;An element xs:complexContent MUST have a child xs:extension.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>NIEM does not support the use of complex type restriction in reference schemas. The use of restriction in a reference schema would reduce the ability for that schema to be reused. Restriction may be used in extension schemas.</p><p>Note that XML Schema requires use of the attribute <code>base</code> on <code>xs:extension</code>.</p></div><div class="section"><a name="section_9.1.3.5.2"></a><div class="heading">9.1.3.5.2. Complex type with complex content must have complex content</div><div class="box"><a name="rule_9-25"></a><div class="normativeHead">[Rule 9-25] (SET, REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[
      nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))
      or nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument'))]
    /xs:complexContent
      /xs:*[(self::xs:restriction or self::xs:extension)
            and exists(@base)]"&gt;
    &lt;sch:let name="not-complex-content"
             value="for $qname in resolve-QName(@base, .),
                        $not-structures-qname in $qname[namespace-uri-from-QName(.) != xs:anyURI('http://release.niem.gov/niem/structures/3.0/')],
                        $base-type in nf:resolve-type(., $not-structures-qname),
                        $base-complex-type in $base-type[self::xs:complexType],
                        $base-not-complex-content in $base-complex-type[empty(xs:complexContent)]
                    return $base-not-complex-content"/&gt;
    &lt;sch:assert test="empty($not-complex-content)"
      &gt;The base type of complex type that has complex content MUST have complex content.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.1.3.6"></a><div class="heading">9.1.3.6. Simple content</div><div class="section"><a name="section_9.1.3.6.1"></a><div class="heading">9.1.3.6.1. Simple content uses extension</div><p>Within a NIEM-conformant schema, a complex type with simple content can be created in one of two ways:</p><ol><li>By extension of an existing complex type with simple content.</li><li>By extension of an existing simple type.</li></ol><p>Both of these methods use the element <code>xs:extension</code>. Although these two methods have similar syntax, there are subtle differences. NIEM’s conformance rules ensure that any complex type has the necessary attributes for representing IDs, references, metadata, and relationship metadata. Case 1 does not require adding these attributes, as they are guaranteed to occur in the base type. However, in case 2, in which a new complex type is created from a simple type, the attributes for complex types must be added. This is done by reference to the attribute group <code>structures:SimpleObjectAttributeGroup</code>.</p><div class="box"><a name="rule_9-26"></a><div class="normativeHead">[Rule 9-26] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleContent"&gt;
    &lt;sch:assert test="exists(xs:extension)"
      &gt;A complex type definition with simple content schema component must have a derivation method of extension.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>This rule ensures that the definition of a complex type with simple content will use XML Schema extension. This allows for the above cases while disallowing more complicated syntactic options available in XML Schema. The above rule allows for use of <code>xs:restriction</code> within <code>xs:simpleContent</code> in extension schemas.</p></div><div class="section"><a name="section_9.1.3.6.2"></a><div class="heading">9.1.3.6.2. Complex types with simple content have <code>structures:SimpleObjectAttributeGroup</code></div><div class="box"><a name="rule_9-27"></a><div class="normativeHead">[Rule 9-27] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleContent/xs:extension[
      for $base in resolve-QName(@base, .), 
          $base-qname in namespace-uri-from-QName($base) return
        (namespace-uri-from-QName($base) = 'http://www.w3.org/2001/XMLSchema'
         or (some $type in nf:resolve-type(., $base) satisfies 
              node-name($type) = xs:QName('xs:simpleType')
            )
        )
     ]"&gt;
    &lt;sch:assert test="exists(
                        xs:attributeGroup[
                          exists(@ref)
                          and resolve-QName(@ref, .) = xs:QName('structures:SimpleObjectAttributeGroup')
                        ]
                      )"
      &gt;A complex type definition with simple content schema component with a derivation method of extension that has a base type definition that is a simple type MUST incorporate the attribute group {http://release.niem.gov/niem/structures/3.0/}SimpleObjectAttributeGroup.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>This rule ensures that a complex type with simple content that is created as an immediate extension of a simple type adds the attributes required for specific NIEM linking mechanisms.</p><p>This creates a pattern for complex type with simple content definition as follows:</p><div class="figure"><a name="figure_9-1"></a><div class="caption">Figure 9-1: Example of complex type with simple content derived from a simple type</div><div class="box"><pre>&lt;xs:complexType name="PercentageType"&gt;
  ... 
  &lt;xs:simpleContent&gt;
    &lt;xs:extension base="nc:PercentageSimpleType"&gt;
      &lt;xs:attributeGroup ref="structures:SimpleObjectAttributeGroup"/&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:simpleContent&gt;
&lt;/xs:complexType&gt;</pre></div></div></div></div><div class="section"><a name="section_9.1.3.7"></a><div class="heading">9.1.3.7. No complex type disallowed substitutions</div><div class="box"><a name="rule_9-28"></a><div class="normativeHead">[Rule 9-28] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:assert test="empty(@block)"
      &gt;An element xs:complexType MUST NOT have an attribute {}block.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.1.3.8"></a><div class="heading">9.1.3.8. No complex type disallowed derivation</div><div class="box"><a name="rule_9-29"></a><div class="normativeHead">[Rule 9-29] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:assert test="empty(@final)"
      &gt;An element xs:complexType MUST NOT have an attribute {}final.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_9.2"></a><div class="heading">9.2. Declaration components</div><div class="section"><a name="section_9.2.1"></a><div class="heading">9.2.1. Element declaration</div><p>Every element declaration in a NIEM-conformant schema document is a top-level element; rules prohibit the declaration of local elements.</p><p>Within a NIEM-conformant schema document, an element may be declared as abstract. Elements may be defined without a type, but any element declaration that has no type must be declared abstract, as specified by <a href="#rule_9-33"><strong>[Rule 9-33]</strong>, below</a>.</p><p>Within an element declaration, the attributes <code>fixed</code>, <code>nillable</code>, and <code>substitutionGroup</code> may be used as per the XML Schema specification. The attribute <code>form</code> is irrelevant to NIEM, as NIEM-conformant schemas may not contain local element definitions, as specified by <a href="#rule_9-30"><strong>[Rule 9-30]</strong>, below</a>.</p><div class="section"><a name="section_9.2.1.1"></a><div class="heading">9.2.1.1. Element declaration is top-level</div><div class="box"><a name="rule_9-30"></a><div class="normativeHead">[Rule 9-30] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name)]"&gt;
    &lt;sch:assert test="exists(parent::xs:schema)"
      &gt;An element declaration MUST be top-level.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>All schema components defined by NIEM-conformant schemas must be named, accessible from outside the defining schema, and reusable across schemas. Local element definitions provide named elements that are not reusable outside the context in which they are defined.Requiring named NIEM elements to be top level ensures that they are globally reusable.</p></div><div class="section"><a name="section_9.2.1.2"></a><div class="heading">9.2.1.2. Element declaration data definitions</div><div class="section"><a name="section_9.2.1.2.1"></a><div class="heading">9.2.1.2.1. Element declaration has data definition</div><div class="box"><a name="rule_9-31"></a><div class="normativeHead">[Rule 9-31] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name)]"&gt;
    &lt;sch:assert test="exists(xs:annotation/xs:documentation)"
      &gt;An element declaration MUST be a documented component.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.1.2.2"></a><div class="heading">9.2.1.2.2. Element declaration data definition is not empty</div><div class="box"><a name="rule_9-32"></a><div class="normativeHead">[Rule 9-32] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name)]/xs:annotation/xs:documentation[
                         . is (../../xs:annotation/xs:documentation)[1]]"&gt;
    &lt;sch:assert test="string-length(normalize-space(string-join(text(), ''))) &amp;gt; 0"
      &gt;A data definition MUST NOT be empty.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.2.1.3"></a><div class="heading">9.2.1.3. Untyped element is abstract</div><div class="box"><a name="rule_9-33"></a><div class="normativeHead">[Rule 9-33] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema/xs:element[empty(@type)]"&gt;
    &lt;sch:assert test="exists(@abstract)
                      and xs:boolean(@abstract) = true()"
      &gt;A top-level element declaration that has no type MUST be abstract.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Untyped element declarations act as wildcards that may carry arbitrary data. By declaring such types abstract, NIEM allows the creation of type independent semantics without allowing arbitrary content to appear in XML instances.</p></div><div class="section"><a name="section_9.2.1.4"></a><div class="heading">9.2.1.4. Element of type <code>xs:anySimpleType</code> is abstract</div><p>The type xs:anySimpleType does not have any concrete semantics; The use of xs:anySimpleType is limited to the case where an abstract element is of type xs:anySimpleType, to act as a base for concrete implementations of the element.</p><div class="box"><a name="rule_9-34"></a><div class="normativeHead">[Rule 9-34] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@type)
                                and resolve-QName(@type, .) = xs:QName('xs:anySimpleType')]"&gt;
    &lt;sch:assert test="exists(@abstract)
                      and xs:boolean(@abstract) = true()"
                &gt;An element declaration that has a type xs:anySimpleType MUST be abstract.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.1.5"></a><div class="heading">9.2.1.5. Element type not in the XML Schema namespace</div><div class="box"><a name="rule_9-35"></a><div class="normativeHead">[Rule 9-35] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@type)]"&gt;
    &lt;sch:assert test="for $type-qname in resolve-QName(@type, .) return
                        $type-qname = xs:QName('xs:anySimpleType')
                        or namespace-uri-from-QName($type-qname) != xs:anyURI('http://www.w3.org/2001/XMLSchema')"
      &gt;An element type that is not xs:anySimpleType MUST NOT have a namespace name &lt;namespace-uri-for-prefix&gt;xs&lt;/namespace-uri-for-prefix&gt;.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The prohibition of element types having the XML Schema namespace subsumes a prohibition of the type <code>xs:anyType</code>.</p></div><div class="section"><a name="section_9.2.1.6"></a><div class="heading">9.2.1.6. Element type not in a special namespace</div><div class="box"><a name="rule_9-36"></a><div class="normativeHead">[Rule 9-36] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@type)]"&gt;
    &lt;sch:assert test="not(namespace-uri-from-QName(resolve-QName(@type, .))
                          = (xs:anyURI('http://www.w3.org/XML/1998/namespace'),
                               xs:anyURI('urn:us:gov:ic:ism'),
                               xs:anyURI('urn:us:gov:ic:ntk')))"
      &gt;An element type MUST NOT have a namespace name that is in a special namespace.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.1.7"></a><div class="heading">9.2.1.7. Element type is not a simple type</div><div class="box"><a name="rule_9-37"></a><div class="normativeHead">[Rule 9-37] (SET) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[(nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))
                                 or nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument')))
                                and exists(@type)]"&gt;
    &lt;sch:assert test="every $type-qname in resolve-QName(@type, .),
                            $type in nf:resolve-type(., $type-qname)
                      satisfies empty($type/self::xs:simpleType)"
                &gt;An element type MUST NOT be a simple type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.1.8"></a><div class="heading">9.2.1.8. No element disallowed substitutions </div><div class="box"><a name="rule_9-38"></a><div class="normativeHead">[Rule 9-38] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element"&gt;
    &lt;sch:assert test="empty(@block)"
      &gt;An element xs:element MUST NOT have an attribute {}block.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.1.9"></a><div class="heading">9.2.1.9. No element disallowed derivation</div><div class="box"><a name="rule_9-39"></a><div class="normativeHead">[Rule 9-39] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element"&gt;
    &lt;sch:assert test="empty(@final)"
      &gt;An element xs:element MUST NOT have an attribute {}final.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.1.10"></a><div class="heading">9.2.1.10. No element value constraints</div><div class="section"><a name="section_9.2.1.10.1"></a><div class="heading">9.2.1.10.1. No element default values</div><div class="box"><a name="rule_9-40"></a><div class="normativeHead">[Rule 9-40] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element"&gt;
    &lt;sch:assert test="empty(@default)"
      &gt;An element xs:element MUST NOT have an attribute {}default.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.1.10.2"></a><div class="heading">9.2.1.10.2. No element fixed values</div><div class="box"><a name="rule_9-41"></a><div class="normativeHead">[Rule 9-41] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element"&gt;
    &lt;sch:assert test="empty(@fixed)"
      &gt;An element xs:element MUST NOT have an attribute {}fixed.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.2.1.11"></a><div class="heading">9.2.1.11. Element declaration is nillable</div><p>All elements declared by reference schemas allow a nil value. This enables the ID/IDREF mechanism linking <code>structures:ref</code> and <code>structures:id</code>, as described by <a href="#section_12.3">Section 12.3, <em>Reference elements</em>, below</a>.</p><p>A developer may constrain the use of <code>nil</code> in instance by setting <code>nillable</code> to false in subset schemas, or by use of non-XML Schema mechanisms, such as Schematron.</p><div class="box"><a name="rule_9-42"></a><div class="normativeHead">[Rule 9-42] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name)
                                and (empty(@abstract)
                                     or xs:boolean(@abstract) = false())]"&gt;
    &lt;sch:assert test="exists(@nillable)
                      and xs:boolean(@nillable) = true()"
      &gt;An [element declaration schema component] MUST have the nillable property with a value of true.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p><span class="termRef"><a name="d3e4670" href="#definition_element_declaration_schema_component">[Element declaration schema component]</a></span> has a normative definition.</p></div></div><div class="section"><a name="section_9.2.2"></a><div class="heading">9.2.2. Element substitution group</div></div><div class="section"><a name="section_9.2.3"></a><div class="heading">9.2.3. Attribute declaration</div><p>Within an attribute declaration, the attribute <code>form</code> is irrelevant to NIEM, as NIEM-conformant schemas may not contain local attribute declarations.</p><p>An attribute use has an {attribute declaration} property that is a top-level, named attribute declaration. NIEM-conformant schemas do not define local named attributes within type definitions. Within an attribute use, the attribute <code>use</code> may be used as per the XML Schema specification.</p><div class="section"><a name="section_9.2.3.1"></a><div class="heading">9.2.3.1. Attribute declarations are top-level</div><div class="box"><a name="rule_9-43"></a><div class="normativeHead">[Rule 9-43] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@name)]"&gt;
    &lt;sch:assert test="exists(parent::xs:schema)"
      &gt;An attribute declaration MUST be top-level.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>All schema components defined by NIEM-conformant schemas are named, accessible from outside the defining schema, and reusable across schemas. Local attribute definitions provide named attributes that are not reusable outside the context in which they are defined. Requiring named NIEM attributes to be top level ensures that they are globally reusable.</p></div><div class="section"><a name="section_9.2.3.2"></a><div class="heading">9.2.3.2. Attribute declaration data definitions</div><div class="section"><a name="section_9.2.3.2.1"></a><div class="heading">9.2.3.2.1. Attribute declaration has data definition</div><div class="box"><a name="rule_9-44"></a><div class="normativeHead">[Rule 9-44] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@name)]"&gt;
    &lt;sch:assert test="exists(xs:annotation/xs:documentation)"
      &gt;An attribute declaration MUST be a documented component.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.3.2.2"></a><div class="heading">9.2.3.2.2. Attribute declaration data definition is not empty</div><div class="box"><a name="rule_9-45"></a><div class="normativeHead">[Rule 9-45] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@name)]/xs:annotation/xs:documentation[
                         . is (../../xs:annotation/xs:documentation)[1]]"&gt;
    &lt;sch:assert test="string-length(normalize-space(string-join(text(), ''))) &amp;gt; 0"
      &gt;A data definition MUST NOT be empty.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.2.3.3"></a><div class="heading">9.2.3.3. Attribute declaration has type</div><div class="box"><a name="rule_9-46"></a><div class="normativeHead">[Rule 9-46] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@name)]"&gt;
    &lt;sch:assert test="exists(@type)"
      &gt;A top-level attribute declaration MUST have a type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Untyped XML Schema attributes allow arbitrary content, with no semantics. Attributes must have a type so that specific syntax and semantics will be provided.</p></div><div class="section"><a name="section_9.2.3.4"></a><div class="heading">9.2.3.4. Prohibited attribute types</div><p>There is no explicit prohibition on the use of xs:NOTATION as an attribute type, because it is prohibited by <a href="#XMLSchema-2" class="ref">[XML Schema Datatypes]</a>.</p><p>These types are only explicitly prohibited from attributes, not elements, because the case is covered by a general prohibition against elements having simple types.</p><div class="section"><a name="section_9.2.3.4.1"></a><div class="heading">9.2.3.4.1. No attribute type of <code>xs:ID</code></div><div class="box"><a name="rule_9-47"></a><div class="normativeHead">[Rule 9-47] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@type)]"&gt;
    &lt;sch:assert test="resolve-QName(@type, .) != xs:QName('xs:ID')"
      &gt;A schema component MUST NOT have an attribute {}type with a value of xs:ID.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.3.4.2"></a><div class="heading">9.2.3.4.2. No attribute type of <code>xs:IDREF</code></div><div class="box"><a name="rule_9-48"></a><div class="normativeHead">[Rule 9-48] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@type)]"&gt;
    &lt;sch:assert test="resolve-QName(@type, .) != xs:QName('xs:IDREF')"
      &gt;A schema component MUST NOT have an attribute {}type with a value of xs:IDREF.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.2.3.5"></a><div class="heading">9.2.3.5. No attribute value constraints</div><div class="section"><a name="section_9.2.3.5.1"></a><div class="heading">9.2.3.5.1. No attribute default values</div><div class="box"><a name="rule_9-49"></a><div class="normativeHead">[Rule 9-49] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute"&gt;
    &lt;sch:assert test="empty(@default)"
      &gt;An element xs:attribute MUST NOT have an attribute {}default.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.2.3.5.2"></a><div class="heading">9.2.3.5.2. No attribute fixed values</div><div class="box"><a name="rule_9-50"></a><div class="normativeHead">[Rule 9-50] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute"&gt;
    &lt;sch:assert test="empty(@fixed)"
      &gt;An element xs:attribute MUST NOT have an attribute {}fixed.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The use of the <code>fixed</code> attribute may result in alteration of the post-schema-validation infoset, like the use of <code>default</code> does. This behavior is described by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Attribute_Declaration_details">§3.2.1, <em>The Attribute Declaration Schema Component</em></a>.</p></div></div></div><div class="section"><a name="section_9.2.4"></a><div class="heading">9.2.4. Notation declaration</div><div class="section"><a name="section_9.2.4.1"></a><div class="heading">9.2.4.1. No use of element xs:notation</div><div class="box"><a name="rule_9-51"></a><div class="normativeHead">[Rule 9-51] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:notation"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:notation.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>See <a href="#section_9.1.1.1.5">Section 9.1.1.1.5, <em>No base type of <code>xs:NOTATION</code></em>, above,</a> for comments about the use of notations.</p></div></div></div><div class="section"><a name="section_9.3"></a><div class="heading">9.3. Model group components</div><div class="section"><a name="section_9.3.1"></a><div class="heading">9.3.1. Model group</div><p>Complex content definitions in XML Schema use model group schema components. These schema components, <code>xs:all</code>, <code>xs:choice</code> and <code>xs:sequence</code>, also called compositors, provide for ordering and selection of particles within a model group.</p><p>XML Schema defines a <strong>particle</strong> as an occurrence of <code>xs:element</code>, <code>xs:sequence</code>, <code>xs:choice</code>, <code>xs:any</code> (wildcard) and <code>xs:group</code> (model group) within a content model. For example, an <code>xs:sequence</code> within an XML Schema complex type is a particle. An <code>xs:element</code> occurring within an <code>xs:sequence</code> is also a particle.</p><div class="section"><a name="section_9.3.1.1"></a><div class="heading">9.3.1.1. Model group does not affect meaning</div><div class="box"><a name="rule_9-52"></a><div class="normativeHead">[Rule 9-52] (EXT) (Interpretation)</div><p>The use of model groups <code>xs:all</code>, <code>xs:sequence</code>, and <code>xs:choice</code> SHALL NOT define the semantics of an instance. The meaning of an element occurrance within an element occurrence SHALL be identical, regardless of the model group used to define a <span class="termRef"><a name="d3e5033" href="#definition_schema_component">[schema component]</a></span>.</p></div></div><div class="section"><a name="section_9.3.1.2"></a><div class="heading">9.3.1.2. No <code>xs:all</code></div><div class="box"><a name="rule_9-53"></a><div class="normativeHead">[Rule 9-53] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:all"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:all&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The element <code>xs:all</code> provides a set of particles (e.g., elements) that may be included in an instance, in no particular order. This can greatly complicate processing and may be difficult to comprehend and satisfy.</p><p></p></div><div class="section"><a name="section_9.3.1.3"></a><div class="heading">9.3.1.3. Sequence</div><div class="section"><a name="section_9.3.1.3.1"></a><div class="heading">9.3.1.3.1. <code>xs:sequence</code> must be child of <code>xs:extension</code></div><div class="box"><a name="rule_9-54"></a><div class="normativeHead">[Rule 9-54] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:sequence"&gt;
    &lt;sch:assert test="exists(parent::xs:extension)"
      &gt;An element xs:sequence must be a child of element xs:extension.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.3.1.3.2"></a><div class="heading">9.3.1.3.2. <code>xs:sequence</code> must be child of <code>xs:extension</code> or <code>xs:restriction</code></div><div class="box"><a name="rule_9-55"></a><div class="normativeHead">[Rule 9-55] (EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:sequence"&gt;
    &lt;sch:assert test="exists(parent::xs:extension) or exists(parent::xs:restriction)"
      &gt;An element xs:sequence must be a child of element xs:extension or xs:restriction.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.3.1.4"></a><div class="heading">9.3.1.4. Choice</div><div class="section"><a name="section_9.3.1.4.1"></a><div class="heading">9.3.1.4.1. No <code>xs:choice</code></div><div class="box"><a name="rule_9-56"></a><div class="normativeHead">[Rule 9-56] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:choice"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:choice&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The element <code>xs:choice</code> provides an exclusive set of particles, one of which may appear in an instance. This can greatly complicate processing and may be difficult to comprehend, satisfy, and reuse.</p><p>The element <code>xs:choice</code> may be used in extension schemas, as it presents a simple way for a schema writer to represent a set of optional content.</p></div><div class="section"><a name="section_9.3.1.4.2"></a><div class="heading">9.3.1.4.2. <code>xs:choice</code> must be child of <code>xs:sequence</code></div><div class="box"><a name="rule_9-57"></a><div class="normativeHead">[Rule 9-57] (EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:choice"&gt;
    &lt;sch:assert test="exists(parent::xs:sequence)"
      &gt;An element xs:choice must be a child of element xs:sequence.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_9.3.2"></a><div class="heading">9.3.2. Particle</div><p>In NIEM schemas, an element use is a element declaration acting as a particle within a content model. Each such element declaration must reference a top-level named element declaration.</p><p>Element declarations acting as a particle (particles formed by <code>xs:element</code>) may have any cardinality. NIEM does not provide additional constraints on the values of the XML Schema properties {min occurs} and {max occurs} on element uses. These properties are described by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#Particle_details">§3.9.1, <em>The Particle Schema Component</em></a>.</p><div class="section"><a name="section_9.3.2.1"></a><div class="heading">9.3.2.1. Sequence cardinality</div><p>XML Schema allows each particle to specify cardinality (how many times the particle may appear in an instance). NIEM restricts the cardinality of <code>xs:sequence</code> particles to exactly one, to ensure that content model definitions are defined in as straightforward a manner as possible.</p><p>Should a schema developer user require the instance syntax would be obtained from the use of specific cardinality on sequences, she should define cardinality on specific elements.</p><div class="section"><a name="section_9.3.2.1.1"></a><div class="heading">9.3.2.1.1. Sequence minimum cardinality</div><div class="box"><a name="rule_9-58"></a><div class="normativeHead">[Rule 9-58] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:sequence"&gt;
    &lt;sch:assert test="empty(@minOccurs) or xs:integer(@minOccurs) = 1"
      &gt;An element xs:sequence MUST either not have the attribute {}minOccurs, or that attribute MUST have a value of 1.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.3.2.1.2"></a><div class="heading">9.3.2.1.2. Sequence maximum cardinality</div><div class="box"><a name="rule_9-59"></a><div class="normativeHead">[Rule 9-59] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:sequence"&gt;
    &lt;sch:assert test="empty(@maxOccurs) or (@maxOccurs instance of xs:integer
                                            and 1 = xs:integer(@maxOccurs))"
      &gt;An element xs:sequence MUST either not have the attribute {}maxOccurs, or that attribute MUST have a value of 1.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.3.2.2"></a><div class="heading">9.3.2.2. Choice cardinality</div><div class="section"><a name="section_9.3.2.2.1"></a><div class="heading">9.3.2.2.1. Choice minimum cardinality</div><div class="box"><a name="rule_9-60"></a><div class="normativeHead">[Rule 9-60] (EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:choice"&gt;
    &lt;sch:assert test="empty(@minOccurs) or 1 = xs:integer(@minOccurs)"
      &gt;An element xs:choice MUST either not have the attribute {}minOccurs, or that attribute MUST have a value of 1.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.3.2.2.2"></a><div class="heading">9.3.2.2.2. Choice maximum cardinality</div><div class="box"><a name="rule_9-61"></a><div class="normativeHead">[Rule 9-61] (EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:choice"&gt;
    &lt;sch:assert test="empty(@maxOccurs) or (@maxOccurs instance of xs:integer
                                            and 1 = xs:integer(@maxOccurs))"
      &gt;An element xs:choice MUST either not have the attribute {}maxOccurs, or that attribute MUST have a value of 1.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_9.3.3"></a><div class="heading">9.3.3. Attribute use</div><div class="section"><a name="section_9.3.3.1"></a><div class="heading">9.3.3.1. Attribute ref defined by conformant schemas</div><div class="box"><a name="rule_9-62"></a><div class="normativeHead">[Rule 9-62] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@ref)]"&gt;
    &lt;sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@ref, .))"/&gt;
    &lt;sch:assert test="$namespace = nf:get-target-namespace(.)
                      or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                    and $namespace = xs:anyURI(@namespace)
                                    and empty(@appinfo:externalImportIndicator)])"
      &gt;An attribute {}ref MUST have the target namespace or a namespace that is imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.3.4"></a><div class="heading">9.3.4. Attribute group</div><div class="section"><a name="section_9.3.4.1"></a><div class="heading">9.3.4.1. Only known attribute groups</div><p>In NIEM-conformant schemas, use of attribute groups is restricted. The only attribute group that plays a part in NIEM-conformant schemas is <code>structures:SimpleObjectAttributeGroup</code>. This attribute group provides the attributes necessary for IDs, references, metadata, and relationship metadata.</p><div class="box"><a name="rule_9-63"></a><div class="normativeHead">[Rule 9-63] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attributeGroup[exists(@ref)]"&gt;
    &lt;sch:assert test="for $ref in exactly-one(resolve-QName(@ref, .)) return
      ($ref = xs:QName('structures:SimpleObjectAttributeGroup')
       or (for $ref-namespace in exactly-one(namespace-uri-from-QName($ref)) return
             $ref-namespace = (xs:anyURI('urn:us:gov:ic:ism'),
                              xs:anyURI('urn:us:gov:ic:ntk'))))"
      &gt;An attribute group reference MUST be structures:SimpleObjectAttributeGroup or have the IC-ISM or IC-NTK namespace.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.3.5"></a><div class="heading">9.3.5. Wildcard</div><div class="section"><a name="section_9.3.5.1"></a><div class="heading">9.3.5.1. No use of <code>xs:any</code></div><div class="box"><a name="rule_9-64"></a><div class="normativeHead">[Rule 9-64] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:any"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:any.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The <code>xs:any</code> particle (see Model Group Restrictions for an informative definition of particle) provides a wildcard that may carry arbitrary content. The particle <code>xs:any</code> may appear within constraint schemas, extension schemas, and exchange schemas.</p></div><div class="section"><a name="section_9.3.5.2"></a><div class="heading">9.3.5.2. No use of <code>xs:anyAttribute</code></div><div class="box"><a name="rule_9-65"></a><div class="normativeHead">[Rule 9-65] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:anyAttribute"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:anyAttribute.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The <code>xs:anyAttribute</code> element provides a wildcard, where arbitrary attributes may appear. The element <code>xs:anyAttribute</code> may appear within constraint schemas or within other schemas that are not NIEM-conformant, but it is prohibited in NIEM- conformant schemas.</p></div></div></div><div class="section"><a name="section_9.4"></a><div class="heading">9.4. Identity-constraint definition components</div><p>XML Schema provides NIEM with the ability to apply uniqueness constraints to schema-validated content. These mechanisms, however, establish relationships in a way that is very difficult to understand, extend, and keep consisent through schema reuse.</p><div class="section"><a name="section_9.4.1"></a><div class="heading">9.4.1. No use of <code>xs:unique</code></div><div class="box"><a name="rule_9-66"></a><div class="normativeHead">[Rule 9-66] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:unique"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:unique.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.4.2"></a><div class="heading">9.4.2. No use of <code>xs:key</code></div><div class="box"><a name="rule_9-67"></a><div class="normativeHead">[Rule 9-67] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:key"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:key.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.4.3"></a><div class="heading">9.4.3. No use of <code>xs:keyref</code></div><div class="box"><a name="rule_9-68"></a><div class="normativeHead">[Rule 9-68] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:keyref"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:keyref.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.4.4"></a><div class="heading">9.4.4. No use of <code>xs:selector</code></div><div class="box"><a name="rule_9-69"></a><div class="normativeHead">[Rule 9-69] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:selector"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:selector.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.4.5"></a><div class="heading">9.4.5. No use of <code>xs:field</code></div><div class="box"><a name="rule_9-70"></a><div class="normativeHead">[Rule 9-70] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:field"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema SHALL NOT contain the element xs:field.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.5"></a><div class="heading">9.5. Group definition components</div><div class="section"><a name="section_9.5.1"></a><div class="heading">9.5.1. Model group definition</div><div class="section"><a name="section_9.5.1.1"></a><div class="heading">9.5.1.1. No use of <code>xs:group</code></div><div class="box"><a name="rule_9-71"></a><div class="normativeHead">[Rule 9-71] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:group"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema MUST NOT contain the element xs:group.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>NIEM does not allow groups of elements to be named other than as named complex types. A group in XML Schema creates a named entity that may be included in multiple types, and which consists of a sequence of or choice between element particles. The NIEM has not developed a semantic model for these components, and they are not integrated into NIEM’s design.</p></div></div><div class="section"><a name="section_9.5.2"></a><div class="heading">9.5.2. Attribute group definition</div><div class="section"><a name="section_9.5.2.1"></a><div class="heading">9.5.2.1. No definition of attribute groups</div><p>The only attribute groups used in NIEM-conformant schemas are <code>structures:SimpleObjectAttributeGroup</code> and attribute groups defined by the IC-ISM and IC-NTK schemas. Therefore, NIEM-conformant schemas do not define additional attribute groups.</p><div class="box"><a name="rule_9-72"></a><div class="normativeHead">[Rule 9-72] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attributeGroup[@name]"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema MUST NOT contain an attribute group definition schema component.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_9.6"></a><div class="heading">9.6. Annotation components</div><div class="section"><a name="section_9.6.1"></a><div class="heading">9.6.1. Comments are not recommended</div><div class="box"><a name="rule_9-73"></a><div class="normativeHead">[Rule 9-73] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="comment()"&gt;
    &lt;sch:report test="true()"
      &gt;An XML Comment is not an XML Schema annotation component; XML Comments SHOULD NOT appear in the schema.&lt;/sch:report&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Since XML comments are not associated with any specific XML Schema construct, there is no standard way to interpret comments. As such, comments should be reserved for internal use, and XML Schema annotations should be preferred for meaningful information about components. NIEM specifically defines how information should be encapsulated in NIEM-conformant schemas via <code>xs:annotation</code> elements.</p></div><div class="section"><a name="section_9.6.2"></a><div class="heading">9.6.2. Documentation elements have no element children</div><div class="box"><a name="rule_9-74"></a><div class="normativeHead">[Rule 9-74] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:documentation/node()"&gt;
    &lt;sch:assert test="self::text() or self::comment()"
      &gt;A child of element xs:documentation MUST be text or an XML comment.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.6.3"></a><div class="heading">9.6.3. Application information annotations</div><p>XML Schema provides special annotations for support of automatic processing. The XML Schema specification provides the element <code>xs:appinfo</code> to carry such content and does not specify what style of content they should carry. In NIEM, <code>xs:appinfo</code> elements carry structured XML content.</p><div class="section"><a name="section_9.6.3.1"></a><div class="heading">9.6.3.1. Appinfo has elements</div><div class="box"><a name="rule_9-75"></a><div class="normativeHead">[Rule 9-75] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:appinfo/node()"&gt;
    &lt;sch:assert test="self::comment() or self::element()"
      &gt;A child of element xs:appinfo MUST be an element or an XML comment.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Application information elements are intended for automatic processing; the meaning of an appinfo annotation is provided via elements.</p></div><div class="section"><a name="section_9.6.3.2"></a><div class="heading">9.6.3.2. Appinfo child elements have namespaces</div><div class="box"><a name="rule_9-76"></a><div class="normativeHead">[Rule 9-76] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:appinfo/*"&gt;
    &lt;sch:assert test="namespace-uri() != xs:anyURI('')"
      &gt;An element that is a child of xs:appinfo MUST have a namespace name.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The XML namespaces specification includes the concept of content not in a namespace. Use of elements without namespaces can lead to conflicting data definitions, and makes it difficult to identify relevant data definitions.</p></div><div class="section"><a name="section_9.6.3.3"></a><div class="heading">9.6.3.3. Appinfo descendants are not XML Schema elements</div><div class="box"><a name="rule_9-77"></a><div class="normativeHead">[Rule 9-77] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:appinfo//xs:*"&gt;
    &lt;sch:assert test="false()"
      &gt;An element with a namespace name of xs: MUST NOT have an ancestor element xs:appinfo.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>NIEM-conformant schemas are designed to be very easily processed. Although uses of XML Schema elements as content of <code>xs:appinfo</code> elements could be contrived, it is not current practice and complicates the processing of XML elements by their namespaces and names. Forbidding the use of XML Schema elements outside valid uses of schema simplifies such processing.</p></div></div></div><div class="section"><a name="section_9.7"></a><div class="heading">9.7. Schema as a whole</div><p>The XML Schema language defines that the document element <code>xs:schema</code> may contain the optional attributes <code>attributeFormDefault</code> and <code>elementFormDefault</code>. The values of these attributes are not material to a NIEM-conformant schema, as each attribute and element defined by a NIEM-conformant schema must be defined at the toplevel and so is qualified its target namespace.</p><div class="section"><a name="section_9.7.1"></a><div class="heading">9.7.1. Schema data definitions</div><div class="section"><a name="section_9.7.1.1"></a><div class="heading">9.7.1.1. Schema has data definition</div><div class="box"><a name="rule_9-78"></a><div class="normativeHead">[Rule 9-78] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema"&gt;
    &lt;sch:assert test="exists(xs:annotation/xs:documentation)"
      &gt;A schema document element MUST be a documented component.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.7.1.2"></a><div class="heading">9.7.1.2. Schema data definition is not empty</div><div class="box"><a name="rule_9-79"></a><div class="normativeHead">[Rule 9-79] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema/xs:annotation/xs:documentation[
                         . is (../../xs:annotation/xs:documentation)[1]]"&gt;
    &lt;sch:assert test="string-length(normalize-space(string-join(text(), ''))) &amp;gt; 0"
      &gt;A data definition MUST NOT be empty.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.7.2"></a><div class="heading">9.7.2. Define target namespace</div><div class="box"><a name="rule_9-80"></a><div class="normativeHead">[Rule 9-80] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema"&gt;
    &lt;sch:assert test="exists(@targetNamespace)"
      &gt;The schema MUST define a target namespace.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Schemas without defined namespaces provide definitions that are ambiguous, in that they are not universally identifiable.</p></div><div class="section"><a name="section_9.7.3"></a><div class="heading">9.7.3. Target namespace is absolute URI</div><div class="box"><a name="rule_9-81"></a><div class="normativeHead">[Rule 9-81] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema[exists(@targetNamespace)]"&gt;
    &lt;sch:report test="true()"
                &gt;&lt;![CDATA[The value of the attribute targetNamespace MUST match the production &lt;absolute-URI&gt; as defined by RFC 3986.]]&gt;&lt;/sch:report&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Absolute URIs are the only universally meaningful URIs. URIs include both URLs and URNs. Finding the target namespace using standard XML Base technology is complicated and not specified by XML Schema. Relative URIs are not universally identifiable, as they are context-specific.</p></div><div class="section"><a name="section_9.7.4"></a><div class="heading">9.7.4. Schema document version</div><p>It is very useful to be able to tell one version of a schema from another. Apart from the use of namespaces for versioning, it is sometimes necessary to release multiple versions of schema documents. Such use might include:</p><ul><li>Subset schemas and constraint schemas</li><li>Error corrections or bug fixes</li><li>Documentation changes</li><li>Contact information updates</li></ul><p>In such cases, a different value for the <code>version</code> attribute implies a different version of the schema. No specific meaning is assigned to specific version identifiers.</p><p>Note that some of the above uses for the version attribute are not employed in management of NIEM Core and domain schemas. An author of an application schema or exchange may use the <code>version</code> attribute for these purposes within their schemas.</p><div class="section"><a name="section_9.7.4.1"></a><div class="heading">9.7.4.1. Schema must have version</div><div class="box"><a name="rule_9-82"></a><div class="normativeHead">[Rule 9-82] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema"&gt;
    &lt;sch:assert test="exists(@version)"
        &gt;An element xs:schema must have an attribute {}version.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.7.4.2"></a><div class="heading">9.7.4.2. Schema version must not be empty.</div><div class="box"><a name="rule_9-83"></a><div class="normativeHead">[Rule 9-83] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema[exists(@version)]"&gt;
    &lt;sch:assert test="string-length(normalize-space(@version)) &amp;gt; 0"
                &gt;An attribute version owned by an element xs:schema must not be empty.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.7.5"></a><div class="heading">9.7.5. No disallowed substitutions</div><div class="box"><a name="rule_9-84"></a><div class="normativeHead">[Rule 9-84] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema"&gt;
    &lt;sch:assert test="empty(@blockDefault)"
      &gt;An element xs:schema MUST NOT have an attribute {}blockDefault.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_9.7.6"></a><div class="heading">9.7.6. No disallowed derivations</div><div class="box"><a name="rule_9-85"></a><div class="normativeHead">[Rule 9-85] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema"&gt;
    &lt;sch:assert test="empty(@finalDefault)"
      &gt;An element xs:schema MUST NOT have an attribute {}finalDefault.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_9.8"></a><div class="heading">9.8. Schema assembly</div><div class="section"><a name="section_9.8.1"></a><div class="heading">9.8.1. No use of <code>xs:redefine</code></div><div class="box"><a name="rule_9-86"></a><div class="normativeHead">[Rule 9-86] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:redefine"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema MUST NOT contain the element xs:redefine.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The <code>xs:redefine</code> element allows an XML Schema document to restrict and extend components from a namespace, in a separate schema document from the one that initially defined that namespace. Such redefinition introduces duplication of definitions, allowing multiple definitions to exist for components from a single namespace. This violates [Principle 8], that a single reference schema defines a NIEM-conformant namespace.</p></div><div class="section"><a name="section_9.8.2"></a><div class="heading">9.8.2. No use of <code>xs:include</code></div><div class="box"><a name="rule_9-87"></a><div class="normativeHead">[Rule 9-87] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:include"&gt;
    &lt;sch:assert test="false()"
      &gt;The schema MUST NOT contain the element xs:include.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Element <code>xs:include</code> brings schemas defined in separate files into the current namespace. It breaks a namespace up into arbitrary partial schemas, which needlessly complicates the schema structure, making it harder to reuse and process, and also increases the likelihood of conflicting definitions.</p><p>Inclusion of schemas that do not have namespaces also complicates schema understanding. This inclusion makes it difficult to find the realization of a specific schema artifact and create aliases for schema components that should be reused. Inclusion of schemas also violates [Principle 8], as it uses multiple schemas to construct a namespace.</p></div><div class="section"><a name="section_9.8.3"></a><div class="heading">9.8.3. <code>xs:import</code> must have namespace</div><div class="box"><a name="rule_9-88"></a><div class="normativeHead">[Rule 9-88] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:import"&gt;
    &lt;sch:assert test="exists(@namespace)"
      &gt;An element xs:import MUST have an attribute {}namespace.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>An import that does not specify a namespace is enabling references to non-namespaced components. NIEM requires that all components have a defined namespace. It is important that the namespace declared by a schema be universally defined and unambiguous.</p></div></div></div><div class="section"><a name="section_10"></a><div class="heading">10. Rules for NIEM modeling, by NIEM concept</div><p>This section focuses on building NIEM data models using XML schema. Whereas <a href="#section_9">Section 9, <em>Rules for a NIEM profile of XML Schema</em>, above,</a> addressed shrinking the XML Schema definition language to a smaller set of features, this section constructs new NIEM-specific features to address modeling and interoperability problems. This includes naming rules, categories of types, and augmentations.</p><p>NIEM provides a framework for modeling concepts and relationships as XML artifacts. The data model is implemented via XML Schema. However, XML Schema does not provide sufficient structure and constraint to enable translating from a conceptual model to a schema and then to instances of the concepts. NIEM provides additional support for modeling concepts as schemas and provides rules for creating and connecting data that realizes those concepts.</p><p>Underlying the NIEM data model are two namespaces: the <span class="termRef"><a name="d3e6194" href="#definition_structures_namespace">[structures namespace]</a></span> and the <span class="termRef"><a name="d3e6197" href="#definition_appinfo_namespace">[appinfo namespace]</a></span>. These two namespaces provide schema components that serve two functions:</p><ol><li>They provide support for connecting structural definitions to concepts.</li><li>They provide base components from which to derive structural definitions.</li></ol><p>These namespaces are distributed with the NIEM data model content but are not themselves considered to be <em>content</em> of the data model. They are, instead, part of the <em>structure</em> on which the data model is built.</p><p>This section is organized by concept, rather than component type. This section is integrated with the following sections:</p><ul><li><a href="#section_11">Section 11, <em>Rules for NIEM modeling, by XML Schema component</em>, below,</a> is organized by component type, and provides a majority of the constraint rules for schemas that define NIEM models.</li><li><a href="#section_12">Section 12, <em>XML instance document rules</em>, below,</a> provides rules for XML documents that are instances of NIEM models.</li></ul><p>Concepts covered by this section include:</p><ul><li><a href="#section_10.1">Section 10.1, <em>NIEM structural facilities</em></a></li><li><a href="#section_10.2">Section 10.2, <em>Categories of NIEM components</em></a></li><li><a href="#section_10.3">Section 10.3, <em>Container elements</em></a></li><li><a href="#section_10.4">Section 10.4, <em>Naming rules</em></a></li><li><a href="#section_10.5">Section 10.5, <em>Machine-readable annotations</em></a></li></ul><div class="section"><a name="section_10.1"></a><div class="heading">10.1. NIEM structural facilities</div><p>NIEM provides the structures schema that contains base types for types defined in NIEM- conformant schemas. It provides base elements to act as heads for substitution groups. It also provides attributes that provide facilities not otherwise provided by XML Schema. These structures should be used to augment XML data. The structures provided are not meant to replace fundamental XML organization methods; they are intended to assist them.</p><div class="box"><a name="definition_structures_namespace"></a><div class="normativeHead">[Definition: <dfn>structures namespace</dfn>]</div><div class="sub"><p>The <strong>structures namespace</strong> is the namespace represented by the URI <q><code>http://release.niem.gov/niem/structures/3.0/</code></q>.</p></div></div><p>The structures namespace is a single namespace, separate from namespaces that define NIEM-conformant data. This document refers to this content via the prefix <code>structures</code>.</p><div class="section"><a name="section_10.1.1"></a><div class="heading">10.1.1. Use structures as specified</div><div class="box"><a name="rule_10-1"></a><div class="normativeHead">[Rule 10-1] (REF, EXT, INS) (Constraint)</div><p>The schema or instance MUST use content within the NIEM <code>structures</code> namespace as specified in this document and ONLY as specified by this document.</p></div><p>This rule further enforces uniformity and consistency by mandating use of the NIEM <code>structures</code> namespace as is, without modification. Users are not allowed to insert types, attributes, etc. that are not specified by this document (the NDR).</p></div></div><div class="section"><a name="section_10.2"></a><div class="heading">10.2. Categories of NIEM components</div><p>The NIEM rules on categories of types, and other components, use the name of a type as the key indicator of the type’s category. This make the rules much simpler than doing a deep examination of each type and its base types to identify its category. For example, for complex types, the names follow a pattern:</p><ul><li>Name ends with <q>AssociationType</q> → type is an association type.</li><li>Name ends with <q>MetadataType</q> → type is a metadata type.</li><li>Name ends with <q>AugmentationType</q> → type is an augmentation type.</li><li>Otherwise → type is an object type.</li></ul><p>Sections within this section include:</p><ul><li><a href="#section_10.2.1">Section 10.2.1, <em>Classes of complex types</em></a></li><li><a href="#section_10.2.2">Section 10.2.2, <em>Objects</em></a></li><li><a href="#section_10.2.3">Section 10.2.3, <em>Associations</em></a></li><li><a href="#section_10.2.4">Section 10.2.4, <em>Augmentations</em></a></li><li><a href="#section_10.2.5">Section 10.2.5, <em>Metadata</em></a></li></ul><div class="section"><a name="section_10.2.1"></a><div class="heading">10.2.1. Classes of complex types</div><div class="box"><a name="rule_10-2"></a><div class="normativeHead">[Rule 10-2] (REF, EXT) (Constraint)</div><p>Within the schema, a complex type definition SHALL be one of the following:</p><ol><li>An object type.</li><li>An association type.</li><li>A metadata type.</li><li>An augmentation type.</li></ol></div><p>This rule establishes the classes of NIEM complex types. It is a limited set, and each class has distinct semantics.</p></div><div class="section"><a name="section_10.2.2"></a><div class="heading">10.2.2. Objects</div><p>The categories of objects are covered by the following sections:</p><ul><li><a href="#section_10.2.2.1">Section 10.2.2.1, <em>General object types</em></a></li><li><a href="#section_10.2.2.2">Section 10.2.2.2, <em>Roles</em></a></li><li><a href="#section_10.2.2.3">Section 10.2.2.3, <em>External adapter types</em></a></li><li><a href="#section_10.2.2.4">Section 10.2.2.4, <em>Code types</em></a></li><li><a href="#section_10.2.2.5">Section 10.2.2.5, <em>Proxy types</em></a></li></ul><div class="section"><a name="section_10.2.2.1"></a><div class="heading">10.2.2.1. General object types</div><div class="box"><a name="definition_object_type"></a><div class="normativeHead">[Definition: <dfn>object type</dfn>]</div><div class="sub"><p>In a NIEM-conformant schema, an <strong>object type</strong> is a complex type definition, an instance of which asserts the existence of an object. An object type represents some kind of object: a thing with its own lifespan that has some existence. The object may or may not be a physical object. It may be a conceptual object.</p></div></div><div class="section"><a name="section_10.2.2.1.1"></a><div class="heading">10.2.2.1.1. Object types with complex content</div><div class="section"><a name="section_10.2.2.1.1.1"></a><div class="heading">10.2.2.1.1.1. An object type with complex content is derived from an object type</div><div class="box"><a name="rule_10-3"></a><div class="normativeHead">[Rule 10-3] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[
      exists(xs:complexContent)
      and not(ends-with(@name, 'AssociationType')
          or ends-with(@name, 'MetadataType')
          or ends-with(@name, 'AugmentationType'))]"&gt;
    &lt;sch:assert test="
        for $derivation-method in (xs:complexContent/xs:extension, xs:complexContent/xs:restriction),
            $base in $derivation-method/@base,
            $base-qname in resolve-QName($base, $derivation-method)
          return ($base-qname = xs:QName('structures:ObjectType')
                  or (for $base-namespace in namespace-uri-from-QName($base-qname) return
                        (not($base-namespace
                               = (xs:anyURI('http://www.w3.org/XML/1998/namespace'),
                                  xs:anyURI('urn:us:gov:ic:ism'),
                                  xs:anyURI('urn:us:gov:ic:ntk')))
                         and (for $base-local-name in local-name-from-QName($base-qname) return
                                not(ends-with($base-local-name, 'AssociationType')
                                    or ends-with($base-local-name, 'MetadataType')
                                    or ends-with($base-local-name, 'AugmentationType'))
                             )
                        )
                      )
                  )"
      &gt;An object type with complex content MUST be derived from structures:Object type or from another object type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_10.2.2.2"></a><div class="heading">10.2.2.2. Roles</div><p class="todo">Indicate that a subset of role type could omit the RoleOf element, in which case an instance of the role type is just a regular object.</p><p>NIEM differentiates between an object and a role of the object. The term <q>role</q> is used here to mean a function or part played by some object. The simplest way to represent a role of an object is to use an element. The following element definition models the role of a person who undergoes an assessment:</p><div class="figure"><a name="figure_10-1"></a><div class="caption">Figure 10-1: An element definition that constitutes a role without the use of a role type</div><div class="box"><pre>&lt;xs:element name="AssessmentPerson" type="nc:PersonType" nillable="true"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A person who undergoes an assessment.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</pre></div></div><p>In many cases, there is a further need to represent characteristics and additional information associated with a role of an object. In such cases, the above element is insufficient. When a role must be modeled with additional information, a <span class="termRef"><a name="d3e6460" href="#definition_role_type">[role type]</a></span> is called for.</p><p>For example, when a person is a driver involved in an automotive crash, that person has a particular role in the crash, which is modeled by the element <code>j:CrashDriver</code>.</p><div class="figure"><a name="figure_10-2"></a><div class="caption">Figure 10-2: Element <code>j:CrashDriver</code>, modeling the role of a driver in a crash</div><div class="box"><pre>&lt;xs:element name="CrashDriver" type="j:CrashDriverType" nillable="true"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A motor vehicle driver involved into a traffic accident.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</pre></div></div><p>There is more information associated with this role of the driver than just his identity as a person. Information associated with this role include the drivers license, contributing circumstances, distractions, and other properties. These characteristics are modeled as shown in the following figure. The role is modeled as a <span class="termRef"><a name="d3e6494" href="#definition_role_type">[role type]</a></span>:</p><div class="figure"><a name="figure_10-3"></a><div class="caption">Figure 10-3: Role type <code>j:CrashDriverType</code>, modeling a driver involved in a crash</div><div class="box"><pre>&lt;xs:complexType name="CrashDriverType"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A data type for a motor vehicle driver involved in a traffic accident.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;xs:complexContent&gt;
    &lt;xs:extension base="structures:ObjectType"&gt;
      &lt;xs:sequence&gt;
        &lt;xs:element ref="nc:RoleOfPerson" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="j:DriverLicense" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="j:CrashDriverContributingCircumstances" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="j:CrashDriverDistraction" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="j:CrashDriverViolation" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="j:CrashDrivingViolation" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;xs:element ref="j:CrashDriverAugmentationPoint" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
    &lt;/xs:extension&gt;
  &lt;/xs:complexContent&gt;
&lt;/xs:complexType&gt;</pre></div></div><p>The term <span class="termRef"><a name="d3e6546" href="#definition_role_type">[role type]</a></span> has a normative definition:</p><div class="box"><a name="definition_role_type"></a><div class="normativeHead">[Definition: <dfn>role type</dfn>]</div><div class="sub"><p>A <strong>role type</strong> is an <span class="termRef"><a name="d3e6557" href="#definition_object_type">[object type]</a></span> that represents a particular function, purpose, usage, or role of one or more objects of its base type.</p></div></div><p>A role type defines an object that carries information associated with an object playing a role. A role type is used instead of the base type (in this case, <code>nc:PersonType</code>). The role type holds information that is specific to the role, but is not specific to the context or the base object (the object that plays the role). Developers of NIEM-conformant schemas should create and use role types whenever they have nonpersistent information specific to a base object’s function. Such information generally expires when the base object is no longer playing the role. Information that is persistent to the base object probably does not belong in a role type.</p><div class="box"><a name="definition_RoleOf_element"></a><div class="normativeHead">[Definition: <dfn>RoleOf element</dfn>]</div><div class="sub"><p>A <strong>RoleOf element</strong> is an <span class="termRef"><a name="d3e6578" href="#definition_element_declaration_schema_component">[element declaration schema component]</a></span> that</p><ul><li>is defined by a <span class="termRef"><a name="d3e6587" href="#definition_conformant_reference_schema_document">[conformant reference schema document]</a></span> or a <span class="termRef"><a name="d3e6590" href="#definition_conformant_extension_schema_document">[conformant extension schema document]</a></span>, and</li><li>has a {name} that begins with <q>RoleOf</q>.</li></ul><p>A RoleOf element represents a base type for a <span class="termRef"><a name="d3e6604" href="#definition_role_type">[role type]</a></span>.</p></div></div><p>We saw the use of <span class="termRef"><a name="d3e6611" href="#definition_RoleOf_element">[RoleOf element]</a></span> <code>nc:RoleOfPerson</code> in <a href="#figure_10-3">Figure 10-3, <em>Role type <code>j:CrashDriverType</code>, modeling a driver involved in a crash</em>, above</a>. Its definition is the following figure:</p><div class="figure"><a name="figure_10-4"></a><div class="caption">Figure 10-4: Declaration of RoleOf element <code>nc:RoleOfPerson</code></div><div class="box"><pre>&lt;xs:element name="RoleOfPerson" type="nc:PersonType" substitutionGroup="nc:RoleOf" nillable="true"&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;A person of whom the role object is a function.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
&lt;/xs:element&gt;</pre></div></div><p>Here is an example of the <code>j:CrashDriver</code> role type used in an instance:</p><div class="figure"><a name="figure_10-5"></a><div class="caption">Figure 10-5: An XML instance of a role type</div><div class="box"><pre>&lt;j:CrashDriver&gt;
  &lt;nc:RoleOfPerson structures:ref="BRAVO"/&gt;
  &lt;j:CrashDriverViolationCode&gt;A10&lt;/j:CrashDriverViolationCode&gt;
  &lt;j:CrashDrivingViolationCode&gt;S16&lt;/j:CrashDrivingViolationCode&gt;
&lt;/j:CrashDriver&gt;
&lt;nc:Person structures:id="BRAVO"&gt;
  &lt;nc:PersonBirthDate&gt;
    &lt;nc:Date&gt;1966-06-06&lt;/nc:Date&gt;
  &lt;/nc:PersonBirthDate&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
&lt;/nc:Person&gt;</pre></div></div><p>Note that the value of the <code>j:CrashPerson</code> element was indicated above using a reference; it could have been shown as a content element, instead.</p><div class="section"><a name="section_10.2.2.2.1"></a><div class="heading">10.2.2.2.1. RoleOf element type is an object type</div><div class="box"><a name="rule_10-4"></a><div class="normativeHead">[Rule 10-4] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[@name[starts-with(., 'RoleOf')]]"&gt;
    &lt;sch:assert test="every $type in @type,
                            $type-local-name in local-name-from-QName(resolve-QName($type, .)) satisfies
                        not(ends-with($type-local-name, 'AssociationType')
                            or ends-with($type-local-name, 'MetadataType')
                            or ends-with($type-local-name, 'AugmentationType'))"
      &gt;The type definition of a RoleOf element SHALL be an object type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Note that by <a href="#rule_11-13"><strong>[Rule 11-13]</strong>, below</a>, the element’s type must be from a conformant namespace.</p></div><div class="section"><a name="section_10.2.2.2.2"></a><div class="heading">10.2.2.2.2. Only object types have RoleOf element</div><div class="box"><a name="rule_10-5"></a><div class="normativeHead">[Rule 10-5] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[
      empty(@appinfo:externalAdapterTypeIndicator)
      and exists(descendant::xs:element[
            exists(@ref[
              starts-with(local-name-from-QName(resolve-QName(., ..)), 'RoleOf')])])]"&gt;
    &lt;sch:assert test="not(ends-with(@name, 'AssociationType')
                          or ends-with(@name, 'MetadataType')
                          or ends-with(@name, 'AugmentationType'))"
      &gt;A complex type that includes a RoleOf element in its content model SHALL be an object type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Note that <span class="termRef"><a name="d3e6740" href="#definition_RoleOf_element">[RoleOf element]</a></span> and <span class="termRef"><a name="d3e6743" href="#definition_object_type">[object type]</a></span> are defined terms.</p></div><div class="section"><a name="section_10.2.2.2.3"></a><div class="heading">10.2.2.2.3. RoleOf element indicates the base types of a role type</div><div class="box"><a name="rule_10-6"></a><div class="normativeHead">[Rule 10-6] (REF, EXT) (Interpretation)</div><p>For every <span class="termRef"><a name="d3e6756" href="#definition_element_declaration_schema_component">[element declaration schema component]</a></span> that has a local name that begins with the string <q>RoleOf</q> SHALL represent a base type, of which the containing type represents a role.</p></div></div><div class="section"><a name="section_10.2.2.2.4"></a><div class="heading">10.2.2.2.4. Instance of RoleOf element indicates a role object</div><div class="box"><a name="rule_10-7"></a><div class="normativeHead">[Rule 10-7] (INS) (Interpretation)</div><p>When a parent element has a child element valid to an <span class="termRef"><a name="d3e6773" href="#definition_element_declaration_schema_component">[element declaration schema component]</a></span> that is a <span class="termRef"><a name="d3e6776" href="#definition_RoleOf_element">[RoleOf element]</a></span>,</p><ul><li>The value of the parent element is a role object.</li><li>The value of the child element is a base object of the role object.</li></ul></div><p>An instance of a <span class="termRef"><a name="d3e6794" href="#definition_RoleOf_element">[RoleOf element]</a></span> indicates the base object of a role. The prefix <q>RoleOf</q> on the element ensures that a role object may be distinguished from other objects and that its link to the base object is also distinguishable from the additional properties that are characteristics or other data of the role.</p></div><p>NIEM does not require that there be only one <span class="termRef"><a name="d3e6804" href="#definition_RoleOf_element">[RoleOf element]</a></span> within a single type, nor does it require that a particular role object have only a single occurrence of a <span class="termRef"><a name="d3e6807" href="#definition_RoleOf_element">[RoleOf element]</a></span>. However, the use of multiple <span class="termRef"><a name="d3e6810" href="#definition_RoleOf_element">[RoleOf elements]</a></span> may not make sense in all cases. Many exchanges may restrict <span class="termRef"><a name="d3e6813" href="#definition_RoleOf_element">[RoleOf elements]</a></span> to a single occurrence within a type.</p></div><div class="section"><a name="section_10.2.2.3"></a><div class="heading">10.2.2.3. External adapter types</div><p>There are a variety of commonly used standards that are represented in XML Schema. Such schemas are generally not NIEM-conformant. NIEM-conformant schemas may reference components defined by these external schemas. NIEM-conformant components may be constructed from schema components that are not NIEM-conformant.</p><div class="box"><a name="definition_external_schema"></a><div class="normativeHead">[Definition: <dfn>external schema</dfn>]</div><div class="sub"><p>An <strong>external schema</strong> is any schema that is not a supporting schema and that is not NIEM-conformant.</p></div></div><p>Note that the supporting schemas <code>structures</code> and <code>appinfo</code> are nonconformant because they define the fundamental framework on which NIEM is built; they are NIEM’s support schemas. However, they are not considered external schemas because of their supporting nature and are thus excluded from this definition.</p><p>NIEM-conformant schemas may work with external schemas by creating <span class="termRef"><a name="d3e6847" href="#definition_adapter_type">[adapter types]</a></span>.</p><p>A single method is used to integrate external components into NIEM-conformant schemas: NIEM-conformant types are constructed from the external components.</p><div class="figure"><a name="figure_10-6"></a><div class="caption">Figure 10-6: Use of external components to create a NIEM-conformant type</div><div class="box"><div class="img"><img src="data:image/png;base64,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" style="max-width:720px"></div></div></div><p>Components defined by external schemas are called <em>external components</em>. A NIEM-conformant type may use external components in a specific way: to construct a NIEM-conformant type from external components. The goal in this method is to preserve as a single unit a set of data that embodies a single <em>concept</em> from an external standard.</p><p>For example, a NIEM-conformant type may be created to represent a bibliographic reference from an external standard. Such an object may be composed of multiple elements and types from the external standard. These pieces are put together to form a single NIEM-conformant type. For example, an element representing an author, a book, and a publisher may be included in a single bibliographic entry.</p><p>A NIEM-conformant type built from these components may be used as any other NIEM- conformant type. That is, elements may be constructed from such a type, and those elements are fully NIEM-conformant.</p><p>To construct such a component, a NIEM-conformant schema must first import an external schema.</p><div class="box"><a name="rule_10-8"></a><div class="normativeHead">[Rule 10-8] (REF, EXT) (Constraint)</div><p>Within the schema, an element <code>xs:import</code> that imports a namespace defined by an external schema MUST have the application information <code>appinfo:ConformantIndicator</code>, with a value of <code>false</code>.</p></div><p><strong>Rationale</strong></p><p>Knowledge of the conformance of an imported schema allows processors to understand the semantics of referenced components, without additional processing. Namespaces imported into NIEM-conformant schemas are assumed to be conformant unless otherwise indicated.</p><div class="box"><a name="rule_10-9"></a><div class="normativeHead">[Rule 10-9] (REF, EXT) (Constraint)</div><p>Within the schema, an element <code>xs:import</code> that imports a namespace defined by an external schema MUST be a documented component.</p></div><p><strong>Rationale</strong></p><p>A NIEM-conformant schema has well-known documentation points. Therefore, a schema that imports a NIEM-conformant namespace need not provide additional documentation. However, when an external schema is imported, appropriate documentation must be provided at the point of import because documentation associated with external schemas is undefined and variable. In this particular case, documentation of external schemas is required at their point of use in NIEM.</p><div class="box"><a name="definition_adapter_type"></a><div class="normativeHead">[Definition: <dfn>adapter type</dfn>]</div><div class="sub"><p>An <strong>adapter type</strong> is a NIEM-conformant type that adapts external components for use within NIEM. An adapter type creates a new class of object that embodies a single concept composed of external components. A NIEM-conformant schema defines an adapter type.</p></div></div><div class="box"><a name="rule_10-10"></a><div class="normativeHead">[Rule 10-10] (REF, EXT) (Constraint)</div><p>Within the schema, an adapter type MUST have application information <code>appinfo:ExternalAdapterTypeIndicator</code> with a value of <code>true</code>. A type that is not an adapter type SHALL NOT contain that indicator.</p></div><p><strong>Rationale</strong></p><p>This rule flags as external adapters those types that may contain external content. This allows for easier processing.</p><div class="box"><a name="rule_10-11"></a><div class="normativeHead">[Rule 10-11] (REF, EXT) (Constraint)</div><p>Within the schema, an adapter type MUST be an immediate extension of type <code>structures:ComplexObjectType</code>.</p></div><p><strong>Rationale</strong></p><p>The adapter type must contain the content defined for any NIEM component. The type <code>structures:ComplexObjectType</code> provides such content.</p><div class="box"><a name="rule_10-12"></a><div class="normativeHead">[Rule 10-12] (REF, EXT) (Constraint)</div><p>Within the schema, an adapter type MUST be composed of only elements and attributes from an external standard.</p></div><p><strong>Rationale</strong></p><p>An adapter type should contain the information from an external standard to express a complete concept. This expression should be composed of content entirely from an external schema. Most likely, the external schema will be based on an external standard with its own legacy support.</p><p>In the case of an external expression that is in the form of model groups, attribute groups, or types, additional elements and type components may be created in an external schema, and the adapter type may use those components.</p><div class="box"><a name="rule_10-13"></a><div class="normativeHead">[Rule 10-13] (REF, EXT) (Constraint)</div><p>Within the schema, an element reference used in an adapter type definition MUST be a documented component.</p></div><div class="box"><a name="rule_10-14"></a><div class="normativeHead">[Rule 10-14] (REF, EXT) (Constraint)</div><p>Within the schema, an attribute reference used in an adapter type definition MUST be a documented component.</p></div><p><strong>Rationale</strong></p><p>In normal (conformant) type definition, a reference to an attribute or element is a reference to a documented component. Within an adapter type, the references to the attributes and elements being adapted are references to undocumented components. These components must be documented to provide comprehensibility and interoperability. Since documentation made available by nonconformant schemas is undefined and variable, documentation of these components is required at their point of use, within the conformant schema.</p><div class="box"><a name="rule_10-15"></a><div class="normativeHead">[Rule 10-15] (REF, EXT) (Constraint)</div><p>Within the schema, an adapter type MUST NOT be extended or restricted.</p></div><p><strong>Rationale</strong></p><p>Adapter types are meant to stand alone; each type expresses a single concept from an external schema, and adapter types are maintained in separate schemas that only contain adapter types. In this way, processors may easily switch modes, processing NIEM-conformant content in one way, and external content in another.</p><div class="section"><a name="section_10.2.2.3.1"></a><div class="heading">10.2.2.3.1. External adapter type has complex content</div><div class="box"><a name="rule_10-16"></a><div class="normativeHead">[Rule 10-16] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)]"&gt;
    &lt;sch:assert test="xs:complexContent"
      &gt;An external adapter type definition must be a complex type definition with complex content.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.2.2.3.2"></a><div class="heading">10.2.2.3.2. External adapter type uses extension</div><div class="box"><a name="rule_10-17"></a><div class="normativeHead">[Rule 10-17] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)
                                    and exists(xs:complexContent)]"&gt;
    &lt;sch:assert test="xs:complexContent/xs:extension"
      &gt;An external adapter type definition must be use the extension derivation method.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.2.2.3.3"></a><div class="heading">10.2.2.3.3. External adapter type extends structures:ObjectType</div><div class="box"><a name="rule_10-18"></a><div class="normativeHead">[Rule 10-18] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)
                                    and exists(xs:complexContent/xs:extension)]"&gt;
    &lt;sch:assert test="for $extension in xs:complexContent/xs:extension return
                        resolve-QName($extension/@base, $extension) = xs:QName('structures:ObjectType')"
      &gt;An external adapter type definition MUST extend structures:ObjectType.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.2.2.3.4"></a><div class="heading">10.2.2.3.4. External adapter types use sequence</div><div class="box"><a name="rule_10-19"></a><div class="normativeHead">[Rule 10-19] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)
                                    and exists(xs:complexContent/xs:extension)]"&gt;
    &lt;sch:assert test="exists(xs:complexContent/xs:extension/xs:sequence)"
      &gt;An external adapter type must use sequence as its top-level compositor.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_10.2.2.4"></a><div class="heading">10.2.2.4. Code types</div><div class="box"><a name="definition_code_type"></a><div class="normativeHead">[Definition: <dfn>code type</dfn>]</div><div class="sub"><p>A <strong>code type</strong> is a NIEM object type with a content model that is constrained by one or more enumeration facets.</p></div></div><p>These types represent lists of values, each of which has a known meaning beyond the text representation. These values may be meaningful text or may be a string of alphanumeric identifiers that represent abbreviations for literals.</p><div class="section"><a name="section_10.2.2.4.1"></a><div class="heading">10.2.2.4.1. The name of a code type ends in <q>CodeType</q></div><div class="box"><a name="rule_10-20"></a><div class="normativeHead">[Rule 10-20] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:let name="has-code-type-name" value="ends-with(@name, 'CodeType')"/&gt;
    &lt;sch:let name="has-code-type-base" value="
        exists(xs:simpleContent[
          exists(xs:*[local-name() = ('extension', 'restriction')
                      and (ends-with(@base, 'CodeSimpleType')
                           or ends-with(@base, 'CodeType'))])])"/&gt;
    &lt;sch:assert test="$has-code-type-name = $has-code-type-base"
      &gt;A complex type with a [base type] of a code type or code simple type MUST have a name that ends in 'CodeType'.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Using the qualifier <code>Code</code> (e.g. <code>CodeType</code>, <code>CodeSimpleType</code>) immediately identifies a type as representing a fixed list of codes. These types may be handled in specific ways, as lists of codes are expected to have their own lifecycles, including versions and periodic updates. Codes may also have responsible authorities behind them who provide concrete semantic bindings for the code values.</p></div></div><div class="section"><a name="section_10.2.2.5"></a><div class="heading">10.2.2.5. Proxy types</div></div></div><div class="section"><a name="section_10.2.3"></a><div class="heading">10.2.3. Associations</div><p>Within NIEM, an <a name="d3e7177">association</a> is a specific relationship between objects. Associations are used when a simple NIEM property is insufficient to model the relationship clearly and when properties of the relationship exist that are not attributable to the objects being related.</p><p>Here is an example of an association in an XML instance:</p><div class="figure"><a name="figure_10-7"></a><div class="caption">Figure 10-7: An association in an instance</div><div class="box"><pre>&lt;nc:GuardianAssociation&gt;
  &lt;nc:PersonGuardianReference s:ref="p1"/&gt;
  &lt;nc:PersonDependentReference s:ref="p2"/&gt;
&lt;/nc:GuardianAssociation&gt;

&lt;nc:Person s:id="p1"&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
&lt;/nc:Person&gt;
          
&lt;nc:Person s:id="p2"&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;Jane Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
&lt;/nc:Person&gt;</pre></div></div><p>This example shows an association between a guardian and a dependent. This relationship is defined by the element <code>nc:GuardianAssociation</code>, whose structure is defined by the type <code>nc:GuardianAssociationType</code>. The type defines what an association relates, but the element defines the actual meaning of the association.</p><p>An example of an association type defined by an XML Schema document follows.</p><p>Note that the NIEM Core schema in NIEM 2.0 defines a type <code>nc:AssociationType</code>, which acts as the base type for all other association types defined within NIEM Core. This is a convention adopted by the NIEM Core namespace but is not a requirement of the NDR. Implementers of NIEM-conformant schemas are not required to base association types on <code>nc:AssociationType</code>.</p><div class="figure"><a name="figure_10-8"></a><div class="caption">Figure 10-8: A definition of an association type</div><div class="box"><pre>&lt;xsd:complexType name="AssociationType"&gt;
  ...
  &lt;xsd:complexContent&gt;
    &lt;xsd:extension base="s:ComplexObjectType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="nc:AssociationBeginDate" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element ref="nc:AssociationEndDate" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;/xsd:extension&gt;
  &lt;/xsd:complexContent&gt;
&lt;/xsd:complexType&gt;

&lt;xsd:complexType name="GuardianAssociationType"&gt;
  ...
  &lt;xsd:complexContent&gt;
    &lt;xsd:extension base="nc:AssociationType"&gt;
    &lt;xsd:sequence&gt;
      &lt;xsd:element ref="nc:PersonGuardianReference" minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;xsd:element ref="nc:PersonDependentReference" minOccurs="0" maxOccurs="unbounded"/&gt;
    &lt;/xsd:sequence&gt;
    &lt;/xsd:extension&gt;
  &lt;/xsd:complexContent&gt;
&lt;/xsd:complexType&gt;

&lt;xsd:element name="GuardianAssociation" type="nc:GuardianAssociationType" nillable="true"&gt;
  ...
&lt;/xsd:element&gt;</pre></div></div><p>This schema fragment shows the definition of a generic <code>AssociationType</code>, which contains a begin and end date. It then defines a specific association type, which contains the structure required to express guardianship. This is followed by the definition of an element that expresses the semantics of the guardian relationship.</p><div class="box"><a name="definition_association_type"></a><div class="normativeHead">[Definition: <dfn>association type</dfn>]</div><div class="sub"><p>In a NIEM-conformant schema, an <strong>association type</strong> is a type that establishes a relationship between objects, along with the properties of that relationship. An association type provides a structure that does not establish existence of an object but instead specifies relationships between objects.</p></div></div><div class="box"><a name="definition_association"></a><div class="normativeHead">[Definition: <dfn>association</dfn>]</div><div class="sub"><p>In a NIEM-conformant schema, an <strong>association</strong> is an element whose type is an association type.</p></div></div><div class="box"><a name="rule_10-21"></a><div class="normativeHead">[Rule 10-21] (REF, EXT) (Constraint)</div><p>Within the schema, an association type SHALL be a complex type definition that either constitutes a NIEM-conformant component or for which there exists a NIEM-conformant component definition. The NIEM-conformant component definition SHALL have one of the following forms:</p><ol><li>Has complex content, is based on the complex type <code>structures:ComplexObjectType</code>, and has application information <code>appinfo:Base</code> of <code>structures:Association</code>.</li><li>Is a complex type that is derived from an association type, which is defined according to this rule.</li></ol></div><p><strong>Rationale</strong></p><p>Associations within reference schemas, extensions schemas, and exchange schemas are easily identifiable as such and have a commonly defined base type. For subset schemas, the NIEM-conformant definition may be located in a primary schema and then identified.</p><div class="box"><a name="rule_10-22"></a><div class="normativeHead">[Rule 10-22] (REF, EXT) (Constraint)</div><p>Given that an association type defines a relationship between a set of participants, within an association type definition, any element that represents a participant SHALL be a reference element.</p></div><p><strong>Rationale</strong></p><p>Associations are intended to relate objects defined elsewhere. They are not intended to carry content of participant objects.</p><div class="section"><a name="section_10.2.3.1"></a><div class="heading">10.2.3.1. Association types</div><div class="section"><a name="section_10.2.3.1.1"></a><div class="heading">10.2.3.1.1. Association types are derived from association types</div><div class="box"><a name="rule_10-23"></a><div class="normativeHead">[Rule 10-23] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:let name="is-association-type" value="exists(@name[ends-with(., 'AssociationType')])"/&gt;
    &lt;sch:let name="has-association-base-type" value="
      exists(xs:complexContent[
        exists(xs:*[local-name() = ('extension', 'restriction')
                    and exists(@base[ends-with(., 'AssociationType')])])])"/&gt;
    &lt;sch:assert test="$is-association-type = $has-association-base-type"
      &gt;A type MUST have a association type name if an only if it is derived from a association type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Using the qualifier <code>Association</code> immediately identifies a type as representing an association.</p></div></div><div class="section"><a name="section_10.2.3.2"></a><div class="heading">10.2.3.2. Association element declarations</div><div class="section"><a name="section_10.2.3.2.1"></a><div class="heading">10.2.3.2.1. Association element is an element of an association type</div><div class="box"><a name="rule_10-24"></a><div class="normativeHead">[Rule 10-24] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name)]"&gt;
    &lt;sch:assert test="exists(@type[ends-with(., 'AssociationType')])
                      = exists(@name[ends-with(., 'Association')])"
      &gt;An element MUST have a name that ends in 'Association' if and only if it has a type that is a association type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Using the qualifier <code>Association</code> immediately identifies an element as representing an association.</p></div></div></div><div class="section"><a name="section_10.2.4"></a><div class="heading">10.2.4. Augmentations</div><p>Sections:</p><ul><li><a href="#section_10.2.4.1">Section 10.2.4.1, <em>Augmentable types</em></a></li><li><a href="#section_10.2.4.2">Section 10.2.4.2, <em>Augmentation point element declarations</em></a></li><li><a href="#section_10.2.4.3">Section 10.2.4.3, <em>Augmentation point element use</em></a></li><li><a href="#section_10.2.4.4">Section 10.2.4.4, <em>Augmentation types</em></a></li><li><a href="#section_10.2.4.5">Section 10.2.4.5, <em>Augmentation element declarations</em></a></li></ul><p>Builders of domains and extensions to NIEM distribution schemas need to be able to define extensions to types. However, extension of types by multiple domain schemas and extension schemas proves problematic, as it results in multiple extensions of a single type. XML Schema does not provide for multiple types of an instance;consequently, such a method results in duplication of base type content and a need to resolve <q>same-as</q> relationships between the instances of the various derived types.</p><p>Instead, it is preferable for domains and extensions to provide augmentations. These are reusable types and elements of those types, which may be added to an object class, in a single extended type, by the author of a NIEM-conformant schema. This avoids the problem of multiple extended types but allows domains and extensions to define reusable extensions.</p><p>Augmentation types such as <code>j:PersonAugmentationType</code>, where <q>j</q> is the prefix for the NIEM Justice domain, <code>http://release.niem.gov/niem/domains/jxdm/5.0/</code>, exist to extend NIEM Core types such as <code>nc:PersonType</code> without creating a new specialized object within the model. Augmentation types are never applied within the model to the types they are designed to augment. Doing so would restrict reusing and combining these augmentations.</p><p>Instead, augmentation should be applied within IEPDs. So in an IEPD (NOT within NIEM), base <code>nc:PersonType</code> may be extended, for example, as <code>my-iepd:PersonType</code> by adding elements <code>a:PersonAugmentation</code> and <code>b:PersonAugmentation</code>. As a result, <code>my-iepd:PersonType</code> will contain all the properties in <code>nc:PersonType</code> plus the properties in both of the elements <code>a:PersonAugmentation</code> and <code>b:PersonAugmentation</code>, which, in turn, each contain their respective sets of subelements.</p><p>All NIEM augmentation types extend the abstract type <code>structures:AugmentationType</code>. Therefore, all augmentation types automatically contain the attributes <code>structures:id</code> and <code>structures:metadata</code> for referencing and metadata, respectively. NIEM also provides the abstract element <code>structures:Augmentation</code> (of type <code>structures:AugmentationType</code>) as the common substitution group head for all augmentation elements. An augmentation element placed into this substitution group can be used in an instance wherever <code>structures:Augmentation</code> occurs in the corresponding IEPD schema. The user must follow NIEM naming conventions for augmentation component names and must place new augmentation elements into the <code>structures:Augmentation</code> substitution group. Further, if an augmentation element cannot be applied to all types in the model, then the user must document those types that the new augmentation element can be applied to using the <code>appinfo:AppliesTo</code> element.</p><div class="box"><a name="definition_augmentation"></a><div class="normativeHead">[Definition: <dfn>augmentation</dfn>]</div><div class="sub"><p>An <strong>augmentation</strong> of a NIEM-conformant object type is a block of additional data added to an object type to carry additional data beyond that of the original object definition.</p></div></div><div class="box"><a name="rule_10-25"></a><div class="normativeHead">[Rule 10-25] (REF, EXT) (Constraint)</div><p>An augmentation type:</p><ol><li>SHALL be transitively derived from <code>structures:AugmentationType</code>.</li><li>SHALL contain elements that represent properties to be applied to a base type.</li></ol></div><p><strong>Rationale</strong></p><p>A base type is the type to which an augmentation is to be applied. An augmentation may be applied to any number of types. Base types are assigned by augmentation elements.</p><div class="box"><a name="rule_10-26"></a><div class="normativeHead">[Rule 10-26] (REF, EXT) (Constraint)</div><p>Within the schema, an augmentation element definition:</p><ol><li>SHALL have a type that is an augmentation type.</li><li>SHALL use the <code>substitutionGroup</code> attribute such that it is transitively substitutable for the element <code>structures:Augmentation</code>.</li></ol><p>An element that is not an augmentation element SHALL NOT meet either of the above criteria.</p></div><p><strong>Rationale</strong></p><p>An augmentation is trivially identifiable as such. The use of the common <code>structures:Augmentation</code> element allows message builders to optionally delay specifying augmentations to be applied to a type until runtime.</p><div class="box"><a name="rule_10-27"></a><div class="normativeHead">[Rule 10-27] (REF, EXT) (Constraint)</div><p>Within the schema, an element definition for an augmentation element MAY contain one or more instances of the element <code>appinfo:AppliesTo</code> as application information to specify types to which the augmentation element applies.</p></div><div class="box"><a name="rule_10-28"></a><div class="normativeHead">[Rule 10-28] (REF, EXT) (Constraint)</div><p>Within the schema, an element definition for an augmentation element that does not contain any instances of the element <code>appinfo:AppliesTo</code> MAY be applied to any object or association type.</p></div><p><strong>Rationale</strong></p><p>These rules allow schema builders to establish applicability for augmentations. An augmentation may be applicable to specific types.</p><p>Users who wish to apply an augmentation type to a given object type may do so by creating a new augmentation element, applicable to the object type.</p><div class="section"><a name="section_10.2.4.1"></a><div class="heading">10.2.4.1. Augmentable types</div><div class="box"><a name="definition_augmentable_type"></a><div class="normativeHead">[Definition: <dfn>augmentable type</dfn>]</div><div class="sub"><p>An <em>augmentable type</em> is any <span class="termRef"><a name="d3e7568" href="#definition_complex_type_definition">[complex type definition]</a></span> that meets all of these criteria:</p><ul><li>It is defined by either a <span class="termRef"><a name="d3e7577" href="#definition_conformant_reference_schema_document">[conformant reference schema document]</a></span> or by an <span class="termRef"><a name="d3e7580" href="#definition_conformant_extension_schema_document">[conformant extension schema document]</a></span>.</li><li><p>It is either:</p><ul><li>an <span class="termRef"><a name="d3e7593" href="#definition_association_type">[association type]</a></span>, or</li><li>an <span class="termRef"><a name="d3e7600" href="#definition_object_type">[object type]</a></span> that has complex content and is not an external adapter type.</li></ul></li></ul></div></div><div class="section"><a name="section_10.2.4.1.1"></a><div class="heading">10.2.4.1.1. Augmentable type has augmentation point</div><div class="box"><a name="rule_10-29"></a><div class="normativeHead">[Rule 10-29] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[
                       exists(@name[
                         not(ends-with(., 'MetadataType'))
                         and not(ends-with(., 'AugmentationType'))])
                       and empty(@appinfo:externalAdapterTypeIndicator)
                       and exists(child::xs:complexContent)]"&gt;
    &lt;sch:let name="augmentation-point-qname" 
             value="QName(nf:get-target-namespace(.),
                          replace(./@name, 'Type$', 'AugmentationPoint'))"/&gt;
    &lt;sch:assert test="count(xs:complexContent/xs:extension/xs:sequence/xs:element[
                              exists(@ref[resolve-QName(., ..) = $augmentation-point-qname])]) = 1"
      &gt;An augmentable type MUST contain exactly one reference its augmentation point element.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_10.2.4.2"></a><div class="heading">10.2.4.2. Augmentation point element declarations</div><div class="section"><a name="section_10.2.4.2.1"></a><div class="heading">10.2.4.2.1. An augmentation point corresponds to an augmentable type</div><div class="box"><a name="rule_10-30"></a><div class="normativeHead">[Rule 10-30] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name[
                                 matches(., 'AugmentationPoint$')])]"&gt;
    &lt;sch:let name="element-name" value="@name"/&gt;
    &lt;sch:assert test="exists(
                        parent::xs:schema/xs:complexType[
                          @name = replace($element-name, 'AugmentationPoint$', 'Type')
                          and exists(@name[
                                  not(ends-with(., 'MetadataType'))
                                  and not(ends-with(., 'AugmentationType'))])
                                and empty(@appinfo:externalAdapterTypeIndicator)
                                and exists(child::xs:complexContent)])"
      &gt;A schema document defining an augmentation point element MUST also define a corresponding [augmentable type].&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.2.4.2.2"></a><div class="heading">10.2.4.2.2. An augmentation point has no type</div><div class="box"><a name="rule_10-31"></a><div class="normativeHead">[Rule 10-31] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name[
                                 matches(., 'AugmentationPoint$')])]"&gt;
    &lt;sch:assert test="empty(@type)"
        &gt;An augmentation point element MUST have no type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>There is no rule requiring that the augmentation element is abstract, as that is implied by the lack of @type.</p></div><div class="section"><a name="section_10.2.4.2.3"></a><div class="heading">10.2.4.2.3. An augmentation point has no substitution group</div><div class="box"><a name="rule_10-32"></a><div class="normativeHead">[Rule 10-32] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name[
                                 matches(., 'AugmentationPoint$')])]"&gt;
    &lt;sch:assert test="empty(@substitutionGroup)"
        &gt;An augmentation point element MUST have no substitution group.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_10.2.4.3"></a><div class="heading">10.2.4.3. Augmentation point element use</div><div class="section"><a name="section_10.2.4.3.1"></a><div class="heading">10.2.4.3.1. Augmentation element may only be referenced by its type</div><div class="box"><a name="rule_10-33"></a><div class="normativeHead">[Rule 10-33] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType//xs:element[exists(@ref[
                       matches(local-name-from-QName(resolve-QName(., ..)), 'AugmentationPoint$')]) ]"&gt;

    &lt;sch:assert test="QName(nf:get-target-namespace(ancestor::xs:complexType[1]), ancestor::xs:complexType[1]/@name)
                      = QName(namespace-uri-from-QName(resolve-QName(@ref, .)), 
               replace(local-name-from-QName(resolve-QName(@ref, .)), 'AugmentationPoint$', 'Type'))"
      &gt;An augmentation element MUST only be referenced by its corresponding type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;            </pre></div></div><div class="section"><a name="section_10.2.4.3.2"></a><div class="heading">10.2.4.3.2. Augmentation reference is optional</div><div class="box"><a name="rule_10-34"></a><div class="normativeHead">[Rule 10-34] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType//xs:element[exists(@ref[
                           matches(local-name-from-QName(resolve-QName(., ..)), 'AugmentationPoint$')]) ]"&gt;
    &lt;sch:assert test="exists(@minOccurs) and xs:integer(@minOccurs) = 0"
        &gt;An augmentation element particle MUST have attribute minOccurs equal to 0.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.2.4.3.3"></a><div class="heading">10.2.4.3.3. Augmentation reference is unbounded</div><div class="box"><a name="rule_10-35"></a><div class="normativeHead">[Rule 10-35] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType//xs:element[exists(@ref[
                           matches(local-name-from-QName(resolve-QName(., ..)), 'AugmentationPoint$')]) ]"&gt;
    &lt;sch:assert test="exists(@maxOccurs) and string(@maxOccurs) = 'unbounded'"
       &gt;An augmentation element particle MUST have attribute maxOccurs set to unbounded.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.2.4.3.4"></a><div class="heading">10.2.4.3.4. Augmentation reference must be last particle</div><div class="box"><a name="rule_10-36"></a><div class="normativeHead">[Rule 10-36] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType//xs:element[exists(@ref[
                           matches(local-name-from-QName(resolve-QName(., ..)), 'AugmentationPoint$')]) ]"&gt;
    &lt;sch:assert test="empty(following-sibling::*)"
       &gt;An augmentation element particle MUST be the last element atom in its content model.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_10.2.4.4"></a><div class="heading">10.2.4.4. Augmentation types</div><div class="box"><a name="definition_augmentation_type"></a><div class="normativeHead">[Definition: <dfn>augmentation type</dfn>]</div><div class="sub"><p>An <strong>augmentation type</strong> is a complex type that provides a reusable block of data that may be added to object types or association types.</p></div></div><div class="section"><a name="section_10.2.4.4.1"></a><div class="heading">10.2.4.4.1. Augmentation type name ends in <q>AugmentationType</q></div><div class="box"><a name="rule_10-37"></a><div class="normativeHead">[Rule 10-37] (REF, EXT) (Constraint)</div><p>A <span class="termRef"><a name="d3e7825" href="#definition_schema_component">[schema component]</a></span> has a name that ends in <q>AugmentationType</q> if and only if it is a <span class="termRef"><a name="d3e7831" href="#definition_complex_type_definition">[complex type definition]</a></span> that defines an <span class="termRef"><a name="d3e7834" href="#definition_augmentation_type">[augmentation type]</a></span>.</p></div></div><div class="section"><a name="section_10.2.4.4.2"></a><div class="heading">10.2.4.4.2. Augmentation type derived from augmentation type</div><div class="box"><a name="rule_10-38"></a><div class="normativeHead">[Rule 10-38] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[@name[ends-with(., 'AugmentationType')]]"&gt;
    &lt;sch:assert test="xs:complexContent/
                        xs:*[self::xs:extension or self::xs:restriction]/
                          @base[resolve-QName(., ..) = xs:QName('structures:AugmentationType')
                                or ends-with(., 'AugmentationType')]"
      &gt;The [base type definition] of an [augmentation type] MUST be either structures:AugmentationType or an [augmentation type].&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>The <span class="termRef"><a name="d3e7862" href="#definition_base_type_definition">[base type definition]</a></span> of an <span class="termRef"><a name="d3e7865" href="#definition_augmentation_type">[augmentation type]</a></span> is required to be from a conformant namespace by <a href="#rule_11-3"><strong>[Rule 11-3]</strong>, below</a>.</p></div><div class="section"><a name="section_10.2.4.4.3"></a><div class="heading">10.2.4.4.3. Augmentation types are derived from augmentation types</div><div class="box"><a name="rule_10-39"></a><div class="normativeHead">[Rule 10-39] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:let name="is-augmentation-type" value="exists(@name[ends-with(., 'AugmentationType')])"/&gt;
    &lt;sch:let name="has-augmentation-base-type" value="
      exists(xs:complexContent[
        exists(xs:*[local-name() = ('extension', 'restriction')
                    and exists(@base[ends-with(., 'AugmentationType')])])])"/&gt;
    &lt;sch:assert test="$is-augmentation-type = $has-augmentation-base-type"
      &gt;A type MUST have a augmentation type name if an only if it is derived from a augmentation type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Using the qualifier <code>Augmentation</code> immediately identifies a type as representing an augmentation.</p></div></div><div class="section"><a name="section_10.2.4.5"></a><div class="heading">10.2.4.5. Augmentation element declarations</div><div class="section"><a name="section_10.2.4.5.1"></a><div class="heading">10.2.4.5.1. Augmentation element is an element of an augmentation type</div><div class="box"><a name="rule_10-40"></a><div class="normativeHead">[Rule 10-40] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name)]"&gt;
    &lt;sch:assert test="exists(@type[ends-with(., 'AugmentationType')])
                      = exists(@name[ends-with(., 'Augmentation')])"
      &gt;An element MUST have a name that ends in 'Augmentation' if and only if it has a type that is a augmentation type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Using the qualifier <code>Augmentation</code> immediately identifies an element as representing an augmentation.</p></div></div></div><div class="section"><a name="section_10.2.5"></a><div class="heading">10.2.5. Metadata</div><div class="section"><a name="section_10.2.5.1"></a><div class="heading">10.2.5.1. Metadata types</div><p>Within NIEM, metadata is defined as <q>data about data.</q> This may include information such as the security of a piece of data or the source of the data. These pieces of metadata may be composed into a metadata type. The types of data to which metadata may be applied may be constrained.</p><div class="box"><a name="definition_metadata_type"></a><div class="normativeHead">[Definition: <dfn>metadata type</dfn>]</div><div class="sub"><p>A <strong>metadata type</strong> describes data about data, that is, information that is not descriptive of objects and their relationships, but is descriptive of the data itself. It is useful to provide a general mechanism for data about data. This provides required flexibility to precisely represent information.</p></div></div><div class="box"><a name="rule_10-41"></a><div class="normativeHead">[Rule 10-41] (REF, EXT) (Constraint)</div><p>Within the schema, a metadata type SHALL contain elements appropriate for a specific class of data about data.</p></div><div class="box"><a name="rule_10-42"></a><div class="normativeHead">[Rule 10-42] (REF, EXT) (Constraint)</div><p>Within the schema, a metadata type and only a metadata type SHALL be derived directly from <code>structures:MetadataType</code>.</p></div><p><strong>Rationale</strong></p><p>A metadata type establishes a specific, named aggregation of data about data. Any type derived from <code>structures:MetadataType</code> is a metadata type. Metadata types should not be derived from other metadata types. Such metadata types should be used asis and additional metadata types defined for additional content.</p><div class="box"><a name="rule_10-43"></a><div class="normativeHead">[Rule 10-43] (REF, EXT) (Constraint)</div><p>Within the schema, a metadata type MAY have application information <code>appinfo:AppliesTo</code>, indicating the NIEM-conformant object, association, or external adapter types to which the metadata applies.</p></div><div class="box"><a name="rule_10-44"></a><div class="normativeHead">[Rule 10-44] (REF, EXT) (Constraint)</div><p>Within the schema, a metadata type that does not have application information <code>appinfo:AppliesTo</code> MAY be applied to any object type, association type, or external adapter type.</p></div><p><strong>Rationale</strong></p><p>Metadata may be constrained to be applicable to only specific types, or it may be defined to be applicable to any type. The source of a piece of data and the security classification of a piece of data are examples of metadata that may be considered globally applicable.</p></div><div class="section"><a name="section_10.2.5.2"></a><div class="heading">10.2.5.2. Metadata types are derived from metadata types</div><div class="box"><a name="rule_10-45"></a><div class="normativeHead">[Rule 10-45] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType"&gt;
    &lt;sch:let name="is-metadata-type" value="exists(@name[ends-with(., 'MetadataType')])"/&gt;
    &lt;sch:let name="has-metadata-base-type" value="
      exists(xs:complexContent[
        exists(xs:*[local-name() = ('extension', 'restriction')
                    and exists(@base[ends-with(., 'MetadataType')])])])"/&gt;
    &lt;sch:assert test="$is-metadata-type = $has-metadata-base-type"
      &gt;A type MUST have a metadata type name if an only if it is derived from a metadata type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Using the qualifier <code>Metadata</code> immediately identifies a type as representing metadata.</p></div></div></div><div class="section"><a name="section_10.3"></a><div class="heading">10.3. Container elements</div><p>All NIEM properties establish a relationship between the object holding the property and the value of the property. For example, an activity object of type <code>nc:ActivityType</code> may have an element <code>nc:ActivityDescriptionText</code>. This element will be of type <code>nc:TextType</code> and represents a NIEM property owned by that activity object. An occurrence of this element within an activity object establishes a relationship between the activity object and the text: the text is the description of the activity.</p><p>In a NIEM-conformant instance, an element establishes a relationship between the object that contains it and the element’s value. This relationship between the object and the element may be semantically strong, such as the text description of an activity in the previous example, or it may be semantically weak, with its exact meaning left unstated. In NIEM, the contained element involved in a weakly defined semantic relationship is commonly referred to as a <strong>container element</strong>.</p><p>A container element establishes a weakly defined relationship with its containing element. For example, an object of type <code>nc:ItemDispositionType</code> may have a container element <code>nc:Item</code> of type <code>nc:ItemType</code>. The container element <code>nc:Item</code> does not establish what relationship exists between the object of <code>nc:ItemDispositionType</code> and itself. There could be any of a number of possible semantics between an object and the value of a container element. It could be a contained object, a subpart, a characteristic, or some other relationship. The appearance of this container element inside the <code>nc:ItemDispositionType</code> merely establishes that the disposition has an item.</p><p>The name of the container element is usually based on the NIEM type that defines it: <code>nc:PersonType</code> uses a container element <code>nc:Person</code>, while <code>nc:ActivityType</code> uses a container element <code>nc:Activity</code>. The concept of an element as a container element is a notional one.</p><p>There are no formalized rules addressing what makes up a container element. A container element is vaguely defined and carries very little semantics about its context and its contents. Accordingly, there is no formal definition of container elements in NIEM: There are no specific artifacts that define a container element; there are no <code>appinfo</code> or other labels for container elements.</p><p>The appearance of a container element within a NIEM type carries no additional semantics about the relationship between the property and the containing type. The use of container elements indicates only that there is a relationship; it does not provide any semantics for interpreting that relationship.</p><p>For example, a NIEM container element <code>nc:Person</code> would be associated with the NIEM type <code>nc:PersonType</code>. The use of the NIEM container element <code>nc:Person</code> in a containing NIEM type indicates that a person has some association with the instances of the containing NIEM type. But because the <code>nc:Person</code> container element is used, there is no additional meaning about the association of the person and the instance containing it. While there is a person associated with the instance, nothing is known about the relationship except its existence.</p><p>The use of the Person container element is in contrast to a NIEM property named <code>nc:AssessmentPerson</code>, also of NIEM type <code>nc:PersonType</code>. When the NIEM property <code>nc:AssessmentPerson</code> is contained within an instance of a NIEM type, it is clear that the person referenced by this property was responsible for an assessment of some type, relevant to the exchange being modeled. The more descriptive name, <code>nc:AssessmentPerson</code>, gives more information about the relationship of the person with the containing instance, as compared with the semantic-free implications associated with the use of the <code>nc:Person</code> container element.</p><p>When a NIEM-conformant schema requires a new container element, it may define a new element with a concrete type and a general name, with general semantics. Any schema may define a container element when it requires one. NIEM-conformant schemas may also create reference elements with general semantics. For example, an element <code>nc:PersonReference</code> will carry the same general, container-like meaning as an element <code>nc:Person</code>.</p></div><div class="section"><a name="section_10.4"></a><div class="heading">10.4. Naming rules</div><p>This section outlines the rules used to create names for NIEM data components previously discussed in this document. Data component names must be understood easily both by humans and by machine processes. These rules improve name consistency by restricting characters, terms, and syntax that could otherwise allow too much variety and potential ambiguity. These rules also improve readability of names for humans, facilitate parsing of individual terms that compose names, and support various automated tasks associated with dictionary and controlled vocabulary maintenance.</p><div class="section"><a name="section_10.4.1"></a><div class="heading">10.4.1. Extension of XSD namespace simple types</div><div class="box"><a name="rule_10-46"></a><div class="normativeHead">[Rule 10-46] (REF, EXT) (Constraint)</div><p>Within the schema, a complex type that is a direct extension of a simple type from the XML Schema namespace simple type MAY use the same local name as the simple type if and only if the extension adds no content other than the attribute group <code>structures:SimpleObjectAttributeGroup</code>.</p></div><p><strong>Rationale</strong></p><p>It is useful to build complex type bases for further extension. The NIEM distribution proxy schema <code>xsd.xsd</code> provides complex type bases for some of the simple types in the XML Schema namespace. However, the complex types in this proxy schema reuse the local names of the simple types they extend, even though the simple type names may not be NIEM-conformant. Requiring name changes for those NIEM-provided complex type bases would work against user understanding, for those already familiar with the names of the XML Schema namespace simple types being extended.</p></div><div class="section"><a name="section_10.4.2"></a><div class="heading">10.4.2. Usage of English</div><div class="box"><a name="rule_10-47"></a><div class="normativeHead">[Rule 10-47] (REF, EXT) (Constraint)</div><p>The name of any XML Schema component defined by the schema SHALL be composed of words from the English language, using the prevalent U.S. spelling, as provided by <a href="#OED" class="ref">[OED]</a>.</p></div><p><strong>Rationale</strong></p><p>The English language has many spelling variations for the same word. For example, American English <q>program</q> has a corresponding British spelling <q>programme.</q> This variation has the potential to cause interoperability problems when XML components are exchanged because of the different names used by the same elements. Providing users with a dictionary standard for spelling will mitigate this potential interoperability issue.</p></div><div class="section"><a name="section_10.4.3"></a><div class="heading">10.4.3. Characters in names</div><div class="box"><a name="rule_10-48"></a><div class="normativeHead">[Rule 10-48] (REF, EXT) (Constraint)</div><p>The name of any XML Schema component defined by the schema SHALL contain only the following characters:</p><ul><li>Upper-case letters (<q><code>A</code></q>–<q><code>Z</code></q>).</li><li>Lower-case letters (<q><code>a</code></q>–<q><code>z</code></q>).</li><li>Digits (<q><code>0</code></q>–<q><code>9</code></q>).</li><li>Hyphen (<q><code>-</code></q>).</li></ul><p>Other characters, such as the underscore (<q><code>_</code></q>) character and the period (<q><code>.</code></q>) character SHALL NOT appear in component names in NIEM-conformant schemas.</p></div><div class="box"><a name="rule_10-49"></a><div class="normativeHead">[Rule 10-49] (REF, EXT) (Constraint)</div><p>The hyphen character (<q><code>-</code></q>) MAY appear in component names only when used as a separator between parts of a single word, phrase, or value, which would otherwise be incomprehensible without the use of a separator.</p></div><p><strong>Rationale</strong></p><p>Names of standards and specifications, in particular, tend to consist of series of discrete numbers. Such names require some explicit separator to keep the values from running together. The separator used within NIEM is the hyphen.</p><p>Names of NIEM components follow the rules of XML Schema, by [Rule 5-3]. NIEM components also must follow the rules specified for each type of XML Schema component.</p></div><div class="section"><a name="section_10.4.4"></a><div class="heading">10.4.4. Character case</div><p>Names of conformant components use the <em>camel case</em> formatting convention, as described by <a href="#WPCamelCase" class="ref">[WP CamelCase]</a>:</p><blockquote><p>CamelCase (camel case) or medial capitals is the practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter. Camel case may start with a capital or, especially in programming languages, with a lowercase letter.</p></blockquote><div class="section"><a name="section_10.4.4.1"></a><div class="heading">10.4.4.1. Names use camel case</div><div class="box"><a name="rule_10-50"></a><div class="normativeHead">[Rule 10-50] (REF, EXT) (Constraint)</div><p>The name of any XML Schema component defined by the schema SHALL use the camel case formatting convention.</p></div></div><div class="box"><a name="rule_10-51"></a><div class="normativeHead">[Rule 10-51] (REF, EXT) (Constraint)</div><p>Within the schema, any attribute declaration SHALL have a name that begins with a lower-case letter (<q><code>a</code></q>–<q><code>z</code></q>).</p></div><div class="box"><a name="rule_10-52"></a><div class="normativeHead">[Rule 10-52] (REF, EXT) (Constraint)</div><p>Within the schema, any XML Schema component other than an attribute declaration SHALL have a name that begins with an upper-case letter (<q><code>A</code></q>–<q><code>Z</code></q>).</p></div><p>The foregoing rules establish <em>lowerCamelCase</em> for all NIEM components that are XML attributes and <em>UpperCamelCase</em> for all NIEM components that are types, elements, or groups.</p></div><div class="section"><a name="section_10.4.5"></a><div class="heading">10.4.5. Use of acronyms and abbreviations</div><p>Acronyms and abbreviations have the ability to improve readability and comprehensibility of large, complex, or frequently used terms. They also obscure meaning and impair understanding when their definitions are not clear or when they are used injudiciously. They should be used with great care. Acronyms and abbreviations that are used must be documented and used consistently.</p><div class="box"><a name="rule_10-53"></a><div class="normativeHead">[Rule 10-53] (REF, EXT) (Constraint)</div><p>The schema MUST consistently use approved acronyms, abbreviations, and word truncations within defined names. The approved shortened forms are defined in <a href="#table_10-1">Table 10-1, <em>Abbreviations used in NIEM core names</em></a>.</p></div><p class="todo">remove this table</p><div class="table"><a name="table_10-1"></a><div class="caption">Table 10-1: Abbreviations used in NIEM core names</div><table><thead><tr><th>Abbreviation</th><th>Full Meaning</th></tr></thead><tbody><tr><td>ANSI</td><td>American National Standards Institute</td></tr><tr><td>CMV</td><td>Commercial Motor Vehicle</td></tr><tr><td>DEA</td><td>Drug Enforcement Agency</td></tr><tr><td>DNA</td><td>Deoxyribonucleic Acid</td></tr><tr><td>FGI</td><td>Foreign Government Information</td></tr><tr><td>FIPS</td><td>Federal Information Processing Standard</td></tr><tr><td>IC</td><td>Intelligence Community</td></tr><tr><td>ID</td><td>Identifier</td></tr><tr><td>IP</td><td>Internet Protocol</td></tr><tr><td>ISO</td><td>International Standards Organization</td></tr><tr><td>LIS</td><td>NCIC code list for license state</td></tr><tr><td>LSTA</td><td>NCIC code list for state/country index</td></tr><tr><td>MCO</td><td>Manufacturer’s Certificate of Origin</td></tr><tr><td>MGRS</td><td>Military Grid Reference System</td></tr><tr><td>MSRP</td><td>Manufacturer’s Suggested Retail Price</td></tr><tr><td>NANP</td><td>North American Numbering Plan</td></tr><tr><td>NCIC</td><td>National Crime Information Center</td></tr><tr><td>NCTC</td><td>National Counter Terrorist Center</td></tr><tr><td>NIBRS</td><td>National Incident Based Reporting System</td></tr><tr><td>NLETS</td><td>The International Justice &amp; Public Safety Information Sharing Network (formerly known as the National Law Enforcement Teletype System)</td></tr><tr><td>ORI</td><td>Organization Identifier (Orion)</td></tr><tr><td>RES</td><td>NCIC code list for registration state for boat registrations</td></tr><tr><td>RF</td><td>Radio Frequency</td></tr><tr><td>SIM</td><td>Subscriber Identity Module</td></tr><tr><td>SSN</td><td>Social security number</td></tr><tr><td>TYP</td><td>NCIC code list for gun type</td></tr><tr><td>TYPO</td><td>NCIC code list for ORI type</td></tr><tr><td>URI</td><td>Uniform Resource Identifier</td></tr><tr><td>US</td><td>United States</td></tr><tr><td>UTM</td><td>Universal Transverse Mercator</td></tr><tr><td>VIN</td><td>Vehicle Identification Number</td></tr><tr><td>VINA</td><td>Vehicle Identification Number Analysis</td></tr></tbody></table></div><p><strong>Rationale</strong></p><p>Consistent, controlled, and documented abridged terms that are used frequently and/or tend to be lengthy can support readability, clarity, and reduction of name length.</p></div><div class="section"><a name="section_10.4.6"></a><div class="heading">10.4.6. Word forms</div><div class="box"><a name="rule_10-54"></a><div class="normativeHead">[Rule 10-54] (REF, EXT) (Constraint)</div><p>A noun used as a term in the name of an XML Schema component MUST be in singular form unless the concept itself is plural.</p></div><div class="box"><a name="rule_10-55"></a><div class="normativeHead">[Rule 10-55] (REF, EXT) (Constraint)</div><p>A verb used as a term in the name of an XML Schema component MUST be used in the present tense unless the concept itself is past tense.</p></div><div class="box"><a name="rule_10-56"></a><div class="normativeHead">[Rule 10-56] (REF, EXT) (Constraint)</div><p>Articles, conjunctions, and prepositions SHALL NOT be used in NIEM component names except where they are required for clarity or by standard convention.</p></div><p><strong>Rationale</strong></p><p>Articles (e.g., a, an, the), conjunctions (e.g., and, or, but), and prepositions (e.g., at, by, for, from, in, of, to) are all disallowed in NIEM component names, unless they are required. For example, <code>PowerOfAttorneyCode</code> requires the preposition. These rules constrain slight variations in word forms and types to improve consistency and reduce potentially ambiguous or confusing component names.</p></div><div class="section"><a name="section_10.4.7"></a><div class="heading">10.4.7. Name generation</div><p>Elements in NIEM-conformant schemas are given names that follow a specific pattern. This pattern comes from <a href="#ISO11179-5" class="ref">[ISO 11179-5]</a>.</p><div class="box"><a name="rule_10-57"></a><div class="normativeHead">[Rule 10-57] (REF, EXT) (Constraint)</div><p>Except as specified elsewhere in this document, any element or attribute defined within the schema SHALL have a name that takes the form:</p><ul><li>Object-class qualifier terms (0 or more).</li><li>An object class term (1).</li><li>Property qualifier terms (0 or more).</li><li>A property term (1).</li><li>Representation qualifier terms (0 or more).</li><li>A representation term (1).</li></ul></div><p><strong>Rationale</strong></p><p>Consistent naming rules are helpful for users who wish to understand components with which they are unfamiliar, as well as for users to find components with known semantics. This rule establishes the basic structure for an element or attribute name, in line with the rules for names under <a href="#ISO11179-5" class="ref">[ISO 11179-5]</a>. Note that many elements with complex type should not have a representation term.</p></div><div class="section"><a name="section_10.4.8"></a><div class="heading">10.4.8. Object-class term</div><p>The NIEM adopts an object-oriented approach to representation of data. Object classes represent what <a href="#ISO11179-5" class="ref">[ISO 11179-5]</a> refers to as <q>things of interest in a universe of discourse that may be found in a model of that universe.</q> An object class or object term is a word that represents a class of real-world entities or concepts. An object-class term describes the applicable context for a NIEM component.</p><div class="box"><a name="rule_10-58"></a><div class="normativeHead">[Rule 10-58] (REF, EXT) (Constraint)</div><p>The object-class term of a NIEM component SHALL consist of a term identifying a category of concrete concepts or entities.</p></div><p><strong>Rationale</strong></p><p>The object-class term indicates the object category that this data component describes or represents. This term provides valuable context and narrows the scope of the component to an actual class of things or concepts.</p><p><strong>Example</strong></p><p>Concept term: Activity</p><p>Entity term: Vehicle</p></div><div class="section"><a name="section_10.4.9"></a><div class="heading">10.4.9. Property term</div><p>Objects or concepts are usually described in terms of their characteristic properties, data attributes, or constituent subparts. Most objects can be described by several characteristics. Therefore, a property term in the name of a data component represents a characteristic or subpartof an object class and generally describes the essence of that data component.</p><div class="box"><a name="rule_10-59"></a><div class="normativeHead">[Rule 10-59] (REF, EXT) (Constraint)</div><p>A property term SHALL describe or represent a characteristic or subpart of an entity or concept.</p></div><p><strong>Rationale</strong></p><p>The property term describes the central meaning of the data component.</p></div><div class="section"><a name="section_10.4.10"></a><div class="heading">10.4.10. Qualifier terms</div><p>Qualifier terms modify object, property, representation, or other qualifier terms to increase semantic precision and reduce ambiguity. Qualifier terms may precede or succeed the terms they modify. The goal for the placement of qualifier terms is to generally follow the rules of ordinary English while maintaining clarity.</p><div class="box"><a name="rule_10-60"></a><div class="normativeHead">[Rule 10-60] (REF, EXT) (Constraint)</div><p>Multiple qualifier terms MAY be used within a component name as necessary to ensure clarity and uniqueness within its namespace and usage context.</p></div><div class="box"><a name="rule_10-61"></a><div class="normativeHead">[Rule 10-61] (REF, EXT) (Constraint)</div><p>The number of qualifier terms SHOULD be limited to the absolute minimum required to make the component name unique and understandable.</p></div><div class="box"><a name="rule_10-62"></a><div class="normativeHead">[Rule 10-62] (REF, EXT) (Constraint)</div><p>The order of qualifiers SHALL NOT be used to differentiate names.</p></div><p><strong>Rationale</strong></p><p>Very large vocabularies may have many similar and closely related properties and concepts. The use of object, property, and representation terms alone is often not sufficient to construct meaningful names that can uniquely distinguish such components. Qualifier terms provide additional context to resolve these subtleties. However, swapping the order of qualifiers rarely (if ever) changes meaning; qualifier ordering is no substitute for meaningful terms.</p></div><div class="section"><a name="section_10.4.11"></a><div class="heading">10.4.11. Representation terms</div><p>The representation terms for a component name serve several purposes in NIEM:</p><ol><li>It can indicate the style of component. For example, types are clearly labeled with the representation term <code>Type</code>.</li><li>It helps prevent name conflicts and confusion. For example, elements and types may not be given the same name.</li><li>It indicates the nature of the value carried by element. Labeling elements and attributes with a notional indicator of the content eases discovery and comprehension.</li></ol><div class="box"><a name="rule_10-63"></a><div class="normativeHead">[Rule 10-63] (REF, EXT) (Constraint)</div><p>If any word in the representation term is redundant with any word in the property term, one occurrence SHOULD be deleted.</p></div><p><strong>Rationale</strong></p><p>This rule, carried over from 11179, is designed to prevent repeating terms unnecessarily within component names. For example, this rule allows designers to avoid naming an element <q>PersonFirstNameName.</q></p><p>The valid value set of a data element or value domain is described by the representation term. NIEM uses a standard set of representation terms in the representation portion of a NIEM-conformant component name. <a href="#table_11-1">Table 11-1, <em>Representation terms</em>, below,</a> lists the primary representation terms and a definition for the concept associated with the use of that term. The table also lists secondary representation terms that may represent more specific uses of the concept associated with the primary representation term.</p><div class="box"><a name="rule_10-64"></a><div class="normativeHead">[Rule 10-64] (REF, EXT) (Constraint)</div><p>Within the schema, the name of an element declaration that is of simple content MUST use a representation term found in <a href="#table_11-1">Table 11-1, <em>Representation terms</em></a>.</p></div><div class="box"><a name="rule_10-65"></a><div class="normativeHead">[Rule 10-65] (REF, EXT) (Constraint)</div><p>Within the schema, the name of an element declaration that is of complex content, and that corresponds to a concept listed in <a href="#table_11-1">Table 11-1, <em>Representation terms</em></a>, MUST use a representation term from that table.</p></div><div class="box"><a name="rule_10-66"></a><div class="normativeHead">[Rule 10-66] (REF, EXT) (Constraint)</div><p>Within the schema, the name of an element declaration that is of complex content and that does not correspond to a concept listed in <a href="#table_11-1">Table 11-1, <em>Representation terms</em></a> MUST NOT use a representation term.</p></div><p><strong>Rationale</strong></p><p>An element that represents a value listed in the table should have a representation term. It should do so even if its type is complex with multiple parts. For example, a type with multiple fields may represent a sound binary, a date, or a name.</p></div></div><div class="section"><a name="section_10.5"></a><div class="heading">10.5. Machine-readable annotations</div><p>XML Schema provides <em>application information</em> schema components to provide for automatic processing and machine-readable content for schemas. NIEM utilizes application information to convey information that is outside schema definition and outside human-readable text definitions. NIEM uses application information to convey high-level data model concepts and additional syntax to support the NIEM conceptual model and validation of NIEM-conformant XML instances.</p><p>XML elements, attributes, and text content may appear as machine-readable annotations within an XML Schema document. The methods provided by XML Schema for machine-readable annotations are:</p><ol><li>An element in the XML Schema namespace (e.g., <code>xs:schema</code>, <code>xs:complexType</code>, …) may carry attributes from namespaces other than the XML Schema namespace. By the rules of XML Schema, any XML Schema element may have attributes that are from other namespaces. These attributes do not participate in XML Schema validation, but may carry information useful to tools that process schemas. In <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a>, these attributes are described in the XML Representation summary of XML Schema elements as <q>{any attributes with non-schema namespace . . .}</q>, for example in <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#element-attribute">§3.2.2, <em>XML Representation of Attribute Declaration Schema Components</em></a>.</li><li>XML Schemas may include <code>xs:appinfo</code> elements, which may include arbitrary XML content. This XML does not participate in XML Schema validation, but may communicate useful information to schema readers or processors. These are described by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> in <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#application_information">§3.13.1, <em>The Annotation Schema Component</em></a> and <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#element-appinfo">§3.13.2, <em>XML Representation of Annotation Schema Components</em></a>.</li></ol><p>NIEM defines the term <q>machine-readable annotation</q> to normatively refer to such annotations within XML Schema documents:</p><div class="box"><a name="definition_machine-readable_annotation"></a><div class="normativeHead">[Definition: <dfn>machine-readable annotation</dfn>]</div><div class="sub"><p>An information item within a schema is defined to be a machine-readable annotation when all of the following are true:</p><ol><li><p>It is one of the following:</p><ol><li>It is an element information item that is a child of an xsd:appinfo element.</li><li>It is an attribute information item that satisfies the <q>{any attributes with non- schema namespace . . .}</q> clause within the declaration of an XML Schema element.</li></ol></li><li>The namespace name property of the item is not the XML namespace, XML Schema namespace, or the XSI namespace.</li></ol></div></div><p>Attributes from the XML namespace, the XML Schema namespace, and the XML Schema instance namespace have special meanings within XML Schema, and may have effects on validation, and so are not considered machine-readable annotations.</p><div class="box"><a name="definition_application_information"></a><div class="normativeHead">[Definition: <dfn>application information</dfn>]</div><div class="sub"><p><span class="issue"><a href="http://niem.gtri.gatech.edu/ncct/show_bug.cgi?id=703" target="_blank" title="http://niem.gtri.gatech.edu/ncct/show_bug.cgi?id=703">[bug]</a><a name="d3e9101" href="#d3e9101" title="A component is said to&#xA;              have application information">A component is said to have <strong>application information</strong></a></span> of some element <var>$element</var> when the XML Schema element that defines the component has an immediate child element <code>xs:annotation</code>, which has an immediate child element <code>xs:appinfo</code>, which has as an immediate child the element <var>$element</var>.</p></div></div><p>If a component is described as having some <span class="termRef"><a name="d3e9122" href="#definition_application_information">[application information]</a></span>, this means that the elements in question appear in an <code>xs:appinfo</code> annotation of the element that defines the component.</p><p>The majority of uses of application information from the <span class="termRef"><a name="d3e9131" href="#definition_appinfo_namespace">[appinfo namespace]</a></span> are described in the modeling rules for the specific component.</p><div class="section"><a name="section_10.5.1"></a><div class="heading">10.5.1. Machine-readable annotations are valid</div><div class="box"><a name="rule_10-67"></a><div class="normativeHead">[Rule 10-67] (REF, EXT) (Constraint)</div><p>Every element information item or attribute information item that appears as a machine-readable annotation in a schema MUST be a valid instance, according to its specification.</p></div><p>The specification for an element or attribute may be via an XML Schema, a Schematron schema, via a DTD, by some other specification, or by other means. This rule is intended to allow NIEM schema developers to leverage relevant vocabularies without being limited by the vocabulary’s method of specification, while ensuring that developers do not subvert or misuse those vocabularies.</p></div><div class="section"><a name="section_10.5.2"></a><div class="heading">10.5.2. The NIEM appinfo namespace</div><p>NIEM defines a single namespace that holds components for use in NIEM-conformant schema application information. This namespace is referred to as the <span class="termRef"><a name="d3e9157" href="#definition_appinfo_namespace">[appinfo namespace]</a></span>.</p><div class="box"><a name="definition_appinfo_namespace"></a><div class="normativeHead">[Definition: <dfn>appinfo namespace</dfn>]</div><div class="sub"><p>The <strong>appinfo namespace</strong> is the namespace represented by the URI <q><code>http://release.niem.gov/niem/appinfo/3.0/</code></q>.</p></div></div><p>The <span class="termRef"><a name="d3e9176" href="#definition_appinfo_namespace">[appinfo namespace]</a></span> defines attributes which provide additional semantics for components built by NIEM-conformant schemas. The XML Schema document for the appinfo namespace appears in <a href="#appendix_C">Appendix C, <em>Appinfo namespace</em>, below</a>.</p><div class="section"><a name="section_10.5.2.1"></a><div class="heading">10.5.2.1. Deprecation</div><p>The <code>appinfo</code> schema provides a construct for indicating that a construct is deprecated. A deprecated component is one whose use is not recommended. A deprecated component may be kept in a schema for support of older versions but should not be used in new efforts. A deprecated component may be removed, replaced, or renamed in a later version of a namespace.</p><div class="box"><a name="definition_deprecated_component"></a><div class="normativeHead">[Definition: <dfn>deprecated component</dfn>]</div><div class="sub"><p>A <strong>deprecated component</strong> is one whose use is not recommended, yet which is maintained in the schema for compatibility with previous versions of the namespace.</p></div></div><div class="section"><a name="section_10.5.2.1.1"></a><div class="heading">10.5.2.1.1. A component marked as deprecated is a deprecated component</div><div class="box"><a name="rule_10-68"></a><div class="normativeHead">[Rule 10-68] (REF, EXT) (Interpretation)</div><p>A <span class="termRef"><a name="d3e9210" href="#definition_schema_component">[schema component]</a></span> that has an attribute <code>appinfo:deprecated</code> with a value of <q>true</q> SHALL be a <span class="termRef"><a name="d3e9219" href="#definition_deprecated_component">[deprecated component]</a></span>.</p></div><p>Deprecation can allow version management to be more consistent; versions of schema may be incrementally improved without introducing validation problems and incompatibility. As XML Schema lacks a deprecation mechanism, NIEM defines such a mechanism.</p></div><div class="section"><a name="section_10.5.2.1.2"></a><div class="heading">10.5.2.1.2. Deprecated annotates schema component</div><div class="box"><a name="rule_10-69"></a><div class="normativeHead">[Rule 10-69] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@appinfo:deprecated)]"&gt;
    &lt;sch:assert test="namespace-uri-from-QName(node-name(.)) = xs:anyURI('http://www.w3.org/2001/XMLSchema')"
            &gt;The attribute appinfo:deprecated MUST be owned by an element with a namespace name &lt;namespace-uri-for-prefix&gt;xs&lt;/namespace-uri-for-prefix&gt;.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_10.5.2.2"></a><div class="heading">10.5.2.2. External import indicator annotates import</div><div class="box"><a name="rule_10-70"></a><div class="normativeHead">[Rule 10-70] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@appinfo:externalImportIndicator)]"&gt;
    &lt;sch:assert test="exists(self::xs:import)"
        &gt;The attribute {http://release.niem.gov/niem/appinfo/3.0/}externalImportIndicator MUST be owned by an element xs:import.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.5.2.3"></a><div class="heading">10.5.2.3. External adapter type indicator annotates complex type</div><div class="box"><a name="rule_10-71"></a><div class="normativeHead">[Rule 10-71] (REF) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@appinfo:externalAdapterTypeIndicator)]"&gt;
    &lt;sch:assert test="exists(self::xs:complexType)"
            &gt;The attribute appinfo:externalAdapterTypeIndicator MUST be owned by an element xs:complexType.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.5.2.4"></a><div class="heading">10.5.2.4. Applies to types annotation</div><div class="section"><a name="section_10.5.2.4.1"></a><div class="heading">10.5.2.4.1. Applies to types annotates metadata element</div><div class="box"><a name="rule_10-72"></a><div class="normativeHead">[Rule 10-72] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@appinfo:appliesToTypes)]"&gt;
    &lt;sch:assert test="exists(self::xs:element[exists(@name)
                               and ends-with(@name, 'Metadata')])"
      &gt;The attribute appinfo:appliesToTypes MUST be owned by a metadata element.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.5.2.4.2"></a><div class="heading">10.5.2.4.2. Applies to types indicates elements</div><div class="box"><a name="rule_10-73"></a><div class="normativeHead">[Rule 10-73] (SET) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@appinfo:appliesToTypes)]"&gt;
    &lt;sch:assert test="every $item in tokenize(normalize-space(@appinfo:appliesToTypes), ' ') satisfies
                        exists(nf:resolve-type(., resolve-QName($item, .)))"
      &gt;Every item in @appinfo:appliesToTypes MUST resolve to a type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_10.5.2.5"></a><div class="heading">10.5.2.5. Applies to elements annotation</div><div class="section"><a name="section_10.5.2.5.1"></a><div class="heading">10.5.2.5.1. Applies to elements annotates metadata element</div><div class="box"><a name="rule_10-74"></a><div class="normativeHead">[Rule 10-74] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@appinfo:appliesToElements)]"&gt;
    &lt;sch:assert test="exists(self::xs:element[
                          exists(@name)
                          and ends-with(@name, 'Metadata')])"
            &gt;The attribute appinfo:appliesToElements MUST be owned by a metadata element.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.5.2.5.2"></a><div class="heading">10.5.2.5.2. Applies to elements indicates elements</div><div class="box"><a name="rule_10-75"></a><div class="normativeHead">[Rule 10-75] (SET) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@appinfo:appliesToElements)]"&gt;
    &lt;sch:assert test="every $item in tokenize(normalize-space(@appinfo:appliesToElements), ' ') satisfies
                        count(nf:resolve-element(., resolve-QName($item, .))) = 1"
      &gt;Every item in @appinfo:appliesToElements must resolve to an element.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_10.5.3"></a><div class="heading">10.5.3. The NIEM local terminology namespace</div><div class="section"><a name="section_10.5.3.1"></a><div class="heading">10.5.3.1. LocalTerm annotates schema</div><div class="box"><a name="rule_10-76"></a><div class="normativeHead">[Rule 10-76] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="term:LocalTerm"&gt;
    &lt;sch:assert test="parent::xs:appinfo[parent::xs:annotation[parent::xs:schema]]"
        &gt;The element {http://release.niem.gov/niem/localTerminology/3.0/}LocalTerm MUST be application information an an element xs:schema.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_10.5.3.2"></a><div class="heading">10.5.3.2. LocalTerm has literal or definition</div><div class="box"><a name="rule_10-77"></a><div class="normativeHead">[Rule 10-77] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="term:LocalTerm"&gt;
    &lt;sch:assert test="exists(@literal) or exists(@definition)"
            &gt;The element {http://release.niem.gov/niem/localTerminology/3.0/}LocalTerm MUST have a literal or definition.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div></div><div class="section"><a name="section_11"></a><div class="heading">11. Rules for NIEM modeling, by XML Schema component</div><p>This section focuses on building NIEM data models using XML schema. Whereas <a href="#section_9">Section 9, <em>Rules for a NIEM profile of XML Schema</em>, above,</a> addressed shrinking the XML Schema definition language to a smaller set of features, this section constructs new NIEM-specific features to address modeling and interoperability problems. This includes naming rules, categories of types, and augmentations.</p><div class="section"><a name="section_11.1"></a><div class="heading">11.1. Type definition components</div><div class="section"><a name="section_11.1.1"></a><div class="heading">11.1.1. Name of type ends in <q>Type</q></div><div class="box"><a name="rule_11-1"></a><div class="normativeHead">[Rule 11-1] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[exists(@name)
                       and exists(xs:simpleContent/xs:extension/@base)
                       and (for $extension in xs:simpleContent/xs:extension,
                                $base-qname in resolve-QName($extension/@base, $extension) return
                              $base-qname = QName('http://www.w3.org/2001/XMLSchema', @name))]"&gt;
    &lt;sch:report test="false()"&gt;The name of a proxy type does not end in "Type".&lt;/sch:report&gt;
  &lt;/sch:rule&gt;
  &lt;sch:rule context="xs:*[(self::xs:simpleType or self::xs:complexType) and exists(@name)]"&gt;
    &lt;sch:assert test="ends-with(@name, 'Type')"
      &gt;A type definition schema component that does not define a proxy type MUST have a name that ends in "Type".&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Use of the representation term <q>Type</q> immediately identifies XML types in a NIEM-conformant schema and prevents naming collisions with corresponding XML elements and attributes. The exception for proxy types ensures that simple NIEM-compatible uses of base XML Schema types are familiar to people with XML Schema experience.</p><p>Note that the first <code>sch:rule</code> and subsequent <code>sch:report</code> serve to provide an exception to the rule for proxy types. It does not establish a constraint on the data.</p></div><div class="section"><a name="section_11.1.2"></a><div class="heading">11.1.2. Name of type is in upper camel case</div><div class="box"><a name="rule_11-2"></a><div class="normativeHead">[Rule 11-2] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:complexType[exists(@name)
                       and exists(xs:simpleContent/xs:extension/@base)
                       and (for $extension in xs:simpleContent/xs:extension,
                                $base-qname in resolve-QName($extension/@base, $extension) return
                              $base-qname = QName('http://www.w3.org/2001/XMLSchema', @name))]"&gt;
    &lt;sch:report test="false()"&gt;The name of a proxy type is not upper camel case.&lt;/sch:report&gt;
  &lt;/sch:rule&gt;
  &lt;sch:rule context="xs:*[(self::xs:simpleType or self::xs:complexType) and exists(@name)]"&gt;
    &lt;sch:assert test="matches(@name, '^([A-Z][A-Za-z0-9\-]*)+$')"
      &gt;A type definition schema component that does not define a proxy type MUST be in upper camel case.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Note that the first <code>sch:rule</code> and q subsequent <code>sch:report</code> serve to provide an exception to the rule for proxy types. It does not establish a constraint on the data.</p></div><div class="section"><a name="section_11.1.3"></a><div class="heading">11.1.3. Type definition hierarchy</div><div class="section"><a name="section_11.1.3.1"></a><div class="heading">11.1.3.1. Base type definition defined by conformant schema</div><div class="box"><a name="rule_11-3"></a><div class="normativeHead">[Rule 11-3] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:*[exists(@base)]"&gt;
    &lt;sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@base, .))"/&gt;
    &lt;sch:assert test="$namespace = (nf:get-target-namespace(.), xs:anyURI('http://www.w3.org/2001/XMLSchema'))
                      or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                    and $namespace = xs:anyURI(@namespace)
                                    and empty(@appinfo:externalImportIndicator)])"
      &gt;The [base type definition] of a [type definition] MUST have the target namespace or the XML Schema namespace or a namespace that is imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_11.1.4"></a><div class="heading">11.1.4. Simple type definition</div><div class="section"><a name="section_11.1.4.1"></a><div class="heading">11.1.4.1. Name of simple type ends in <q>SimpleType</q></div><div class="box"><a name="rule_11-4"></a><div class="normativeHead">[Rule 11-4] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleType[@name]"&gt;
    &lt;sch:assert test="ends-with(@name, 'SimpleType')"
      &gt;A simple type definition schema component MUST have a name that ends in "SimpleType".&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Specific uses of type definitions have similar syntax but very different effects on data definitions. Schemas that clearly identify complex and simple type definitions are easier to understand without tool support. This rule ensures that names of simple types end in <code>SimpleType</code>.</p></div><div class="section"><a name="section_11.1.4.2"></a><div class="heading">11.1.4.2. Name of simple type is upper camel case</div><div class="box"><a name="rule_11-5"></a><div class="normativeHead">[Rule 11-5] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleType[exists(@name)]"&gt;
    &lt;sch:assert test="matches(string(@name), '^([A-Z][A-Za-z0-9\-]*)+$')"
      &gt;The name of a simple type definition schema component MUST be upper camel case.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.1.4.3"></a><div class="heading">11.1.4.3. Derivation by list</div><div class="section"><a name="section_11.1.4.3.1"></a><div class="heading">11.1.4.3.1. Use lists only when data is uniform</div><div class="box"><a name="rule_11-6"></a><div class="normativeHead">[Rule 11-6] (REF, EXT) (Constraint)</div><p>Within the schema, a simple type definition that uses <code>xs:list</code> SHOULD NOT be defined if any member of the list requires a property or metadata that is different than other members of the list. All members of the list SHOULD have the same metadata, and should be related via the same properties.</p></div><p>The use of lists should be reserved for cases where the data is fairly uniform.</p><p>Items in a list are not individually addressable by NIEM metadata techniques. The items are also not individually referencable by elements or attributes; one will have a value of the entire list, including all the items in the list. NIEM provides no method for individually addressing an item in a list. If an individual item in a list needs to be marked up in a manner different than other items in the list, the use of individual elements may be preferred to the definition of a list simple type.</p></div><div class="section"><a name="section_11.1.4.3.2"></a><div class="heading">11.1.4.3.2. List item type defined by conformant schemas</div><div class="box"><a name="rule_11-7"></a><div class="normativeHead">[Rule 11-7] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:list[exists(@itemType)]"&gt;
    &lt;sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@itemType, .))"/&gt;
    &lt;sch:assert test="$namespace = (nf:get-target-namespace(.), xs:anyURI('http://www.w3.org/2001/XMLSchema'))
                      or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                    and $namespace = xs:anyURI(@namespace)
                                    and empty(@appinfo:externalImportIndicator)])"
      &gt;The item type of a list simple type definition MUST have a target namespace equal to the target namespace of the XML Schema document within which it is defined, or a namespace that is imported as conformant by the schema document within which it is defined.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_11.1.4.4"></a><div class="heading">11.1.4.4. Derivation by union</div><div class="section"><a name="section_11.1.4.4.1"></a><div class="heading">11.1.4.4.1. Union member types defined by conformant schemas</div><div class="box"><a name="rule_11-8"></a><div class="normativeHead">[Rule 11-8] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:union[exists(@memberTypes)]"&gt;
    &lt;sch:assert test="every $qname in tokenize(normalize-space(@memberTypes), ' '),
                            $namespace in namespace-uri-from-QName(resolve-QName($qname, .))
                      satisfies ($namespace = nf:get-target-namespace(.)
                                 or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                           and $namespace = xs:anyURI(@namespace)
                                           and empty(@appinfo:externalImportIndicator)]))"
                &gt;Every member type of a union simple type definition MUST have a target namespace that is equal to either the target namespace of the XML Schema document within which it is defined or a namespace that is imported as conformant by the schema document within which it is defined.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_11.1.4.5"></a><div class="heading">11.1.4.5. Code simple types</div><div class="box"><a name="definition_code_simple_type"></a><div class="normativeHead">[Definition: <dfn>code simple type</dfn>]</div><div class="sub"><p>A <strong>code simple type</strong> is a simple type definition schema component that is constrained by one or more enumeration facets.</p></div></div><p>These types represent lists of values, each of which has a known meaning beyond the text representation. These values may be meaningful text or may be a string of alphanumeric identifiers that represent abbreviations for literals.</p><div class="section"><a name="section_11.1.4.5.1"></a><div class="heading">11.1.4.5.1. Name of a code simple type has standard suffix</div><div class="box"><a name="rule_11-9"></a><div class="normativeHead">[Rule 11-9] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleType[exists(@name)
      and (xs:restriction/xs:enumeration
           or xs:restriction[ends-with(local-name-from-QName(resolve-QName(@base, .)), 'CodeSimpleType')])]"&gt;
    &lt;sch:assert test="ends-with(@name, 'CodeSimpleType')"
      &gt;A simple type definition schema component that has an enumeration facet or that is derived from a code type MUST have a name that ends in "CodeSimpleType".&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.1.4.5.2"></a><div class="heading">11.1.4.5.2. Code simple type has enumerations</div><div class="box"><a name="rule_11-10"></a><div class="normativeHead">[Rule 11-10] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:simpleType[exists(@name) and ends-with(@name, 'CodeSimpleType')]"&gt;
    &lt;sch:assert test="xs:restriction[ends-with(local-name-from-QName(resolve-QName(@base, .)), 'CodeSimpleType')]
                      or xs:restriction/xs:enumeration
                      or (for $union in xs:union,
                             $member-types in $union/@memberTypes return
                           some $member-type in tokenize(normalize-space($member-types), ' ') satisfies
                             ends-with(local-name-from-QName(resolve-QName($member-type, $union)), 'CodeSimpleType'))"
      &gt;A code simple type MUST be derived from a code simple type or have an enumeration facet.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><p>Using the qualifier <code>Code</code> (e.g. <code>CodeType</code>, <code>CodeSimpleType</code>) immediately identifies a type as representing a fixed list of codes. These types may be handled in specific ways, as lists of codes are expected to have their own lifecycles, including versions and periodic updates. Codes may also have responsible authorities behind them who provide concrete semantic bindings for the code values.</p></div></div></div><div class="section"><a name="section_11.2"></a><div class="heading">11.2. Declaration components</div><div class="section"><a name="section_11.2.1"></a><div class="heading">11.2.1. Element declaration</div><div class="section"><a name="section_11.2.1.1"></a><div class="heading">11.2.1.1. Element name is upper camel case</div><div class="box"><a name="rule_11-11"></a><div class="normativeHead">[Rule 11-11] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name)]"&gt;
    &lt;sch:assert test="matches(string(@name), '^([A-Z][A-Za-z0-9\-]*)+$')"
                &gt;The name of an element declaration schema component MUST be upper camel case.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.2.1.2"></a><div class="heading">11.2.1.2. Element type does not have a simple type name</div><div class="box"><a name="rule_11-12"></a><div class="normativeHead">[Rule 11-12] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@type)]"&gt;
    &lt;sch:assert test="not(ends-with(@type, 'SimpleType'))"
                &gt;The {type definition} of an [element declaration] MUST NOT have a {name} that ends in 'SimpleType'.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.2.1.3"></a><div class="heading">11.2.1.3. Element type is from conformant namespace</div><div class="box"><a name="rule_11-13"></a><div class="normativeHead">[Rule 11-13] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@type)]"&gt;
    &lt;sch:assert test="for $type-qname in resolve-QName(@type, .),
                          $type-namespace in namespace-uri-from-QName($type-qname) return
                        $type-namespace = nf:get-target-namespace(.)
                        or exists(nf:get-document-element(.)/xs:import[
                                    xs:anyURI(@namespace) = $type-namespace
                                    and empty(@appinfo:externalImportIndicator)])"
                &gt;The {type definition} of an {element declaration} MUST have a {target namespace} that is the target namesapce, or one that is imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Additional prohibitions on element types are defined by <a href="#rule_9-36"><strong>[Rule 9-36]</strong>, above,</a> and <a href="#rule_9-37"><strong>[Rule 9-37]</strong>, above</a>.</p></div><div class="section"><a name="section_11.2.1.4"></a><div class="heading">11.2.1.4. Name of element that ends in <q>Abstract</q> must be abstract</div><div class="box"><a name="rule_11-14"></a><div class="normativeHead">[Rule 11-14] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[@name[ends-with(., 'Abstract')]]"&gt;
    &lt;sch:assert test="exists(@abstract) and xs:boolean(@abstract) = true()"
      &gt;An element with a name that ends in 'Abstract' MUST be abstract.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.2.1.5"></a><div class="heading">11.2.1.5. Name of element that ends in <q>Representation</q> must be abstract</div><div class="box"><a name="rule_11-15"></a><div class="normativeHead">[Rule 11-15] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[@name[ends-with(., 'Representation')]]"&gt;
    &lt;sch:assert test="exists(@abstract) and xs:boolean(@abstract) = true()"
      &gt;An element with a name that ends in 'Representation' MUST be abstract.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.2.1.6"></a><div class="heading">11.2.1.6. Object element declarations</div><div class="table"><a name="table_11-1"></a><div class="caption">Table 11-1: Representation terms</div><table><thead><tr><th>Primary Representation Term</th><th>Secondary Representation Term</th><th>Definition</th></tr></thead><tbody><tr><td>Amount</td><td>-</td><td>A number of monetary units specified in a currency where the unit of currency is explicit or implied.</td></tr><tr><td>BinaryObject</td><td>-</td><td>A set of finite-length sequences of binary octets.</td></tr><tr><td></td><td>Graphic</td><td>A diagram, graph, mathematical curves, or similar representation</td></tr><tr><td></td><td>Picture</td><td>A visual representation of a person, object, or scene</td></tr><tr><td></td><td>Sound</td><td>A representation for audio</td></tr><tr><td></td><td>Video</td><td>A motion picture representation; may include audio encoded within</td></tr><tr><td>Code</td><td></td><td>A character string (i.e.,letters, figures,and symbols) that for brevity, language independence, or precision represents a definitive value of an attribute.</td></tr><tr><td>DateTime</td><td></td><td>A particular point in the progression of time together with relevant supplementary information.</td></tr><tr><td></td><td>Date</td><td>A particular day, month, and year in the Gregorian calendar.</td></tr><tr><td></td><td>Time</td><td>A particular point in the progression of time within an unspecified 24-hour day.</td></tr><tr><td></td><td>Duration</td><td>An amount of time; the length of a time span.</td></tr><tr><td>ID</td><td></td><td>A character string to identify and distinguish uniquely one instance of an object in an identification scheme from all other objects in the same scheme together with relevant supplementary information.</td></tr><tr><td></td><td>URI</td><td>A string of characters used to identify (or name) a resource. The main purpose of this identifier is to enable interaction with representations of the resource over a network, typically the World Wide Web, using specific protocols. A URI is either a Uniform Resource Locator (URL) or a Uniform Resource Name (URN). The specific syntax for each is defined by <a href="#RFC3986" class="ref">[RFC 3986]</a>.</td></tr><tr><td>Indicator</td><td></td><td>A list of two mutually exclusive Boolean values that express the only possible states of a property.</td></tr><tr><td>Measure</td><td></td><td>A numeric value determined by measuring an object along with the specified unit of measure.</td></tr><tr><td>Numeric</td><td></td><td>Numeric information that is assigned or is determined by calculation, counting, or sequencing. It does not require a unit of quantity or unit of measure.</td></tr><tr><td></td><td>Value</td><td>A result of a calculation.</td></tr><tr><td></td><td>Rate</td><td>A representation of a ratio where the two units are not included.</td></tr><tr><td></td><td>Percent</td><td>A representation of a ratio in which the two units are the same.</td></tr><tr><td>Quantity</td><td></td><td>A counted number of nonmonetary units possibly including fractions.</td></tr><tr><td>Text</td><td>-</td><td>A character string (i.e., a finite sequence of characters) generally in the form of words of a language.</td></tr><tr><td></td><td>Name</td><td>A word or phrase that constitutes the distinctive designation of a person, place, thing, or concept.</td></tr><tr><td></td><td>List</td><td>A sequence of values. This representation term is used in tandem with another of the listed representation terms.</td></tr></tbody></table></div><div class="section"><a name="section_11.2.1.6.1"></a><div class="heading">11.2.1.6.1. Elements with simple content use representation term</div><div class="box"><a name="rule_11-16"></a><div class="normativeHead">[Rule 11-16] (REF, EXT, SET) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[
      (nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))
       or nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument')))
      and exists(@name) 
      and exists(@type)]"&gt;
    &lt;sch:let name="has-simple-content" value="
      some $type in nf:resolve-type(., resolve-QName(@type, .)) satisfies
        exists($type[exists(xs:simpleContent)])"/&gt;
    &lt;sch:let name="name-uses-representation-term" value="
      some $representation-term in ('Amount', 'BinaryObject', 'Graphic', 'Picture', 'Sound', 'Video', 'Code', 'DateTime', 'Date', 'Time', 'Duration', 'ID', 'URI', 'Indicator', 'Measure', 'Numeric', 'Value', 'Rate', 'Percent', 'Quantity', 'Text', 'Name', 'List') satisfies
        ends-with(@name, $representation-term)"/&gt;
    &lt;sch:assert test="if ($has-simple-content) then $name-uses-representation-term else true()"
      &gt;the name of an element declaration that is of simple content MUST use a representation term.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Representation terms are defined by <a href="#table_11-1">Table 11-1, <em>Representation terms</em>, above</a></p></div></div><div class="section"><a name="section_11.2.1.7"></a><div class="heading">11.2.1.7. Metadata element declarations</div><div class="box"><a name="definition_metadata_element"></a><div class="normativeHead">[Definition: <dfn>metadata element</dfn>]</div><div class="sub"><p>Within a NIEM-conformant schema, a <em>metadata element</em> is an element with a type that is a metadata type.</p></div></div><p> There are limitations on the meaning of a metadata element in an instance; it does not establish existence of an object, nor is it a property of its containing object.</p><div class="section"><a name="section_11.2.1.7.1"></a><div class="heading">11.2.1.7.1. Metadata element is an element of a metadata type</div><div class="box"><a name="rule_11-17"></a><div class="normativeHead">[Rule 11-17] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@name)]"&gt;
    &lt;sch:assert test="exists(@type[ends-with(., 'MetadataType')])
                      = exists(@name[ends-with(., 'Metadata')])"
      &gt;An element MUST have a name that ends in 'Metadata' if and only if it has a type that is a metadata type.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Using the qualifier <code>Metadata</code> immediately identifies an element as representing metadata.</p></div></div></div><div class="section"><a name="section_11.2.2"></a><div class="heading">11.2.2. Element substitution group</div><div class="section"><a name="section_11.2.2.1"></a><div class="heading">11.2.2.1. Element substitution group defined by conformant schemas</div><div class="box"><a name="rule_11-18"></a><div class="normativeHead">[Rule 11-18] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@substitutionGroup)]"&gt;
    &lt;sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@substitutionGroup, .))"/&gt;
    &lt;sch:assert test="$namespace = nf:get-target-namespace(.)
                      or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                    and $namespace = xs:anyURI(@namespace)
                                    and empty(@appinfo:externalImportIndicator)])"
      &gt;An element substitution group MUST have either the target namespace or a namespace that is imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_11.2.3"></a><div class="heading">11.2.3. Attribute declaration</div><div class="section"><a name="section_11.2.3.1"></a><div class="heading">11.2.3.1. Attribute type defined by conformant schemas</div><div class="box"><a name="rule_11-19"></a><div class="normativeHead">[Rule 11-19] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@type)]"&gt;
    &lt;sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@type, .))"/&gt;
    &lt;sch:assert test="$namespace = (nf:get-target-namespace(.), xs:anyURI('http://www.w3.org/2001/XMLSchema'))
                      or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                    and $namespace = xs:anyURI(@namespace)
                                    and empty(@appinfo:externalImportIndicator)])"
      &gt;The type of an attribute declaration MUST have the target namespace or the XML Schema namespace or a namespace that is imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.2.3.2"></a><div class="heading">11.2.3.2. Attribute name uses representation term</div><div class="box"><a name="rule_11-20"></a><div class="normativeHead">[Rule 11-20] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:attribute[exists(@name)]"&gt;
    &lt;sch:assert test="some $representation-term in ('Amount', 'BinaryObject', 'Graphic', 'Picture', 'Sound', 'Video', 'Code', 'DateTime', 'Date', 'Time', 'Duration', 'ID', 'URI', 'Indicator', 'Measure', 'Numeric', 'Value', 'Rate', 'Percent', 'Quantity', 'Text', 'Name', 'List') satisfies
                        ends-with(@name, $representation-term)"
                &gt;An attribute name MUST end with a representation term.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div><div class="section"><a name="section_11.2.4"></a><div class="heading">11.2.4. Notation declaration</div></div></div><div class="section"><a name="section_11.3"></a><div class="heading">11.3. Model group components</div><div class="section"><a name="section_11.3.1"></a><div class="heading">11.3.1. Model group</div></div><div class="section"><a name="section_11.3.2"></a><div class="heading">11.3.2. Particle</div><div class="section"><a name="section_11.3.2.1"></a><div class="heading">11.3.2.1. Element use</div><div class="section"><a name="section_11.3.2.1.1"></a><div class="heading">11.3.2.1.1. Element introduced only once in a content model</div><div class="box"><a name="rule_11-21"></a><div class="normativeHead">[Rule 11-21] (REF, EXT) (Constraint)</div><p>Within the schema, an element MUST NOT be introduced more than once into the content of a type definition. This applies to content acquired from base type definitions. This applies to elements substitutable through element substitution groups.</p></div><p>This rule ensures that sequences of elements are simple sequences. A type does not define, for example, a sequence of elements A, B, then A again. Definitions should define, instead, what elements may be included, and the cardinality of each element. Schemas must also be careful not to introduce elements that are substitutable for one another, as this can create violations of the unique particle attribution constraint, as described by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#cos-nonambig">§3.8.6, <em>Constraints on Model Group Schema Components</em></a>.</p></div><div class="section"><a name="section_11.3.2.1.2"></a><div class="heading">11.3.2.1.2. Element ref in external type defined by external schemas</div><div class="box"><a name="rule_11-22"></a><div class="normativeHead">[Rule 11-22] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(@ref)
                                and exists(ancestor::xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)])]"&gt;
    &lt;sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@ref, .))"/&gt;
    &lt;sch:assert test="$namespace != nf:get-target-namespace(.)
                      and exists(nf:get-document-element(.)/self::xs:schema/xs:import[
                          exists(@namespace)
                          and $namespace = xs:anyURI(@namespace)
                          and xs:boolean(@appinfo:externalImportIndicator) = true()])"
      &gt;An element reference that appears within an external adapter type MUST have a target namespace that is imported as external.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.3.2.1.3"></a><div class="heading">11.3.2.1.3. Element reference defined by conformant schemas</div><div class="box"><a name="rule_11-23"></a><div class="normativeHead">[Rule 11-23] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:element[exists(ancestor::xs:complexType[empty(@appinfo:externalAdapterTypeIndicator)]) and exists(@ref)]"&gt;
    &lt;sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@ref, .))"/&gt;
    &lt;sch:assert test="$namespace = nf:get-target-namespace(.)
                      or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                    and $namespace = xs:anyURI(@namespace)
                                    and empty(@appinfo:externalImportIndicator)])"
      &gt;An element reference MUST be to a component that has a namespace that is either the target namespace of the [schema document] in which it appears, or which is imported as conformant by that [schema document].&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_11.3.3"></a><div class="heading">11.3.3. Attribute use</div></div><div class="section"><a name="section_11.3.4"></a><div class="heading">11.3.4. Wildcard</div></div></div><div class="section"><a name="section_11.4"></a><div class="heading">11.4. Annotation components</div><p>NIEM-conformant schemas define data models for the purpose of information exchange. A major part of defining data models is the proper definition of the contents of the model. What does a component mean, and what might it contain? How should it be used? NIEM- conformant schemas contain the invariant part of the definitions for the data model. The set of definitions includes:</p><ol><li>A text definition of each component. This describes what the component means. The term used in this specification for such a text definition is <em>data definition</em>.</li><li>The structural definition of each component. This is made up of XML Schema component definitions, along with certain application information (<code>appinfo</code>).</li></ol><p>When possible, meaning is expressed via XML Schema mechanisms: type derivation, element substitution, specific types and structures, as well as names that are trivially parseable. Beyond that, NIEM-specific syntax must be used, as discussed in this section.</p><div class="section"><a name="section_11.4.1"></a><div class="heading">11.4.1. Human-readable documentation</div><p>Note that [Rule 5-4] applies <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> definition rules to documented components.</p><div class="box"><a name="rule_11-24"></a><div class="normativeHead">[Rule 11-24] (REF, EXT) (Constraint)</div><p>Words or synonyms for the words within a data element definition SHALL NOT be reused as terms in the corresponding component name if those words dilute the semantics and understanding of, or impart ambiguity to, the entity or concept that the component represents.</p></div><div class="box"><a name="rule_11-25"></a><div class="normativeHead">[Rule 11-25] (REF, EXT) (Constraint)</div><p>An object class SHALL have one and only one associated semantic meaning (i.e., a single word sense) as described in the definition of the component that represents that object class.</p></div><div class="box"><a name="rule_11-26"></a><div class="normativeHead">[Rule 11-26] (REF, EXT) (Constraint)</div><p>An object class SHALL NOT be redefined within the definitions of the components that represent properties or subparts of that entity or class.</p></div><p><strong>Rationale</strong></p><p>Data definitions should be concise, precise, and unambiguous without embedding additional definitions of data elements that have already been defined once elsewhere (such as object classes). <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> says that definitions should not be nested inside other definitions. Furthermore, a data dictionary is not a language dictionary. It is acceptable to reuse terms (object class, property term, and qualifier terms) from a component name within its corresponding definition to enhance clarity, as long as the requirements and recommendations of <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> are not violated. This further enhances brevity and precision.</p><div class="box"><a name="rule_11-27"></a><div class="normativeHead">[Rule 11-27] (REF, EXT) (Constraint)</div><p>A data definition SHALL NOT contain explicit representational or data typing information such as number characters, type of characters, etc., unless the very nature of the component can be described only by such information.</p></div><p><strong>Rationale</strong></p><p>A component definition is intended to describe semantic meaning only, not representation or structure. How a component with simple content is represented is indicated through the representation term and further refined through constraints.</p><div class="figure"><a name="figure_11-1"></a><div class="caption">Figure 11-1: A definition that describes mathematical representation</div><div class="box"><pre>&lt;xsd:element name="AngularMinuteValue" type="nc:AngularMinuteType" nillable="true"&gt;
  &lt;xsd:annotation&gt;
    &lt;xsd:documentation&gt;
      A value that specifies a minute of a degree. The value comes from a restricted range of 0 (inclusive) to 60 (exclusive).
    &lt;/xsd:documentation&gt;
  &lt;/xsd:annotation&gt;
&lt;/xsd:element&gt;</pre></div></div><p>In Figure 7-1, above, the component definition contains representational information because the component is mathematical and therefore requires such. In Figure 7-2, below, the definition is incorrect and states unnecessary representational information about the data element. <code>nc:PersonSSNIdentification</code> is not a social security number (SSN); it is a complex element (type <code>nc:IdentificationType</code>) that contains a SSN identifier as well as other properties that describe a person’s SSN identifier (such as issue date, issue authority, etc.). The phrase <q>9-digit</q> is incorrect and unnecessary because it applies only to the SSN identifier and should be applied as a length or pattern constraint on the identifier only.</p><div class="figure"><a name="figure_11-2"></a><div class="caption">Figure 11-2: A definition that describes syntactic representation</div><div class="box"><pre>&lt;xsd:element name="PersonSSNIdentification" type="nc:IdentificationType"&gt;
  &lt;xsd:annotation&gt;
    &lt;xsd:documentation&gt;
      A social security number that references a person; a 9-digit numeric identifier assigned to a living person by the United States Social Security Administration.
    &lt;/xsd:documentation&gt;
  &lt;/xsd:annotation&gt;
&lt;/xsd:element&gt;</pre></div></div><div class="box"><a name="rule_11-28"></a><div class="normativeHead">[Rule 11-28] (REF, EXT) (Constraint)</div><p>A component definition SHALL begin with a standard opening phrase that depends on the class of the component per <a href="#table_11-2">Table 11-2, <em>Standard opening phrases</em></a>.</p></div><div class="table"><a name="table_11-2"></a><div class="caption">Table 11-2: Standard opening phrases</div><table><thead><tr><th>Component class</th><th>Definition opening phrase</th></tr></thead><tbody><tr><td>Abstract element</td><td><q>A data concept for a…</q></td></tr><tr><td>Association element</td><td><q>A relationship…</q></td></tr><tr><td>Association type</td><td><q>A data type for a relationship…</q></td></tr><tr><td>Augmentation element</td><td><q>Supplements…</q></td></tr><tr><td>Augmentation type</td><td><q>A data type that supplements…</q></td></tr><tr><td>Metadata element</td><td>Either <q>Metadata about…</q> or <q>Information that further qualifies…</q></td></tr><tr><td>Metadata type</td><td><q>A data type for metadata about…</q> or <q>A data type for information that further qualifies…</q></td></tr><tr><td>Element with a date representation term</td><td><q>A date…</q></td></tr><tr><td>Element with a quantity representation term</td><td><q>A (optional adjective) count/number of…</q></td></tr><tr><td>Element with an image representation term</td><td><q>A(n) (optional adjective) image/picture/photograph of…</q></td></tr><tr><td>Element with an indicator representation term</td><td><q>True if…; false otherwise/if…</q></td></tr><tr><td>Element with an identification representation term</td><td><q>A(n) (optional adjective) identification…</q></td></tr><tr><td>Element with an ID representation term</td><td><q>An identifier…</q></td></tr><tr><td>Element with a status representation term</td><td><q>A(n) (optional adjective) status/state of…</q></td></tr><tr><td>Element with a name representation term</td><td><q>A name of…</q></td></tr><tr><td>Element with a category text representation term</td><td><q>A kind of…</q></td></tr><tr><td>Element with a description text representation term</td><td><q>A description of…</q></td></tr><tr><td>Other element</td><td><q>A(n)…</q></td></tr><tr><td>Other type</td><td><q>A data type for a(n)…</q></td></tr></tbody></table></div><p><strong>Rationale</strong></p><p>A standard opening phrase based on component class helps to ensure consistent definitions that appropriate for the type of component item being defined. These opening phrases also provide a cue that facilitates recognition of the particular kind of component.</p></div><div class="section"><a name="section_11.4.2"></a><div class="heading">11.4.2. Data definition follows 11179-4 requirements</div><div class="box"><a name="rule_11-29"></a><div class="normativeHead">[Rule 11-29] (REF, EXT) (Constraint)</div><p>Each <span class="termRef"><a name="d3e10821" href="#definition_data_definition">[data definition]</a></span> SHALL conform to the requirements for data definitions provided by <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> §5.2, <em>Requirements</em>.</p></div></div><div class="section"><a name="section_11.4.3"></a><div class="heading">11.4.3. Data definition follows 11179-4 recommendations</div><div class="box"><a name="rule_11-30"></a><div class="normativeHead">[Rule 11-30] (REF, EXT) (Constraint)</div><p>Each <span class="termRef"><a name="d3e10844" href="#definition_data_definition">[data definition]</a></span> SHOULD conform to the recommendations for data definitions provided by <a href="#ISO11179-4" class="ref">[ISO 11179-4]</a> §5.3, <em>Recommendations</em>.</p></div></div></div><div class="section"><a name="section_11.5"></a><div class="heading">11.5. Schema as a whole</div><div class="section"><a name="section_11.5.1"></a><div class="heading">11.5.1. <code>xs:schema</code> document element restrictions</div><div class="box"><a name="rule_11-31"></a><div class="normativeHead">[Rule 11-31] (REF, EXT) (Constraint)</div><p>Two XML Schema documents SHALL have the same value for attribute <code>targetNamespace</code> carried by the element <code>xs:schema</code>, if and only if they represent the same set of components.</p></div><div class="box"><a name="rule_11-32"></a><div class="normativeHead">[Rule 11-32] (REF, EXT) (Constraint)</div><p>Two XML Schema documents SHALL have the same value for attribute <code>targetNamespace</code> carried by the element <code>xs:schema</code>, and different values for attribute <code>version</code> carried by the element <code>xs:schema</code> if and only if they are different views of the same set of components.</p></div><p><strong>Rationale</strong></p><p>These rules embody the basic philosophy behind NIEM’s use of namespaced components: A component is uniquely identified by its class (e.g. element, attribute, type), its namespace (a URI), and its local name (an unqualified string). Any two matching component identifiers refer to the same component, even if the versions of the schemas containing each are different.</p></div></div><div class="section"><a name="section_11.6"></a><div class="heading">11.6. Schema assembly</div><div class="section"><a name="section_11.6.1"></a><div class="heading">11.6.1. Reference schemas import reference schemas.</div><div class="box"><a name="rule_11-33"></a><div class="normativeHead">[Rule 11-33] (SET) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:import[
                         nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))
                         and exists(@namespace)
                         and empty(@appinfo:externalImportIndicator)
                         and not(xs:anyURI(@namespace) = (
                                   xs:anyURI('http://release.niem.gov/niem/structures/3.0/'),
                                   xs:anyURI('http://www.w3.org/XML/1998/namespace'),
                                   xs:anyURI('urn:us:gov:ic:ism'),
                                   xs:anyURI('urn:us:gov:ic:ntk')))]"&gt;
    &lt;sch:assert test="every $schema 
                      in nf:resolve-namespace(., @namespace)
                      satisfies nf:has-effective-conformance-target-identifier($schema, xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))"
      &gt;A namespace imported as conformant from a reference schema document MUST identify a reference schema document.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.6.2"></a><div class="heading">11.6.2. Special namespaces are imported as conformant</div><div class="section"><a name="section_11.6.2.1"></a><div class="heading">11.6.2.1. Structures imported as conformant</div><div class="box"><a name="rule_11-34"></a><div class="normativeHead">[Rule 11-34] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:import[exists(@namespace) 
                               and xs:anyURI(@namespace) = xs:anyURI('http://release.niem.gov/niem/structures/3.0/')]"&gt;
    &lt;sch:assert test="empty(@appinfo:externalImportIndicator)"
      &gt;The structures namespace MUST be imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;          </pre></div></div><div class="section"><a name="section_11.6.2.2"></a><div class="heading">11.6.2.2. Schema for XML imported as conformant</div><div class="box"><a name="rule_11-35"></a><div class="normativeHead">[Rule 11-35] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:import[exists(@namespace)
                               and xs:anyURI(@namespace) = xs:anyURI('http://www.w3.org/XML/1998/namespace')]"&gt;
    &lt;sch:assert test="empty(@appinfo:externalImportIndicator)"
      &gt;The namespace for XML MUST be imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;          </pre></div></div><div class="section"><a name="section_11.6.2.3"></a><div class="heading">11.6.2.3. Schema for IC-ISM imported as conformant</div><div class="box"><a name="rule_11-36"></a><div class="normativeHead">[Rule 11-36] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:import[exists(@namespace)
                               and xs:anyURI(@namespace) = xs:anyURI('urn:us:gov:ic:ism')]"&gt;
    &lt;sch:assert test="empty(@appinfo:externalImportIndicator)"
      &gt;The namespace for IC-ISM MUST be imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;          </pre></div></div><div class="section"><a name="section_11.6.2.4"></a><div class="heading">11.6.2.4. Schema for IC-NTK imported as conformant</div><div class="box"><a name="rule_11-37"></a><div class="normativeHead">[Rule 11-37] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:import[exists(@namespace)
                               and xs:anyURI(@namespace) = xs:anyURI('urn:us:gov:ic:ntk')]"&gt;
    &lt;sch:assert test="empty(@appinfo:externalImportIndicator)"
      &gt;The namespace for IC-NTK MUST be imported as conformant.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;          </pre></div></div></div><div class="section"><a name="section_11.6.3"></a><div class="heading">11.6.3. Each namespace may have only a single root schema in a schema set.</div><div class="box"><a name="rule_11-38"></a><div class="normativeHead">[Rule 11-38] (SET) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:schema[exists(@targetNamespace)
                               and (some $element 
                                   in nf:resolve-namespace(., xs:anyURI(@targetNamespace))
                                   satisfies $element is .)]"&gt;
    &lt;sch:assert test="count(nf:resolve-namespace(., xs:anyURI(@targetNamespace))) = 1"
                &gt;A namespace may appear as a root schema in a schema set only once.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div><div class="section"><a name="section_11.6.4"></a><div class="heading">11.6.4. Consistently marked namespace imports</div><p>XML Schemas allows multiple xs:import elements for the same namespace, which allows for multiple sets of annotations and schema locations. </p><div class="box"><a name="rule_11-39"></a><div class="normativeHead">[Rule 11-39] (REF, EXT) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="xs:import"&gt;
    &lt;sch:let name="namespace" value="@namespace"/&gt;
    &lt;sch:let name="is-conformant" value="empty(@appinfo:externalImportIndicator)"/&gt;
    &lt;sch:let name="first" value="exactly-one(parent::xs:schema/xs:import[@namespace = $namespace][1])"/&gt;
    &lt;sch:assert test=". is $first
                      or $is-conformant = empty($first/@appinfo:externalImportIndicator)"
            &gt;All xs:import elements that have the same namespace MUST have the same conformance marking via appinfo:externalImportIndicator.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div></div></div></div><div class="section"><a name="section_12"></a><div class="heading">12. XML instance document rules</div><p>This specification attempts to restrict XML instance data as little as possible while still maintaining interoperability. Section 2.6, NIEM-Conformant XML Documents and Elements, defines terminology for NIEM-conformance and XML documents.</p><p>NIEM does not require a specific encoding or specific requirements for the XML prologue, except as specified by <a href="#XML" class="ref">[XML]</a>.</p><div class="section"><a name="section_12.1"></a><div class="heading">12.1. Instance must be schema-valid</div><div class="box"><a name="rule_12-1"></a><div class="normativeHead">[Rule 12-1] (INS) (Constraint)</div><p>The XML document MUST be schema-valid, assessed with reference to the schema composed of the reference schemas, extension schemas, exchange schemas, utility schemas, and external schemas for the relevant namespaces.</p></div><p>The schemas that define the exchange must be authoritative. Each is the reference schema, extension schema, or exchange schema for the namespace it defines. Application developers may use other schemas for various purposes, but for the purposes of determining conformance, the authoritative schemas are relevant.</p><p>This rule should not be construed to mean that XML validation must be performed on all XML instances as they are served or consumed; only that the XML instances validate if XML validation is performed. The XML Schema component definitions specify XML documents and element information items, and the instances should follow the rules given by the schemas, even when validation is not performed.</p><p>NIEM embraces the use of XML Schema instance attributes, including <code>xsi:type</code>, <code>xsi:nil</code>, and <code>xsi:schemaLocation</code>, as specified by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a>.</p></div><div class="section"><a name="section_12.2"></a><div class="heading">12.2. Content elements</div><p>In XML instances, relationships between data objects are expressed as XML elements:</p><ol><li>Data objects are expressed as XML elements.</li><li>XML elements contain attributes and other elements.</li></ol><p>In this way, there is a relationship between the outer element (the containing element, also called the parent element) and the inner elements (the contained elements, also called as the child elements). An element that contains its content in this way is called a <span class="termRef"><a name="d3e11145" href="#definition_content_element">[content element]</a></span>.</p><div class="box"><a name="definition_content_element"></a><div class="normativeHead">[Definition: <dfn>content element</dfn>]</div><div class="sub"><p>A <strong>content element</strong> is an element information item that does not contain an attribute <code>structures:ref</code>. A content element expresses its value as text and element content of the element information item.</p></div></div><p>The most common NIEM patterns use content elements to represent most data. The following is an example of a content element in use. All elements in this example are content elements.</p><div class="figure"><a name="figure_12-1"></a><div class="caption">Figure 12-1: Example of content elements</div><div class="box"><pre>&lt;nc:Item&gt;
  &lt;nc:ItemOwner&gt;
    &lt;nc:EntityPerson&gt;
      &lt;nc:PersonName&gt;
        &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
      &lt;/nc:PersonName&gt;
    &lt;/nc:EntityPerson&gt;
  &lt;/nc:ItemOwner&gt;
&lt;/nc:Item&gt;</pre></div></div></div><div class="section"><a name="section_12.3"></a><div class="heading">12.3. Reference elements</div><p>Content elements are sufficient to represent data that takes the form of a tree. However, use of content elements has limitations. Problematic cases include:</p><p>Expression of all relationships via element containment is not always possible. Situations that cause problems include:</p><ul><li><p>Cycles: the relationships transitively held by an object include a relationship to itself.</p><p>For example, suppose that object 1 has a relationship to object 2 and object 2 has a relationship to object 1. This is not a tree, and so needs some representation other than a simple tree.</p></li><li><p>Reuse: multiple objects have a relationshp to a common object.</p><p>For example, suppose object 1 has a relationship to object 2 and object 3 has a relationship to object 2. Expressed via containment, this would result in a duplicate of object 2.</p></li></ul><p>A method that solves this problem is the use of references. In a C or assembler, you could use a pointer. In C++, a reference might be used. In Java, a reference value might be used. The method defined by the XML standard is the use of ID and IDREF. An IDREF refers to an ID. NIEM uses this method and assigns to it specific semantics.</p><p>Naive solutions to these problems that use only content elements require techniques such as repeating data and identifying and excluding duplicate data; these operation entail the use of excess storage and processing time.</p><p>It is good to avoid these problems; in order to avoid them, NIEM allows <span class="termRef"><a name="d3e11233" href="#definition_reference_element">[reference elements]</a></span>. A reference element expresses a relationship to another object by using a reference attribute, <code>structures:ref</code>. In <a href="#figure_12-2">Figure 12-2, <em>Example of reference element</em>, below</a>, the outer object is the content of <code>nc:Item</code>, which is an object of type <code>nc:ItemType</code>. It has a relationship <code>nc:ItemOwner</code> to the object that is the content of the <code>nc:Entity</code> element.</p><div class="figure"><a name="figure_12-2"></a><div class="caption">Figure 12-2: Example of reference element</div><div class="box"><pre>&lt;nc:Item&gt;
  &lt;nc:ItemOwner structures:ref="m82"/&gt;
&lt;/nc:Item&gt;
&lt;nc:Entity structures:id="m82"&gt;
  &lt;nc:EntityPerson&gt;
    &lt;nc:PersonName&gt;
      &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
    &lt;/nc:PersonName&gt;
  &lt;/nc:EntityPerson&gt;
&lt;/nc:Entity&gt;</pre></div></div><p>NIEM XML instances use IDREF attributes to establish links between XML elements.</p><div class="box"><a name="definition_reference_element"></a><div class="normativeHead">[Definition: <dfn>reference element</dfn>]</div><div class="sub"><p>A <strong>reference element</strong> is an element information item that has an attribute <code>structures:ref</code>. A reference element refers to its value by reference, instead of carrying it as content.</p></div></div><div class="section"><a name="section_12.3.1"></a><div class="heading">12.3.1. Element with <code>structures:ref</code> does not have content</div><div class="box"><a name="rule_12-2"></a><div class="normativeHead">[Rule 12-2] (INS) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[@structures:ref]"&gt;
    &lt;sch:assert test="empty(element() | text())"
      &gt;An element that has attribute structures:ref MUST NOT have element or text content.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;            </pre></div></div><div class="section"><a name="section_12.3.2"></a><div class="heading">12.3.2. Attribute <code>structures:ref</code> must reference <code>structures:id</code></div><div class="box"><a name="rule_12-3"></a><div class="normativeHead">[Rule 12-3] (INS) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[@structures:ref]"&gt;
    &lt;sch:let name="ref" value="@structures:ref"/&gt;
    &lt;sch:assert test="exists(//*[@structures:id = $ref])"
      &gt;The value of an attribute structures:ref must match the value of an attribute structures:id of some element in the XML document.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;            </pre></div><p>This mirrors the terminology in <a href="#XML" class="ref">[XML]</a> <a target="_blank" href="http://www.w3.org/TR/2008/REC-xml-20081126/#idref">subsection <em>Validity constraint: IDREF</em></a> within <a target="_blank" href="http://www.w3.org/TR/2008/REC-xml-20081126/#sec-attribute-types">§3.3.1, <em>Attribute Types</em></a>, except it requires the target attribute to be <code>structures:id</code>, rather than any attribute of type <code>ID</code>.</p></div><div class="section"><a name="section_12.3.3"></a><div class="heading">12.3.3. Linked elements have same validation root</div><div class="box"><a name="rule_12-4"></a><div class="normativeHead">[Rule 12-4] (INS) (Constraint)</div><p>Given that:</p><ul><li><var>$element</var> is an <a target="_blank" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoitem.element">element information item</a></li><li><var>$element</var> has attribute <code>structures:ref</code> with value <var>$ref</var></li><li><var>$element</var> has <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#e-validation_context">property [validation context]</a> with value called the <em>referencing element validation root</em></li><li><var>$target</var> is an <a target="_blank" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoitem.element">element information item</a></li><li><var>$target</var> has attribute <code>structures:id</code> with value <var>$ref</var></li><li><var>$target</var> has <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#e-validation_context">property [validation context]</a> with value called the <em>referenced element validation root</em></li></ul><p>Every element that has an attribute <code>structures:ref</code> MUST have a referencing element validation root that is equal to the referenced element validation root.</p></div><p>The term <q>validation root</q> is defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-vr">§5.2, <em>Assessing Schema-Validity</em></a>. It is established as a part of validity assessment of an XML document. It is required because relationships between the types of elements cannot be established if those elements were not assessed together.</p></div><div class="section"><a name="section_12.3.4"></a><div class="heading">12.3.4. Attribute <code>structures:ref</code> references element of correct type</div><div class="box"><a name="rule_12-5"></a><div class="normativeHead">[Rule 12-5] (INS) (Constraint)</div><p>Given that:</p><ul><li><var>$element</var> is an <a target="_blank" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoitem.element">element information item</a></li><li><var>$element</var> has attribute <code>structures:ref</code> with value <var>$ref</var></li><li><var>$element</var> has <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#e-declaration">property [element declaration]</a> with value <var>$element-declaration</var></li><li><var>$element-declaration</var> has <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#type_definition">property {type definition}</a> with value called the <em>referencing element type definition</em></li><li><var>$target</var> is an <a target="_blank" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/#infoitem.element">element information item</a></li><li><var>$target</var> has attribute <code>structures:id</code> with value <var>$ref</var></li><li><var>$target</var> has <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#e-type_definition">property [type definition]</a> with value called the <em>referenced element type definition</em></li></ul><p>Every element that has an attribute <code>structures:ref</code> MUST have a referencing element type definition that is validly derived from the referenced element type definition.</p></div><p>The term <strong>validly derived</strong> is as established by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#cos-ct-derived-ok">subsection <em>Schema Component Constraint: Type Derivation OK (Complex)</em></a> within <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#coss-ct">§3.4.6, <em>Constraints on Complex Type Definition Schema Components</em></a>.</p><p>This rule requires that the type of the element information item pointed to by a <code>structures:ref</code> attribute must be of (or derived from) the type that is specified by the element declaration of the reference element.</p></div><div class="section"><a name="section_12.3.5"></a><div class="heading">12.3.5. Reference and content elements have same meaning</div><p>An important aspect of the use of NIEM reference and content elements is that they have the same meaning. The use of a content element versus a reference element is merely for convenience and ease of serialization. There is no change in meaning or semantics between content and reference elements.</p><p>Any claim that content elements represent composition while reference elements represent aggregation is incorrect. Any life cycle dependency is not expressed through the use of content and reference elements, and is not an explicit part of the NIEM model.</p><div class="box"><a name="rule_12-6"></a><div class="normativeHead">[Rule 12-6] (INS) (Interpretation)</div><p>There MUST NOT be any difference in meaning between a relationship established via a content element and a relationship established via reference element, except as explicitly described by the semantics of the elements involved.</p></div><p>There is no difference in meaning between relationships established by content elements and those established by reference elements. They are simply two mechanisms for expressing connections between objects. Neither mechanism implies that properties are intrinsic or extrinsic; such characteristics must be explicitly stated in property definitions.</p><p>Being of type <code>xs:ID</code> and <code>xs:IDREF</code>, validating schema parsers will perform certain checks on the values of <code>structures:id</code> and <code>structures:ref</code>. Specifically, no two IDs may have the same value. This includes <code>structures:id</code> and other IDs that may be used within an XML document. Also, any value of <code>structures:ref</code> must also appear as the value of an ID.</p><p>By this rule, the following two XML fragments have the same meaning. First, <a href="#figure_12-3">Figure 12-3, <em>Example with a backward reference</em>, below,</a> shows a person object being expressed, followed by a backwards reference to it. Second, <a href="#figure_12-4">Figure 12-4, <em>Example with a forward reference</em>, below,</a> shows a person as a forward reference to the person object that is expressed later, within the definition of a witness. Both of these XML fragments have the same semantics.</p><div class="figure"><a name="figure_12-3"></a><div class="caption">Figure 12-3: Example with a backward reference</div><div class="box"><pre>&lt;nc:Person structures:id="c58"&gt;
  &lt;nc:PersonName&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
&lt;/nc:Person&gt;
&lt;j:Witness&gt;
  &lt;nc:RoleOfPerson structures:ref="c58"/&gt;
&lt;/j:Witness&gt;</pre></div></div><div class="figure"><a name="figure_12-4"></a><div class="caption">Figure 12-4: Example with a forward reference</div><div class="box"><pre>&lt;nc:Person structures:ref="t85"/&gt;
&lt;j:Witness&gt;
  &lt;nc:RoleOfPerson structures:id="t85"&gt;
    &lt;nc:PersonName&gt;
      &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
    &lt;/nc:PersonName&gt;
  &lt;/nc:RoleOfPerson&gt;
&lt;/j:Witness&gt;</pre></div></div><p>NIEM-conformant data instances may use content elements and reference elements as needed, to represent the meaning of the fundamental data. There is no difference in meaning between reference and content data representations. The two different methods are available for ease of representation. No difference in <em>meaning</em> should be implied by the use of one method or the other.</p><p>Assertions that indicate <q>included</q> data is intrinsic, while referenced data is extrinsic, are not valid and are not applicable to NIEM-conformant data instances and data definitions.</p></div></div><div class="section"><a name="section_12.4"></a><div class="heading">12.4. Instance meaning</div><div class="box"><a name="rule_12-7"></a><div class="normativeHead">[Rule 12-7] (INS) (Constraint)</div><p>Within the instance, the meaning of an element with no content is that additional properties are not asserted. There SHALL NOT be additional meaning interpreted for an element with no content.</p></div><p><strong>Rationale</strong></p><p>Elements without content only show a lack of asserted information. That is, all that is asserted is what is explicitly stated, through a combination of XML instance data and its schema. Data that is not present makes no claims. It may be absent due to lack of availability, lack of knowledge, or deliberate withholding of information. These cases should be modeled explicitly, if they are required.</p></div><div class="section"><a name="section_12.5"></a><div class="heading">12.5. Instance metadata</div><p>NIEM provides the metadata mechanism for giving information about object assertions. An object may have an attribute that refers to one or more metadata objects. A <code>structures:metadata</code> attribute indicates that a data item has the given metadata. A <code>structures:relationshipMetadata</code> attribute asserts that the link (or relationship) established by an element has the given metadata.</p><div class="figure"><a name="figure_12-5"></a><div class="caption">Figure 12-5: Simple example of instance metadata</div><div class="box"><pre>&lt;nc:Person&gt;
  &lt;nc:PersonName structures:metadata="o25" structures:relationshipMetadata="o67"&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
&lt;/nc:Person&gt;
&lt;nc:Metadata structures:id="o25"&gt;
  &lt;nc:SourceText&gt;Adam Barber&lt;/nc:SourceText&gt;
&lt;/nc:Metadata&gt;
&lt;nc:Metadata structures:id="o67"&gt;
  &lt;nc:ProbabilityPercent&gt;0.25&lt;/nc:ProbabilityPercent&gt;
&lt;/nc:Metadata&gt;</pre></div></div><div class="figure"><a name="figure_12-6"></a><div class="caption">Figure 12-6: Example of metadata used in an instance</div><div class="box"><pre>&lt;nc:Person&gt;
  &lt;nc:PersonBirthDate structures:metadata="j86"&gt;
    &lt;nc:Date&gt;1945-12-01&lt;/nc:Date&gt;
  &lt;/nc:PersonBirthDate&gt;
  &lt;nc:PersonName structures:metadata="s22 j86" structures:relationshipMetadata="k25"&gt;
    &lt;nc:PersonFullName&gt;John Doe&lt;/nc:PersonFullName&gt;
  &lt;/nc:PersonName&gt;
&lt;/nc:Person&gt;
&lt;nc:Metadata structures:id="s22"&gt;
  &lt;nc:SourceText&gt;Adam Barber&lt;/nc:SourceText&gt;
&lt;/nc:Metadata&gt;
&lt;nc:Metadata structures:id="j86"&gt;
  &lt;nc:ReportedDate&gt;
    &lt;nc:Date&gt;2005-04-26&lt;/nc:Date&gt;
  &lt;/nc:ReportedDate&gt;
&lt;/nc:Metadata&gt;
&lt;nc:Metadata structures:id="k25"&gt;
  &lt;nc:ProbabilityPercent&gt;0.25&lt;/nc:ProbabilityPercent&gt;
&lt;/nc:Metadata&gt;</pre></div></div><p>This example shows a person named John Doe, born 12/1/1945. This data has several pieces of metadata on it:</p><ul><li>Metadata <code>s22</code> asserts Adam Barber gave the name.</li><li>Metadata <code>j86</code> asserts the name and the birth date were reported on 4/26/2005.</li><li>Link metadata <code>o67</code> asserts a 25% probability that the name goes with the person.</li></ul><p>This shows several characteristics of metadata:</p><ul><li>Metadata objects may appear outside the data they describe.</li><li>Metadata objects may be reused.</li><li>Data may refer to more than one metadata object.</li><li>Metadata pertains to an object or simple content, while link metadata pertains to the relationship between objects.</li></ul><p>An instance would not be valid XML if the <code>structures:metadata</code> or <code>structures:relationshipMetadata</code> attributes contained references for which there were no defined IDs. The instance would not be NIEM-conformant if the references were not to IDs defined with the <code>structures:id</code> attribute.</p><p>The definition of a metadata type may contain an <code>appinfo:AppliesTo</code> element, which indicates the type to which the metadata applies. For example:</p><div class="figure"><a name="figure_12-7"></a><div class="caption">Figure 12-7: A metadata type that describes applicability using <code>appinfo:AppliesTo</code></div><div class="box"><pre>&lt;xsd:complexType name="MeasureMetadataType"&gt;
  &lt;xsd:annotation&gt;
      ...
    &lt;xsd:appinfo&gt;
      &lt;i:AppliesTo i:name="MeasureType"/&gt;
    &lt;/xsd:appinfo&gt;
  &lt;/xsd:annotation&gt;
  &lt;xsd:complexContent&gt;
    ...
  &lt;/xsd:complexContent&gt;
&lt;/xsd:complexType&gt;</pre></div></div><p>Application of metadata to a type to which it is not applicable is not NIEM-conformant. A metadata type may contain multiple <code>appinfo:AppliesTo</code> elements, in which case it may apply to an instance of any of the listed types. If a metadata type contains no <code>appinfo:AppliesTo</code> elements, then it may apply to any type. This is the case for <code>nc:MetadataType</code> in NIEM 2.0.</p><div class="box"><a name="rule_12-8"></a><div class="normativeHead">[Rule 12-8] (INS) (Constraint)</div><p>Within an element instance, when an object O links to a metadata object via an attribute <code>structures:metadata</code>, the information in the metadata object SHALL be applied to the object O.</p></div><div class="box"><a name="rule_12-9"></a><div class="normativeHead">[Rule 12-9] (INS) (Constraint)</div><p>Within an element instance, when an object O1 contains an element E, with content object O2 or with a reference to object O2, and O2 links to a metadata object via an attribute <code>structures:relationshipMetadata</code>, the information in the metadata object SHALL be applied to the relationship E between O1 and O2.</p></div><p><strong>Rationale</strong></p><p>These two rules define the meaning of metadata:</p><ul><li><code>structures:metadata</code> applies metadata to an object.</li><li><code>structures:relationshipMetadata</code> applies metadata to a relationship between two objects.</li></ul><div class="box"><a name="rule_12-10"></a><div class="normativeHead">[Rule 12-10] (INS) (Constraint)</div><p>Given that each IDREF in the value of an attribute <code>structures:metadata</code> must match the value of an ID attribute on some element in the XML document, that ID attribute MUST be an occurrence of the attribute <code>structures:id</code>.</p></div><div class="box"><a name="rule_12-11"></a><div class="normativeHead">[Rule 12-11] (INS) (Constraint)</div><p>Each element that an attribute <code>structures:metadata</code> references MUST have a type definition that is derived from <code>structures:MetadataType</code>.</p></div><div class="box"><a name="rule_12-12"></a><div class="normativeHead">[Rule 12-12] (INS) (Constraint)</div><p>Given that each IDREF in the value of an attribute <code>structures:relationshipMetadata</code> must match the value of an ID attribute on some element in the XML document, that ID attribute MUST be an occurrence of the attribute <code>structures:id</code>.</p></div><div class="box"><a name="rule_12-13"></a><div class="normativeHead">[Rule 12-13] (INS) (Constraint)</div><p>Each element that an attribute <code>structures:relationshipMetadata</code> references MUST have a type definition that is derived from structures:MetadataType.</p></div><p><strong>Rationale</strong></p><p>All <code>structures:metadata</code> and <code>structures:relationshipMetadata</code> attributes must refer to metadata objects, and the reference to that object must be established using the <code>structures:id</code> attribute, to facilitate processing of XML documents.</p><div class="box"><a name="rule_12-14"></a><div class="normativeHead">[Rule 12-14] (INS) (Constraint)</div><p>Given that an element information item E has a type definition of some type T, each metadata type that is the type definition of an element information item referenced by an attribute <code>structures:metadata</code> or <code>structures:relationshipMetadata</code> on element E MUST be applicable to T.</p></div><p><strong>Rationale</strong></p><p>The applicability is determined by <code>appinfo:AppliesTo</code> application information of the metadata type definition. The instances must correspond to the types specified by the metadata type definition.</p></div><div class="box"><a name="definition_XML_instance_document"></a><div class="normativeHead">[Definition: <dfn>XML instance document</dfn>]</div><div class="sub"><p>An <em>XML instance document</em> is an <span class="termRef"><a name="d3e12038" href="#definition_XML_document">[XML document]</a></span> that is assessed as <span class="termRef"><a name="d3e12041" href="#definition_valid">[valid]</a></span> against an <span class="termRef"><a name="d3e12044" href="#definition_XML_Schema">[XML Schema]</a></span>.</p></div></div><div class="box"><a name="definition_valid"></a><div class="normativeHead">[Definition: <dfn>valid</dfn>]</div><div class="sub"><p>The term <q>valid</q> is as defined by <a href="#XMLSchema-1" class="ref">[XML Schema Structures]</a> <a target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/#key-vn">§2.1, <em>Overview of XML Schema</em></a>, which states:</p><blockquote><p>[Definition:] the word <strong>valid</strong> and its derivatives are used to refer to clause 1 above, the determination of local schema-validity.</p></blockquote><p>The referenced clause 1 is a part of a description of schema-validity:</p><blockquote><p>Schema-validity assessment has two aspects:</p><ol><li>Determining local schema-validity, that is whether an element or attribute information item satisfies the constraints embodied in the relevant components of an XML Schema;</li><li>Synthesizing an overall validation outcome for the item, combining local schema-validity with the results of schema-validity assessments of its descendants, if any, and adding appropriate augmentations to the infoset to record this outcome.</li></ol></blockquote></div></div><div class="section"><a name="section_12.6"></a><div class="heading">12.6. Attribute <code>structures:ref</code> references <code>structures:id</code></div><div class="box"><a name="rule_12-15"></a><div class="normativeHead">[Rule 12-15] (INS) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@structures:ref)]"&gt;
    &lt;sch:let name="ref" value="@structures:ref"/&gt;
    &lt;sch:assert test="exists(//@structures:id[. = $ref])"
      &gt;The value of an attribute structures:ref MUST appear as the value of an attribute structures:id in the [XML instance document].&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>This states that in NIEM-conformant content, <code>structures:ref</code> attributes must refer to <code>structures:id</code> attributes. By <a href="#XML" class="ref">[XML]</a> <a target="_blank" href="http://www.w3.org/TR/2008/REC-xml-20081126/#idref">§3.3.1, <em>Attribute Types</em></a>, an IDREF is required to reference an ID. This rule ensures that the target of a reference is a NIEM ID for easier processing of XML documents.</p></div><div class="section"><a name="section_12.7"></a><div class="heading">12.7. Attribute <code>structures:metadata</code> references a metadata element</div><div class="box"><a name="rule_12-16"></a><div class="normativeHead">[Rule 12-16] (INS) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@structures:metadata)]"&gt;
    &lt;sch:assert test="every $metadata-ref in tokenize(normalize-space(@structures:metadata)) satisfies
                        exists(//*[exists(@structures:id[. = $metadata-ref])
                                   and ends-with(local-name(), 'Metadata')])"
      &gt;Each item in the value of an attribute structures:metadata MUST appear as the value of an attribute structures:id with an owner element that is a metadata element.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Note that this will NOT catch a scenario in which the element with a name ending in <q>Metadata</q> is an external element; additional tests would be required to catch that.</p></div><div class="section"><a name="section_12.8"></a><div class="heading">12.8. Attribute <code>structures:relationshipMetadata</code> references a metadata element</div><div class="box"><a name="rule_12-17"></a><div class="normativeHead">[Rule 12-17] (INS) (Constraint)</div><pre>&lt;sch:pattern&gt;
  &lt;sch:rule context="*[exists(@structures:relationshipMetadata)]"&gt;
    &lt;sch:assert test="every $metadata-ref in tokenize(normalize-space(@structures:relationshipMetadata)) satisfies
                        exists(//*[exists(@structures:id[. = $metadata-ref])
                                   and ends-with(local-name(), 'Metadata')])"
      &gt;Each item in the value of an attribute structures:relationshipMetadata MUST appear as the value of an attribute structures:id with an owner element that is a metadata element.&lt;/sch:assert&gt;
  &lt;/sch:rule&gt;
&lt;/sch:pattern&gt;</pre></div><p>Note that this will NOT catch a scenario in which the element with a name ending in <q>Metadata</q> is an external element; additional tests would be required to catch that.</p></div></div><div class="section"><a name="appendix_A"></a><div class="heading">Appendix A. References</div><p class="hang"><a name="ClarkNS"></a><span class="ref">[ClarkNS]</span>: Clark, J. <q>XML Namespaces</q>, 4 February 1999. Available from <a class="url" target="_blank" href="http://www.jclark.com/xml/xmlns.htm">http://www.jclark.com/xml/xmlns.htm</a>.</p><div class="sub"></div><p class="hang"><a name="CTAS"></a><span class="ref">[CTAS]</span>: <q>NIEM Conformance Targets Attribute Specification, Version 3.0</q>, 1 August 2012. Available from <a class="url" target="_blank" href="http://reference.niem.gov/niem/specification/conformance-target-attribute/3.0beta2/NIEM-CTAS-3.0beta2.html">http://reference.niem.gov/niem/specification/conformance-target-attribute/3.0beta2/NIEM-CTAS-3.0beta2.html</a>.</p><div class="sub"></div><p class="hang"><a name="ISO11179-4"></a><span class="ref">[ISO 11179-4]</span>: <q>ISO/IEC 11179-4 Information Technology — Metadata Registries (MDR) — Part 4: Formulation of Data Definitions Second Edition</q>, 15 July 2004. Available from <a class="url" target="_blank" href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c035346_ISO_IEC_11179-4_2004(E).zip">http://standards.iso.org/ittf/PubliclyAvailableStandards/c035346_ISO_IEC_11179-4_2004(E).zip</a>.</p><div class="sub"></div><p class="hang"><a name="ISO11179-5"></a><span class="ref">[ISO 11179-5]</span>: <q>ISO/IEC 11179-5:2005, Information technology — Metadata registries (MDR) — Part 5: Naming and identification principles</q>. Available from <a class="url" target="_blank" href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c035347_ISO_IEC_11179-5_2005(E).zip">http://standards.iso.org/ittf/PubliclyAvailableStandards/c035347_ISO_IEC_11179-5_2005(E).zip</a>.</p><div class="sub"></div><p class="hang"><a name="N-ary"></a><span class="ref">[N-ary]</span>: <q>Defining N-ary Relations on the Semantic Web</q>, W3C Working Group Note, 12 April 2006. Available from <a class="url" target="_blank" href="http://www.w3.org/TR/2006/NOTE-swbp-n-aryRelations-20060412//">http://www.w3.org/TR/2006/NOTE-swbp-n-aryRelations-20060412//</a>.</p><div class="sub"></div><p class="hang"><a name="OED"></a><span class="ref">[OED]</span>: <q>Oxford English Dictionary, Third Edition</q>, Oxford University Press, November 2010. <a class="url" target="_blank" href="http://dictionary.oed.com/">http://dictionary.oed.com/</a>.</p><div class="sub"></div><p class="hang"><a name="RDFPrimer"></a><span class="ref">[RDF Primer]</span>: <q>RDF Primer</q>, W3C Recommendation, 10 February 2004. Available from <a class="url" target="_blank" href="http://www.w3.org/TR/2004/REC-rdf-primer-20040210/">http://www.w3.org/TR/2004/REC-rdf-primer-20040210/</a>.</p><div class="sub"></div><p class="hang"><a name="RDFSemantics"></a><span class="ref">[RDF Semantics]</span>: <q>RDF Semantics</q>, W3C Recommendation, 10 February 2004. Available from <a class="url" target="_blank" href="http://www.w3.org/TR/2004/REC-rdf-mt-20040210/">http://www.w3.org/TR/2004/REC-rdf-mt-20040210/</a>.</p><div class="sub"></div><p class="hang"><a name="RFC2119"></a><span class="ref">[RFC 2119]</span>: Bradner, S. <q>Key words for use in RFCs to Indicate Requirement Levels</q>, IETF RFC 2119, March 1997. Available from <a class="url" target="_blank" href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</p><div class="sub"></div><p class="hang"><a name="RFC3986"></a><span class="ref">[RFC 3986]</span>: Berners-Lee, T., et al. <q>Uniform Resource Identifier (URI): Generic Syntax</q>, Request for Comments 3986, January 2005. Available from <a class="url" target="_blank" href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</p><div class="sub"></div><p class="hang"><a name="WPCamelCase"></a><span class="ref">[WP CamelCase]</span>: <q>CamelCase.</q> Wikipedia, The Free Encyclopedia, January 19, 2014. <a class="url" target="_blank" href="http://en.wikipedia.org/w/index.php?title=CamelCase&amp;oldid=591379310">http://en.wikipedia.org/w/index.php?title=CamelCase&amp;oldid=591379310</a>.</p><div class="sub"></div><p class="hang"><a name="XML"></a><span class="ref">[XML]</span>: <q>Extensible Markup Language (XML) 1.0 (Fourth Edition)</q>, W3C Recommendation, 16 August 2006. Available from <a class="url" target="_blank" href="http://www.w3.org/TR/2008/REC-xml-20081126/">http://www.w3.org/TR/2008/REC-xml-20081126/</a>.</p><div class="sub"></div><p class="hang"><a name="XMLInfoset"></a><span class="ref">[XML Infoset]</span>: Cowan, John, and Richard Tobin. <q>XML Information Set (Second Edition)</q>, 4 February 2004. <a class="url" target="_blank" href="http://www.w3.org/TR/2004/REC-xml-infoset-20040204/">http://www.w3.org/TR/2004/REC-xml-infoset-20040204/</a>.</p><div class="sub"></div><p class="hang"><a name="XMLNamespaces"></a><span class="ref">[XML Namespaes]</span>: <q>Namespaces in XML 1.0 (Third Edition)</q>, W3C Recommendation, 8 December 2009. Available from <a class="url" target="_blank" href="http://www.w3.org/TR/2009/REC-xml-names-20091208/">http://www.w3.org/TR/2009/REC-xml-names-20091208/</a>.</p><div class="sub"><p>NCName is described at <a class="url" target="_blank" href="http://www.w3.org/TR/2006/REC-xml-names-20060816#NT-NCName">#NT-NCName</a>.</p></div><p class="hang"><a name="XMLNamespacesErrata"></a><span class="ref">[XML Namespaces Errata]</span>: <q>Namespaces in XML Errata</q>, 6 December 2002. Available from <a class="url" target="_blank" href="http://www.w3.org/XML/xml-names-19990114-errata">http://www.w3.org/XML/xml-names-19990114-errata</a>.</p><div class="sub"></div><p class="hang"><a name="XMLSchema-2"></a><span class="ref">[XML Schema Datatypes]</span>: <q>XML Schema Part 2: Datatypes Second Edition</q>, W3C Recommendation, 28 October 2004. Available at <a class="url" target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/</a>.</p><div class="sub"><p>Prohibition on direct use of simple type <code>xs:NOTATION</code> is at <a class="url" target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/#enumeration-required-notation">#enumeration-required-notation</a>.</p></div><p class="hang"><a name="XMLSchema-1"></a><span class="ref">[XML Schema Structures]</span>: <q>XML Schema Part 1: Structures Second Edition</q>, W3C Recommendation, 28 October 2004. Available from <a class="url" target="_blank" href="http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/">http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/</a>.</p><div class="sub"></div><p class="hang"><a name="Schematron"></a><span class="ref">[Schematron]</span>: <q>ISO/IEC STANDARD 19757-3: Information technology — Document Schema Definition Languages (DSDL) Part 3: Rule-based validation — Schematron</q>, ISO/IEC, 1 June 2006. Retrieved from <a class="url" target="_blank" href="http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip">http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip</a>.</p><div class="sub"></div><p class="hang"><a name="XPath2"></a><span class="ref">[XPath 2]</span>: Berglund, Anders, Scott Boag, Don Chamberlin, Mary F. Fernández, Michael Kay, Jonathan Robie, and Jérôme Siméon. <q>XML Path Language (XPath) 2.0 (Second Edition)</q>, W3C Recommendation, 3 January 2011. <a class="url" target="_blank" href="http://www.w3.org/TR/2010/REC-xpath20-20101214/">http://www.w3.org/TR/2010/REC-xpath20-20101214/</a>.</p><div class="sub"></div></div><div class="section"><a name="appendix_B"></a><div class="heading">Appendix B. Structures namespace</div><pre>&lt;?xml version="1.0" encoding="US-ASCII"?&gt;
&lt;xs:schema
    targetNamespace="http://release.niem.gov/niem/structures/3.0/"
    version="1"
    xmlns:structures="http://release.niem.gov/niem/structures/3.0/"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;

    &lt;xs:attribute name="id" type="xs:ID"/&gt;
    &lt;xs:attribute name="ref" type="xs:IDREF"/&gt;
    &lt;xs:attribute name="metadata" type="xs:IDREFS"/&gt;
    &lt;xs:attribute name="relationshipMetadata" type="xs:IDREFS"/&gt;
   
    &lt;xs:attributeGroup name="SimpleObjectAttributeGroup"&gt;
        &lt;xs:attribute ref="structures:id"/&gt;
        &lt;xs:attribute ref="structures:ref"/&gt;
        &lt;xs:attribute ref="structures:metadata"/&gt;
        &lt;xs:attribute ref="structures:relationshipMetadata"/&gt;
        &lt;xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/&gt;
    &lt;/xs:attributeGroup&gt;

    &lt;xs:complexType name="ObjectType" abstract="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element ref="structures:ObjectAugmentationPoint" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute ref="structures:id"/&gt;
        &lt;xs:attribute ref="structures:ref"/&gt;
        &lt;xs:attribute ref="structures:metadata"/&gt;
        &lt;xs:attribute ref="structures:relationshipMetadata"/&gt;
        &lt;xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:element name="ObjectAugmentationPoint" abstract="true"&gt;
        &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;An augmentation point for ObjectType&lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
    &lt;/xs:element&gt;

    &lt;xs:complexType name="AssociationType" abstract="true"&gt;
        &lt;xs:sequence&gt;
            &lt;xs:element ref="structures:AssociationAugmentationPoint" minOccurs="0" maxOccurs="unbounded"/&gt;
        &lt;/xs:sequence&gt;
        &lt;xs:attribute ref="structures:id"/&gt;
        &lt;xs:attribute ref="structures:ref"/&gt;
        &lt;xs:attribute ref="structures:metadata"/&gt;
        &lt;xs:attribute ref="structures:relationshipMetadata"/&gt;
        &lt;xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:element name="AssociationAugmentationPoint" abstract="true"&gt;
        &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;An augmentation point for AssociationType&lt;/xs:documentation&gt;
        &lt;/xs:annotation&gt;
    &lt;/xs:element&gt;

    &lt;xs:complexType name="MetadataType" abstract="true"&gt;
        &lt;xs:attribute ref="structures:id"/&gt;
        &lt;xs:attribute ref="structures:ref"/&gt;
        &lt;xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/&gt;
    &lt;/xs:complexType&gt;

    &lt;xs:complexType name="AugmentationType" abstract="true"&gt;
        &lt;xs:attribute ref="structures:id"/&gt;
        &lt;xs:attribute ref="structures:ref"/&gt;
        &lt;xs:attribute ref="structures:metadata"/&gt;
        &lt;xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/&gt;
    &lt;/xs:complexType&gt;

&lt;/xs:schema&gt;
</pre></div><div class="section"><a name="appendix_C"></a><div class="heading">Appendix C. Appinfo namespace</div><pre>&lt;?xml version="1.0" encoding="US-ASCII"?&gt;
&lt;xs:schema
    attributeFormDefault="qualified"
    targetNamespace="http://release.niem.gov/niem/appinfo/3.0/"
    version="1"
    xmlns:appinfo="http://release.niem.gov/niem/appinfo/3.0/"
    xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;The appinfo schema provides support for high level data model concepts and additional syntax to support the NIEM conceptual model and validation of NIEM-conformant instances.&lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;

  &lt;xs:attribute name="deprecated"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;The Deprecated element provides a method for identifying schema components as being deprecated. A deprecated component is one that is provided, but the use of which is not recommended.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:boolean"&gt;
        &lt;xs:pattern value="true"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:attribute&gt;

  &lt;xs:attribute name="appliesToTypes"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;The appliesToTypes attribute appears on the element declaration of a metadata element. It indicates a set of types to which the metadata element may be applied. The metadata element will also be applicable to any type that is derived from a listed type.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:list itemType="xs:QName"/&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:attribute&gt;

  &lt;xs:attribute name="appliesToElements"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;The appliesToElements attribute appears on the element declaration of a metadata element. It indicates a set of elements to which the metadata element may be applied. The metadata element will also be applicable to any element that is in the substitution group of a listed element.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:list itemType="xs:QName"/&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:attribute&gt;

  &lt;xs:attribute name="externalAdapterTypeIndicator"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;The externalAdapterTypeIndicator attribute indicates that a complex type is an external adapter type. An external adapter type is composed of elements and attributes from non-NIEM-conformant schemas.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:boolean"&gt;
        &lt;xs:pattern value="true"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:attribute&gt;

  &lt;xs:attribute name="externalImportIndicator"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;The externalImportIndicator attribute is true if and only if a namespace identified via xs:import is expected to be non-conformant.&lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:simpleType&gt;
      &lt;xs:restriction base="xs:boolean"&gt;
        &lt;xs:pattern value="true"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:attribute&gt;

&lt;/xs:schema&gt;
</pre></div><div class="section"><a name="appendix_D"></a><div class="heading">Appendix D. Local terminology namespace</div><pre>&lt;?xml version="1.0" encoding="US-ASCII"?&gt;
&lt;xs:schema
   elementFormDefault="qualified" 
   targetNamespace="http://release.niem.gov/niem/localTerminology/3.0/"
   version="1"
   xmlns:term="http://release.niem.gov/niem/localTerminology/3.0/"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;

  &lt;xs:element name="LocalTerm"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:sequence&gt;
	&lt;xs:element name="SourceText" type="term:NonemptyStringSimpleType" 
                    minOccurs="0" maxOccurs="unbounded"/&gt;
      &lt;/xs:sequence&gt;
      &lt;xs:attribute name="term" type="term:NonemptyStringSimpleType" use="required"/&gt;
      &lt;xs:attribute name="literal" type="term:NonemptyStringSimpleType"/&gt;
      &lt;xs:attribute name="definition" type="term:NonemptyStringSimpleType"/&gt;
      &lt;xs:attribute name="sourceURIs"&gt;
        &lt;xs:simpleType&gt;
          &lt;xs:restriction&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:list itemType="xs:anyURI"/&gt;
            &lt;/xs:simpleType&gt;
            &lt;xs:minLength value="1"/&gt;
          &lt;/xs:restriction&gt;
        &lt;/xs:simpleType&gt;
      &lt;/xs:attribute&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:simpleType name="NonemptyStringSimpleType"&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:minLength value="1"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</pre></div><div class="section"><a name="appendix_E"></a><div class="heading">Appendix E. Index of definitions</div><ul><li><a href="#definition_adapter_type">adapter type</a>: <a href="#section_10.2.2.3">Section 10.2.2.3, <em>External adapter types</em></a></li><li><a href="#definition_appinfo_namespace">appinfo namespace</a>: <a href="#section_10.5.2">Section 10.5.2, <em>The NIEM appinfo namespace</em></a></li><li><a href="#definition_application_information">application information</a>: <a href="#section_10.5">Section 10.5, <em>Machine-readable annotations</em></a></li><li><a href="#definition_association">association</a>: <a href="#section_10.2.3">Section 10.2.3, <em>Associations</em></a></li><li><a href="#definition_association_type">association type</a>: <a href="#section_10.2.3">Section 10.2.3, <em>Associations</em></a></li><li><a href="#definition_augmentable_type">augmentable type</a>: <a href="#section_10.2.4.1">Section 10.2.4.1, <em>Augmentable types</em></a></li><li><a href="#definition_augmentation">augmentation</a>: <a href="#section_10.2.4">Section 10.2.4, <em>Augmentations</em></a></li><li><a href="#definition_augmentation_type">augmentation type</a>: <a href="#section_10.2.4.4">Section 10.2.4.4, <em>Augmentation types</em></a></li><li><a href="#definition_base_type_definition">base type definition</a>: <a href="#section_3.4">Section 3.4, <em>XML Schema terminology</em></a></li><li><a href="#definition_code_simple_type">code simple type</a>: <a href="#section_11.1.4.5">Section 11.1.4.5, <em>Code simple types</em></a></li><li><a href="#definition_code_type">code type</a>: <a href="#section_10.2.2.4">Section 10.2.2.4, <em>Code types</em></a></li><li><a href="#definition_complex_type_definition">complex type definition</a>: <a href="#section_3.4">Section 3.4, <em>XML Schema terminology</em></a></li><li><a href="#definition_conformance_target">conformance target</a>: <a href="#section_3.6">Section 3.6, <em>Conformance Targets Attribute Specification terminology</em></a></li><li><a href="#definition_conformance_target_identifier">conformance target identifier</a>: <a href="#section_3.6">Section 3.6, <em>Conformance Targets Attribute Specification terminology</em></a></li><li><a href="#definition_conformant_element_information_item">conformant element information item</a>: <a href="#section_4.1.4">Section 4.1.4, <em>Instance documents and elements</em></a></li><li><a href="#definition_conformant_extension_schema_document">conformant extension schema document</a>: <a href="#section_4.1.2">Section 4.1.2, <em>Extension schema document</em></a></li><li><a href="#definition_conformant_instance_XML_document">conformant instance XML document</a>: <a href="#section_4.1.4">Section 4.1.4, <em>Instance documents and elements</em></a></li><li><a href="#definition_conformant_reference_schema_document">conformant reference schema document</a>: <a href="#section_4.1.1">Section 4.1.1, <em>Reference schema document</em></a></li><li><a href="#definition_conformant_schema_document_set">conformant schema document set</a>: <a href="#section_4.1.3">Section 4.1.3, <em>Schema document set</em></a></li><li><a href="#definition_constraint_rule">constraint rule</a>: <a href="#section_2.5.1">Section 2.5.1, <em>Rules</em></a></li><li><a href="#definition_content_element">content element</a>: <a href="#section_12.2">Section 12.2, <em>Content elements</em></a></li><li><a href="#definition_data_definition">data definition</a>: <a href="#section_7.4">Section 7.4, <em>ISO 11179 Part 4</em></a></li><li><a href="#definition_deprecated_component">deprecated component</a>: <a href="#section_10.5.2.1">Section 10.5.2.1, <em>Deprecation</em></a></li><li><a href="#definition_documented_component">documented component</a>: <a href="#section_7.4">Section 7.4, <em>ISO 11179 Part 4</em></a></li><li><a href="#definition_effective_conformance_target_identifier">effective conformance target identifier</a>: <a href="#section_3.6">Section 3.6, <em>Conformance Targets Attribute Specification terminology</em></a></li><li><a href="#definition_element_declaration">element declaration</a>: <a href="#section_3.4">Section 3.4, <em>XML Schema terminology</em></a></li><li><a href="#definition_element_declaration_schema_component">element declaration schema component</a>: <a href="#section_3.4">Section 3.4, <em>XML Schema terminology</em></a></li><li><a href="#definition_external_schema">external schema</a>: <a href="#section_10.2.2.3">Section 10.2.2.3, <em>External adapter types</em></a></li><li><a href="#definition_interpretation_rule">interpretation rule</a>: <a href="#section_2.5.1">Section 2.5.1, <em>Rules</em></a></li><li><a href="#definition_machine-readable_annotation">machine-readable annotation</a>: <a href="#section_10.5">Section 10.5, <em>Machine-readable annotations</em></a></li><li><a href="#definition_metadata_element">metadata element</a>: <a href="#section_11.2.1.7">Section 11.2.1.7, <em>Metadata element declarations</em></a></li><li><a href="#definition_metadata_type">metadata type</a>: <a href="#section_10.2.5.1">Section 10.2.5.1, <em>Metadata types</em></a></li><li><a href="#definition_object_type">object type</a>: <a href="#section_10.2.2.1">Section 10.2.2.1, <em>General object types</em></a></li><li><a href="#definition_reference_element">reference element</a>: <a href="#section_12.3">Section 12.3, <em>Reference elements</em></a></li><li><a href="#definition_role_type">role type</a>: <a href="#section_10.2.2.2">Section 10.2.2.2, <em>Roles</em></a></li><li><a href="#definition_RoleOf_element">RoleOf element</a>: <a href="#section_10.2.2.2">Section 10.2.2.2, <em>Roles</em></a></li><li><a href="#definition_schema_component">schema component</a>: <a href="#section_3.4">Section 3.4, <em>XML Schema terminology</em></a></li><li><a href="#definition_simple_type_definition">simple type definition</a>: <a href="#section_3.4">Section 3.4, <em>XML Schema terminology</em></a></li><li><a href="#definition_structures_namespace">structures namespace</a>: <a href="#section_10.1">Section 10.1, <em>NIEM structural facilities</em></a></li><li><a href="#definition_valid">valid</a>: <a href="#section_12">Section 12, <em>XML instance document rules</em></a></li><li><a href="#definition_XML_document">XML document</a>: <a href="#section_3.2">Section 3.2, <em>XML terminology</em></a></li><li><a href="#definition_XML_instance_document">XML instance document</a>: <a href="#section_12">Section 12, <em>XML instance document rules</em></a></li><li><a href="#definition_XML_Schema">XML Schema</a>: <a href="#section_3.4">Section 3.4, <em>XML Schema terminology</em></a></li></ul></div><div class="section"><a name="appendix_F"></a><div class="heading">Appendix F. Index</div><ul><li>adapter type: <a href="#d3e6847">§10.2.2.3</a>, <a href="#definition_adapter_type">§10.2.2.3 (definition)</a></li><li>appinfo namespace: <a href="#d3e6197">§10</a>, <a href="#d3e9131">§10.5</a>, <a href="#d3e9157">§10.5.2</a>, <a href="#definition_appinfo_namespace">§10.5.2 (definition)</a>, <a href="#d3e9176">§10.5.2</a></li><li>application information: <a href="#definition_application_information">§10.5 (definition)</a>, <a href="#d3e9122">§10.5</a></li><li>association: <a href="#d3e1834">§5.1</a>, <a href="#d3e7177">§10.2.3</a>, <a href="#definition_association">§10.2.3 (definition)</a></li><li>association type: <a href="#d3e1760">§5.1</a>, <a href="#definition_association_type">§10.2.3 (definition)</a>, <a href="#d3e7593">§10.2.4.1</a></li><li>augmentable type: <a href="#definition_augmentable_type">§10.2.4.1 (definition)</a></li><li>augmentation: <a href="#definition_augmentation">§10.2.4 (definition)</a></li><li>augmentation type: <a href="#definition_augmentation_type">§10.2.4.4 (definition)</a>, <a href="#d3e7834">§10.2.4.4.1</a>, <a href="#d3e7865">§10.2.4.4.2</a></li><li>base type definition: <a href="#definition_base_type_definition">§3.4 (definition)</a>, <a href="#d3e7862">§10.2.4.4.2</a></li><li>code simple type: <a href="#definition_code_simple_type">§11.1.4.5 (definition)</a></li><li>code type: <a href="#definition_code_type">§10.2.2.4 (definition)</a></li><li>complex type definition: <a href="#definition_complex_type_definition">§3.4 (definition)</a>, <a href="#d3e7831">§10.2.4.4.1</a></li><li>conformance target: <a href="#d3e463">§2.5.1</a>, <a href="#d3e504">§2.5.1</a>, <a href="#definition_conformance_target">§3.6 (definition)</a></li><li>conformance target identifier: <a href="#definition_conformance_target_identifier">§3.6 (definition)</a>, <a href="#d3e1485">§4.3</a></li><li>conformant element information item: <a href="#definition_conformant_element_information_item">§4.1.4 (definition)</a></li><li>conformant extension schema document: <a href="#definition_conformant_extension_schema_document">§4.1.2 (definition)</a>, <a href="#d3e1321">§4.1.4</a>, <a href="#d3e1386">§4.1.4</a>, <a href="#d3e6590">§10.2.2.2</a>, <a href="#d3e7580">§10.2.4.1</a></li><li>conformant instance XML document: <a href="#definition_conformant_instance_XML_document">§4.1.4 (definition)</a>, <a href="#d3e1393">§4.1.4</a>, <a href="#d3e2042">§5.5</a>, <a href="#d3e2048">§5.5</a></li><li>conformant reference schema document: <a href="#definition_conformant_reference_schema_document">§4.1.1 (definition)</a>, <a href="#d3e1262">§4.1.2</a>, <a href="#d3e1318">§4.1.4</a>, <a href="#d3e1383">§4.1.4</a>, <a href="#d3e3168">§8.2</a>, <a href="#d3e3186">§8.2</a>, <a href="#d3e6587">§10.2.2.2</a>, <a href="#d3e7577">§10.2.4.1</a></li><li>conformant schema document set: <a href="#definition_conformant_schema_document_set">§4.1.3 (definition)</a></li><li>constraint rule: <a href="#d3e486">§2.5.1</a>, <a href="#definition_constraint_rule">§2.5.1 (definition)</a></li><li>content element: <a href="#d3e11145">§12.2</a>, <a href="#definition_content_element">§12.2 (definition)</a></li><li>data definition: <a href="#d3e2513">§6.5.1</a>, <a href="#definition_data_definition">§7.4 (definition)</a>, <a href="#d3e2949">§7.4</a>, <a href="#d3e2989">§7.4</a>, <a href="#d3e10821">§11.4.2</a>, <a href="#d3e10844">§11.4.3</a></li><li>deprecated component: <a href="#definition_deprecated_component">§10.5.2.1 (definition)</a>, <a href="#d3e9219">§10.5.2.1.1</a></li><li>documented component: <a href="#definition_documented_component">§7.4 (definition)</a></li><li>effective conformance target identifier: <a href="#d3e679">§2.7</a>, <a href="#definition_effective_conformance_target_identifier">§3.6 (definition)</a></li><li>element declaration: <a href="#definition_element_declaration">§3.4 (definition)</a></li><li>element declaration schema component: <a href="#definition_element_declaration_schema_component">§3.4 (definition)</a>, <a href="#d3e4670">§9.2.1.11</a>, <a href="#d3e6578">§10.2.2.2</a>, <a href="#d3e6756">§10.2.2.2.3</a>, <a href="#d3e6773">§10.2.2.2.4</a></li><li>external schema: <a href="#definition_external_schema">§10.2.2.3 (definition)</a></li><li>interpretation rule: <a href="#d3e493">§2.5.1</a>, <a href="#definition_interpretation_rule">§2.5.1 (definition)</a></li><li>machine-readable annotation: <a href="#definition_machine-readable_annotation">§10.5 (definition)</a></li><li>metadata element: <a href="#definition_metadata_element">§11.2.1.7 (definition)</a></li><li>metadata type: <a href="#definition_metadata_type">§10.2.5.1 (definition)</a></li><li>object type: <a href="#d3e1757">§5.1</a>, <a href="#definition_object_type">§10.2.2.1 (definition)</a>, <a href="#d3e6557">§10.2.2.2</a>, <a href="#d3e6743">§10.2.2.2.2</a>, <a href="#d3e7600">§10.2.4.1</a></li><li>reference element: <a href="#d3e11233">§12.3</a>, <a href="#definition_reference_element">§12.3 (definition)</a></li><li>role type: <a href="#d3e6460">§10.2.2.2</a>, <a href="#d3e6494">§10.2.2.2</a>, <a href="#d3e6546">§10.2.2.2</a>, <a href="#definition_role_type">§10.2.2.2 (definition)</a>, <a href="#d3e6604">§10.2.2.2</a></li><li>RoleOf element: <a href="#definition_RoleOf_element">§10.2.2.2 (definition)</a>, <a href="#d3e6611">§10.2.2.2</a>, <a href="#d3e6740">§10.2.2.2.2</a>, <a href="#d3e6794">§10.2.2.2.4</a>, <a href="#d3e6804">§10.2.2.2</a>, <a href="#d3e6807">§10.2.2.2</a>, <a href="#d3e6810">§10.2.2.2</a>, <a href="#d3e6813">§10.2.2.2</a></li><li>schema component: <a href="#definition_schema_component">§3.4 (definition)</a>, <a href="#d3e5033">§9.3.1.1</a>, <a href="#d3e7825">§10.2.4.4.1</a>, <a href="#d3e9210">§10.5.2.1.1</a></li><li>simple type definition: <a href="#definition_simple_type_definition">§3.4 (definition)</a></li><li>structures namespace: <a href="#d3e6194">§10</a>, <a href="#definition_structures_namespace">§10.1 (definition)</a></li><li>valid: <a href="#d3e12041">§12</a>, <a href="#definition_valid">§12 (definition)</a></li><li>XML document: <a href="#definition_XML_document">§3.2 (definition)</a>, <a href="#d3e12038">§12</a></li><li>XML instance document: <a href="#definition_XML_instance_document">§12 (definition)</a></li><li>XML Schema: <a href="#definition_XML_Schema">§3.4 (definition)</a>, <a href="#d3e12044">§12</a></li></ul></div></body></html>