National Information Exchange Model Naming and Design Rules

Version 3.0alpha8

February 5, 2014

NIEM Technical Architecture Committee (NTAC)

Contents

   The table of contents is omitted from this edition.

Table of Figures

   The table of figures is omitted from this edition.

Table of Tables

   The table of tables is omitted from this edition.

Authors

   Webb Roberts, Georgia Tech Research Institute

Abstract

   This document specifies the data model, XML components, and XML data for use with the National Information Exchange Model (NIEM) version 3.0.

Status

   This document is draft of the specification for NIEM-conformant XML Schema documents, components, and instances. It represents the design that has evolved from the collaborative work of the NIEM Business Architecture Committee (NBAC) and the NIEM Technical Architecture Committee (NTAC) and their predecessors.

   This specification is a product of the NIEM Program Management Office (PMO).

   Send comments on this specification via email to niem-comments@lists.gatech.edu.

1. Introduction

   This Naming and Design Rules (NDR) document specifies XML Schema documents for use with the National Information Exchange Model (NIEM). NIEM is an information sharing framework based on the World Wide Web Consortium (W3C) Extensible Markup Language (XML) Schema standard. In February 2005, the U.S. Departments of Justice (DOJ) and Homeland Security (DHS) signed a cooperative agreement to jointly develop NIEM by leveraging and expanding the Global Justice XML Data Model (GJXDM) into multiple domains. NIEM is a result of a combined government and industry effort to improve information interoperability and exchange within the United States at federal, state, tribal, and local levels of government.

   NIEM specifies a set of reusable information components for defining standard information exchange messages, transactions, and documents on a large scale: across multiple communities of interest and lines of business. These reusable components are rendered in XML Schema documents as type, element, and attribute definitions that comply with the W3C XML Schema specification. The resulting reference schemas are available to government practitioners and developers at http://niem.gov/.

   The W3C XML Schema standard enables information interoperability and sharing by providing a common language for describing data precisely. The constructs it defines are basic metadata building blocks -- baseline data types and structural components. Users employ these building blocks to describe their own domain-oriented data semantics and structures, as well as structures for specific information exchanges and components for reuse across multiple information exchanges. Rules that profile allowable XML Schema constructs and describe how to use them help ensure that those components are consistent and reusable.

   This document specifies principles and enforceable rules for NIEM data components and schemas. Schemas and components that obey the rules set forth here are considered to be NIEM-conformant.

1.1. Scope

   This document was developed to specify NIEM 3.0. Later releases of NIEM may be specified by later versions of this document. The document covers the following issues in depth:

      *  The underlying NIEM data model

      *  Guiding principles behind the design of NIEM

      *  Rules for using XML Schema constructs in NIEM

      *  Rules for modeling and structuring NIEM-conformant schemas

      *  Rules for creating NIEM-conformant instances

      *  Rules for naming NIEM components

      *  Rules for extending NIEM-conformant components

   This document does NOT address the following:

      *  A formal definition of the NIEM data model.

         Such a definition would focus on the Resource Definition Framework (RDF) and concepts not strictly required for interoperability. This document instead focuses on definition of schemas that work with the data model, to ensure translatability and interoperability.

      *  A detailed discussion of NIEM architecture and schema versioning.

      *  The artifacts of the NIEM information exchange process.

   This document is intended as a technical specification. It is not intended to be a tutorial or a user guide.

1.2. Audience

   This document targets practitioners and developers who employ NIEM for information exchange and interoperability. Such information exchanges may be between or within organizations. The NIEM reference schemas provide system implementers much content on which to build specific exchanges. However, there is a need for extended and additional content. The purpose of this document is to define the rules for such new content so that it will be consistent with the NIEM reference schemas. These rules are intended to establish and, more important, enforce a degree of standardization on a national level.

2. Document conventions and normative content

   This document uses formatting and syntactic conventions to clarify meaning and avoid ambiguity.

2.1. Document references

   This document relies on references to many outside documents. Such references are noted by bold, bracketed inline terms. For example, a reference to RFC 2119 is shown as [RFC 2119]. All reference documents are recorded in Appendix A, References, below.

2.2. Formatting

   In addition to special formatting for definitions, principles, and rules, this document uses consistent formatting to identify NIEM components.

   Courier: All words appearing in Courier font are values, objects, keywords, or literal XML text.

   Italics: All words appearing in italics, when not titles or used for emphasis, are special terms with definitions appearing in this document.

   Throughout the document, fragments of XML Schema or XML instances are used to clarify a principle or rule. These fragments are specially formatted in Courier font and appear in text boxes. An example of such a fragment follows:

   Figure 2-1: Example of an XML fragment

      <xsd:complexType name="PersonType">
        ...
      </xsd:complexType>

2.3. Clark notation and qualified names

   This document uses both Clark notation and QName notation to represent qualified names.

   QName notation is defined by [XML Namespaes] section 4, Qualified Names. A QName for the XML Schema string datatype is xs:string. Namespace prefixes used within this specification are listed in Section 2.4, Use of namespaces, below.

   This document sometimes uses Clark notation to represent qualified names in normative text. Clark notation is described by [ClarkNS], and provides the information in an XML qualified name (as defined by [XML Namespaes]) without the need to define a namespace prefix and then reference that namespace prefix. A Clark notation representation for the qualified name for the XML Schema string datatype is {http://www.w3.org/2001/XMLSchema}string.

   Each Clark notation value consists of a namespace URI surrounded by curly braces, concatenated with a local name. Clark notation is frequently used to represent the qualified name for an attribute with no namespace, which is ambiguous when represented using QName notation. For example, the element targetNamespace, which has no [namespace name] property, is represented in Clark notation as {}targetNamespace.

2.4. Use of namespaces

   The following namespace prefixes are used consistently within this specification. These prefixes are not normative; this document issues no requirement that these prefixes be used in any conformant artifact.

      *  xs: The namespace for the XML Schema definition language as defined by [XML Schema Structures] and [XML Schema Datatypes], "http://www.w3.org/2001/XMLSchema".

      *  xsi: The XML Schema instance namespace, defined by [XML Schema Structures] section 2.6, Schema-Related Markup in Documents Being Validated, for use in XML documents, "http://www.w3.org/2001/XMLSchema-instance".

      *  sch: The Schematron namespace URI, as defined by [Schematron], "http://purl.oclc.org/dsdl/schematron".

      *  nf: The namespace defined by this specification for XPath functions, "http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#NDRFunctions".

      *  ct: The namespace defined by [CTAS] for the conformanceTargets attribute, "http://release.niem.gov/niem/conformanceTargets/3.0/".

      *  appinfo: The namespace for the [appinfo namespace], "http://release.niem.gov/niem/appinfo/3.0/".

      *  structures: The namespace for the [structures namespace], "http://release.niem.gov/niem/structures/3.0/".

2.5. Normative and informative content

   This document includes a variety of content. Some content is normative (binding and enforceable in implementations), while other content is informative (explanatory, but not part of the NIEM specification). In general, the informative material appears as supporting text and specific rationales for the normative material.

   Conventions used within this document include:

   [Definition: <term>]

      A formal definition of a term associated with NIEM.

   Definitions are normative.

   [Principle <number>]

      A guiding principle for NIEM.

   The principles represent the requirements, concepts, and goals that have helped shape the NIEM. Principles are informative, not normative, but act as the basis on which the rules are defined.

   Accompanying each principle is a short discussion section that justifies the application of the principle to NIEM design.

   Principles are numbered in the order in which they appear in the document.

2.5.1. Rules

   Rules state specific requirements on artifacts or on the interpretation of artifacts. The classes of artifacts are identified by [conformance targets] that are enumerated by this document in Section 4.1, Conformance targets defined, below. The rules are normative.

   [Rule <section>-<number>] (<applicability>)

      An enforceable rule for NIEM.

   Each rule has a classification, which is either "Constraint" or "Interpretation". If the classification is "Constraint", then the rule is a [constraint rule]. If the classification is "Interpretation", then the rule is an [interpretation rule].

   [Definition: constraint rule]

      A constraint rule is a rule that sets a requirement on an artifact with respect to its conformance to a [conformance target].

   [Definition: interpretation rule]

      An interpretation rule is a rule that sets the methodology, pattern, or procedure for understanding using some aspect of an instance of a conformance target.

   Each rule has description of its applicability. This identifies the conformance target to which the rule applies. Each entry in the list is a code from Table Table 4-1, Codes representing conformance targets, below. If a code appears in the applicability list for a rule, then the rule applies to the corresponding conformance target. The conformance targets are defined in Section 4, Conformance targets, below.

   Rules are stated with the help of XML Infoset terminology (elements and attributes), described by Section 3.3, XML Information Set terminology, below, and XML Schema terminology (e.g., schema components), described by Section 3.4, XML Schema terminology, below. The choice of terminology is driven by which terminology best expresses the rule. Certain concepts are more clearly expressed using XML Infoset information items, others using the XML Schema data model; still others are best expressed using a combination of terminology drawn from each standard.

   Rules are numbered according to the section in which they appear and the order in which they appear within that section. For example, Rule 6-1 is the first rule in Section 6.

2.6. Use of normative Schematron

   This document defines many normative rules using Schematron rule-based validation syntax, as defined by [Schematron]. Effort has been made to make the rules precise and unambiguous. Very detailed text descriptions of rules can introduce ambiguity, and they are not directly executable by users. Providing NDR rules that are expressed as Schematron rules ensures that the rules are precise, and that they are directly executable through commercially-available and free tools.

   Many rules herein do not have executable Schematron supporting them. Some are not fit for automatic validation, and others may be difficult or cumbersome to express in Schematron. In neither case are such rules be any less normative. A rule that has no Schematron is just as normative as a rule that does have Schematron.

   The Schematron rules are written using XPath2 as defined by [XPath 2]. These executable rules are normative.

   An execution of a Schematron pattern that issues a failed assert represents a validation error, and signfies that the assessed artifact vioates a requirement of a conformance rule. 

   An execution of a Schematron pattern that issues a report indicates cause for concern. This may be:

      *  An indication that the automated rules are not sufficient to validate a conformance rule, and that another means is required to ensure conformance. This is frequently a reference to another specification.

      *  an indication that an automated rule has found that the assessed artifact violates a recommendation of the specification (e.g., a SHOULD, rather than a MUST), and that attention should be paid to ensure that the artifact maintains the spirit of the specification.

   In either case, the Schematron reporting mechanism may be used to identify specific location within artifacts that need further attention. 

2.7. Normative XPath functions

   The Schematron within this document is supported by functions, to make the rules more comprehensible, and to abstract away process-specific operations. Each function has a normative XPath interface and a normative text definition. Any implementation provided for these functions should be considered informative, not normative, but may be useful for certain implementations of the rules.

   The following XPath functions are defined normatively when used within Schematron by this specification:

      *  nf:get-document-element($context as element()) as element()

         Yields the document element for the XML document in which $context occurs.

         This function provides the ability for a validator to consolidate multiple XML Schema documents and XML instance documents into a single XML document, which may simplify validation, and allow for preprocessing of xs:include elements.

      *  nf:get-target-namespace($element as element()) as xs:anyURI?

         Yields the target namespace of the XML Schema document in which $element appears. If it is an XML Schema document schema with no target namespace defined, then it yields the zero-length xs:anyURI value (xs:anyURI('')). If it is not an XML Schema document, then it yields the empty sequence (()).

      *  nf:resolve-namespace($context as element(), $namespace-uri as xs:anyURI) as element(xs:schema)?

         Yields the first available xs:schema document element that has the target namespace $namespace-uri. If there is no such XML Schema document available, it yields the empty sequence.

      *  nf:resolve-type($context as element(), $qname as xs:QName) as element()?

         Yields the first available occurence of an element xs:simpleType or xs:complexType that has a name matching $qname. If there is no occurrence available, it yields the empty sequence. 

      *  nf:resolve-element($context as element(), $qname as xs:QName) as element(xs:element)?

         Yields the first available occurrence of an element xs:element with a name matching $qname. If there is no occurrence available, it yields the empty sequence.

      *  nf:has-effective-conformance-target-identifier($context as element(), $match as xs:anyURI) as xs:boolean

         Yields true if and only if an [effective conformance target identifier] of the XML document containing $context is $match.

2.8. Normative Schematron namespace declarations

   The following Schematron namespace declarations are normative for the Schematron rules and supporting code within this specification:

   Figure 2-2: Normative Schematron namespace declarations

      <sch:ns prefix="xs" uri="http://www.w3.org/2001/XMLSchema"/>
      <sch:ns prefix="xsl" uri="http://www.w3.org/1999/XSL/Transform"/>
      <sch:ns prefix="nf" uri="http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#NDRFunctions"/>
      <sch:ns prefix="ct" uri="http://release.niem.gov/niem/conformanceTargets/3.0/"/>
      <sch:ns prefix="xsi" uri="http://www.w3.org/2001/XMLSchema-instance"/>
      <sch:ns prefix="appinfo" uri="http://release.niem.gov/niem/appinfo/3.0/"/>
      <sch:ns prefix="structures" uri="http://release.niem.gov/niem/structures/3.0/"/>
      <sch:ns prefix="term" uri="http://release.niem.gov/niem/localTerminology/3.0/"/>

   Note that the binding of the prefix xml to the XML namespace ("http://www.w3.org/XML/1998/namespace") is implicit.

3. Terminology

   This document uses standard terminology to explain the principles and rules that describe NIEM.

3.1. RFC 2119 terminology

   Within normative content (rules and definitions), the key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this document are to be interpreted as described in [RFC 2119].

3.2. XML terminology

   [Definition: XML document]

      The term "XML document" is as defined by [XML] section 2, Documents.

3.3. XML Information Set terminology

   When discussing XML documents, this document uses terminology and language as defined by [XML Infoset].

   [XML Infoset] uses the term "information item" to describe pieces of XML documents. Documents, elements, and attributes are types of information items. The use of the term "element information item", for example, refers to the term as defined by [XML Infoset]. Shorthand terms may also be used to refer to information items, such as "element", as described within this section. The element information items are identified and defined by [XML Infoset] section 2, Information Items.

   [XML Infoset] also describes properties of information items. Each class of information item carries a set of properties. Each property has a name, and the property is identified by putting the name into square brackets. For example, the element that contains an attribute is described as the [owner element] of an attribute information item.

   Shorthand terms for information items include:

      *  element: an element information item

      *  attribute: an attribute information item

      *  document element: the [document element] property of a document information item, preferred over the common term "root element".

   Shorthand terms for properties of information items include:

      *  parent (of an element): the [parent] property of an element information item

      *  child (of an element): a member of the [children] property of an element information item

      *  owner (of an attribute): the [owner element] property of an attribute information item

3.4. XML Schema terminology

   This document uses many terms from [XML Schema Structures] and [XML Schema Datatypes] in a normative way.

   [Definition: schema component]

      The term "schema component" is as defined by [XML Schema Structures] section 2.2, XML Schema Abstract Data Model, which states:

         Schema component is the generic term for the building blocks that comprise the abstract data model of the schema.

   [Definition: XML Schema]

      The term "XML Schema" is as defined by [XML Schema Structures] section 2.2, XML Schema Abstract Data Model, which states:

         An XML Schema is a set of schema components.

   [Definition: base type definition]

      The term "base type definition" is as defined by [XML Schema Structures] section 2.2.1.1, Type Definition Hierarchy.

   [Definition: simple type definition]

      The term "simple type definition" is as defined by [XML Schema Structures] section 2.2.1.2, Simple Type Definition.

   [Definition: complex type definition]

      The term "complex type definition" is as defined by [XML Schema Structures] section 2.2.1.3, Complex Type Definition.

   [Definition: element declaration schema component]

      The term "element declaration" is as defined by [XML Schema Structures] section 2.2.2.1, Element Declaration.

   [Definition: element declaration]

      *  the XML Schema definition language: as described by [XML Schema Structures].

      *  a schema document: as defined by [XML Schema Structures].

      *  valid: as defined by [XML Schema Structures].

      *  an XML Schema document set: a set of schema documents that together define an XML schema suitable for assessing the validity of an XML document.

   In this document, the name of the referenced schema component may appear without the suffix "schema component" (e.g., the term "complex type definition" may be used instead of "complex type definition schema component") to enhance readability of the text.

3.5. XML Namespaces terminology

   This document uses XML Namespaces as defined by [XML Namespaes] and [XML Namespaces Errata].

3.6. Conformance Targets Attribute Specification terminology

   [CTAS] defines several terms used normatively within this specification.

   [Definition: conformance target]

      The term "conformance target" is as defined by [CTAS], which states:

         A conformance target is a class of artifact, such as an interface, protocol, document, platform, process or service, that is the subject of conformance clauses and normative statements. There may be several conformance targets defined within a specification, and these targets may be diverse so as to reflect different aspects of a specification. For example, a protocol message and a protocol engine may be different conformance targets.

   [Definition: conformance target identifier]

      The term "conformance target identifier" is as defined by [CTAS], which states:

         A conformance target identifier is an internationalized resource identifier that uniquely identifies a conformance target.

   [Definition: effective conformance target identifier]

      The term "effective conformance target identifier" is as defined by [CTAS] section 4, Semantics and Use, which states:

         An effective conformance target identifier of a conformant document is an internationalized resource identifier reference that occurs in the document's effective conformance targets attribute.

4. Conformance targets

4.1. Conformance targets defined

   This section defines and describes conformance targets of this specification. Each conformance target has a formal definition, along with a notional description of the characterstics and intent of each. These include:

   * Section 4.1.1, Reference schema document
   * Section 4.1.2, Extension schema document
   * Section 4.1.3, Schema document set
   * Section 4.1.4, Instance documents and elements

4.1.1. Reference schema document

   [Definition: conformant reference schema document]

      A conformant reference schema document is a schema document that is intended to provide the authoritative definitions of broadly reusable data components. It is a conformance target of this specification. A reference schema document MUST conform to all rules of this specification that apply to this conformance target. An XML document with a conformance target identifier of http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument MUST be a conformant reference schema document.

   A conformant reference schema document is a schema document that is intended to be the authoritative definition schema for a namespace. Examples include NIEM Core and NIEM domains.

   Some characteristics of a reference schema document:

      *  It is explicitly designated as a reference schema via the conformance targets attribute (ct:conformanceTargets), as defined by [CTAS].

      *  It provides the broadest, most fundamental definitions of components in its namespace.

      *  It provides the authoritative definition of business semantics for components in its namespace.

      *  It is intended to serve as the basis for components in information exchanges and extension schema documents.

      *  It satisfies all rules specified in the Naming and Design Rules for reference schemas.

   Any schema that defines components that are intended to be incorporated into NIEM Core or a NIEM domain may be defined as a reference schema.

   The rules for reference schema documents are more stringent than are the rules for other classes of NIEM-conformant schemas. Reference schema documents are intended to support the broadest reuse. They are very uniform in their structure. As they are the primary definitions for data components, they do not need to restrict other data definitions, and they are not allowed to use XML Schema's restriction mechanisms. Reference schema documents are intended to be as regular and simple as possible.

4.1.2. Extension schema document

   [Definition: conformant extension schema document]

      A conformant extension schema document is a schema document that is intended to provide definitions of data components that are intended for reuse within a more narrow scope than reference schema documents. It is a conformance target of this specification. An extension schema document MUST conform to all rules of this specification that apply to this conformance target. An XML document with a conformance target identifier of http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument MUST be a conformant reference schema document.

   An extension schema is an XML Schema document that meets all of the following criteria:

      *  It is explicitly designated as an extension schema document via the conformance targets attribute.

      *  It provides the broadest, most fundamental definitions of components in its namespace.

      *  It provides the authoritative definition of business semantics for components in its namespace.

      *  It contains components that, when appropriate, use or are derived from the components in reference schema documents.

      *  It is intended to express the additional vocabulary required for an information exchange, above and beyond the vocabulary available from reference schemas, and to also support additional XML Schema validation requirements for an exchange.

      *  It satisfies all rules specified in the Naming and Design Rules for extension schemas.

   An extension schema in an information exchange specification serves several functions. First, it defines new content within a new namespace, which may be an exchange-specific namespace or a namespace shared by several exchanges. This content is NIEM-conformant but has fewer restrictions on it than do [conformant reference schema documents]. Second, the extension schema document bases its content on content from reference schemas documents, where appropriate. Methods of deriving content include using (by reference) existing components, as well as creating extensions and restrictions of existing components.

   For example, an information exchange specification may define a type for an exchange-specific phone number and base that type on a type defined by the NIEM Core reference schema document. This exchange-specific phone number type may restrict the NIEM Core type to limit those possibilities that are permitted of the base type. Exchange extensions and restrictions must include annotations and documentation to be conformant, but they are allowed to use restriction, choice, and some other constructs that are not allowed in reference schema documents.

   Note that exchange specifications may define schemas that meet the criteria of reference schemas for those components that its developers wish to nominate for later inclusion in NIEM Core or in domains.

4.1.3. Schema document set

   [Definition: conformant schema document set]

      A conformant schema document set is a collection of XML Schema documents that together are capable of validating a conformant instance XML document. It is a conformance target of this specification. A conformant schema document set MUST conform to all rules of this specification that apply to this conformance target.

4.1.4. Instance documents and elements

   This document has specific rules about how NIEM content should be used in XML documents. As well as containing rules for XML Schema documents, this NDR contains rules for NIEM-conformant XML content at a finer granularity than the XML document.

   [Definition: conformant instance XML document]

      A conformant instance XML document is an XML document that is an instance of a conformant schema document set. It is a conformance target of this specification. A conformant instance XML document MUST conform to all rules of this specification that apply to this conformance target.

   A conformant instance XML document is an XML document that satisfies all of the following criteria:

      *  The document element is locally schema-valid.

      *  Each element information item within the XML document that has a namespace name matching the target namespace of a [conformant reference schema document] or [conformant extension schema document] is a [conformant element information item].

   {Just make these term references}

   In this definition and the next definition below, the term XML document is as specified in [XML]. The terms document information item, document element, element information item, namespace name, and local name are as specified in [XML Infoset]. The term valid is as specified in [XML Schema Structures].

   Schema-validity may be assessed against a single set of schemas or against multiple sets of schemas. Assessment against schemas is as directed by an IEPD, other instructions, or tools.

   Note that the document element (root element) of a NIEM-conformant XML document is not required to be a NIEM-conformant element information item. Other specifications, such as the IEPD specification, may add additional constraints to these to specify IEPD or exchange conformance.

   [Definition: conformant element information item]

      A conformant element information item is an element information item that satisfies all of the following criteria:

         *  Its namespace name and local name matches an element declared by a [conformant reference schema document] or [conformant extension schema document].

         *  It occurs within a [conformant instance XML document].

         *  It is locally schema-valid.

         *  It satisfies all rules specified in the Naming and Design Rules for NIEM-conformant element information items.

   Because each NIEM-conformant element information item must be locally schema-valid, each element must validate against the schema definition of the element, even if the element information item is allowed within the document because of a wildcard with processContents of "skip". Within a NIEM-conformant XML document, each element that is from a NIEM namespace conforms to its schema specification.

4.2. Applicability of rules to conformance targets

   Rules within this document are annotated with conformance target codes. Each rule may be annotated with one or more codes for a conformance target. A rule within this document that is annotated with one of the following codes applies to the corresponding conformance target.

   Table 4-1: Codes representing conformance targets

      Code|Conformance target

      REF|conformant reference schema document

      EXT|conformant extension schema document

      SET|Conformant schema document set

      INS|Conformant instance XML document

4.3. Conformance target identifiers

   The term [conformance target identifier] is defined by [CTAS].

4.3.1. Schema is CTAS-conformant

   [Rule 4-1] (REF, EXT)

      <sch:pattern>
        <sch:rule context="*[. is nf:get-document-element(.)]">
          <sch:report test="true()">The document MUST be a conformant document as defined by the NIEM Conformance Targets Attribute Specification.</sch:report>
        </sch:rule>
      </sch:pattern>

   The term "conformant document" is defined by [CTAS] section 3.2, Conformance to this Specification.

4.3.2. Document element has conformanceTargets

   [Rule 4-2] (REF, EXT)

      <sch:pattern>
        <sch:rule context="*[. is nf:get-document-element(.)
                             or exists(@ct:conformanceTargets)]">
          <sch:assert test="(. is nf:get-document-element(.)) = exists(@ct:conformanceTargets)"
            >An element MUST own an attribute {http://release.niem.gov/niem/conformanceTargets/3.0/}conformanceTargets if and only if it is a [document element].</sch:assert>
        </sch:rule>
      </sch:pattern>

   The term "document element" is as described by Section 3.3, XML Information Set terminology, above.

4.3.3. Schema claims reference schema conformance target.

   [Rule 4-3] (REF)

      <sch:pattern>
        <sch:rule context="*[. is nf:get-document-element(.)]">
          <sch:assert test="nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))"
            >The document MUST have an effective conformance target identifier of http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument.</sch:assert>
        </sch:rule>
      </sch:pattern>

4.3.4. Schema claims extension conformance target

   [Rule 4-4] (EXT)

      <sch:pattern>
        <sch:rule context="*[. is nf:get-document-element(.)]">
          <sch:assert test="nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument'))"
            >The document MUST have an effective conformance target identifier of http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument.</sch:assert>
        </sch:rule>
      </sch:pattern>

5. The NIEM conceptual model

   NIEM provides a concrete data model, in the form of a set of XML Schema documents. These schemas may be used to build messages and information exchanges. The schemas spell out what kinds of objects exist and how those objects may be related. XML data that follows the rules of NIEM imply specific meaning. The varieties of XML Schema components used within NIEM-conformant schemas are selected to clarify the meaning of XML data. That is, schema components that do not have a clear meaning have been avoided. NIEM provides a framework within which XML data has a specific meaning.

   One limitation of XML and XML Schema is that they do not describe the meaning of an XML document. The XML specification defines XML documents and defines their syntax but does not address the meaning of those documents. The XML Schema specification defines the XML Schema definition language, which describes the structure and constrains the contents of XML documents (schemas).

   In a schema, the meaning of a schema component (e.g., element, attribute, or type) may be described using the xs:documentation element. Or, additional information may be included via the xs:appinfo element. Although this may enable humans to understand XML data, more information is needed to support the machine-understandable meaning of XML data. In addition, inconsistency among the ways that schema components may be put together may be a source of confusion.

   The RDF Core Working Group of the World Wide Web consortium has developed a simple, consistent conceptual model, the RDF model. The RDF model is described and specified through a set of W3C Recommendations, the Resource Description Framework (RDF) specifications, making it a very well defined standard. The NIEM model and the rules contained in this NDR are based on the RDF model. This provides numerous advantages:

      *  NIEM's conceptual model is defined by a recognized standard.

      *  NIEM's conceptual model is very well defined.

      *  NIEM's conceptual model provides a consistent basis for relating attributes, elements, types, and other XML Schema components.

      *  NIEM's use of the RDF model defines what a set of NIEM data means. The RDF specification provides a detailed description of what a statement means. See [RDF Semantics] section 1.3, Intepretations. This meaning is leveraged by NIEM.

      *  NIEM's use of the RDF model provides a basis for inferencing and reasoning about XML data that uses NIEM. That is, using the rules defined for the RDF model, programs can determine implications of relationships between NIEM-defined objects.

   With the exception of Section 2, NIEM rules are explained in this document without reference to RDF or RDF concepts. Understanding RDF is not required to understand NIEM-conformant schemas or data based on NIEM. However, understanding RDF concepts may deepen understanding of NIEM.

   The goal of this section is to clarify the meaning of XML data that is NIEM-conformant and to outline the implications of various modeling constructs in NIEM. The rules for NIEM- conformant schemas and instances are in place to ensure that a specific meaning can be derived from data. That is, the data makes specific assertions, which are well understood since they are derived from the rules for NIEM.

   The key concepts underpinning the NIEM conceptual model are discussed in the remainder of this section:

      *  NIEM and the RDF Model

      *  NIEM Properties

      *  Unique Identification of Data Objects

      *  NIEM Data Model Is Explicit, Not Implicit

      *  NIEM Data Model Implementation in XML Schema

5.1. NIEM and the RDF model

   NIEM has its foundation in the RDF model. This helps to ensure that NIEM-conformant data has precise meaning. The RDF view of what data means is clarified by [RDF Semantics]:

      ...asserting a sentence makes a claim about the world...an assertion amounts to stating a constraint on the possible ways the world might be.

   The RDF view of the meaning of data carries into NIEM: NIEM elements form statements that make claims about the world: that a person has a name, a residence location, a spouse, etc. The assertion of one set of facts does not necessarily rule out other statements: A person could have multiple names, could have moved, or could be divorced. Each statement is a claim asserted to be true by the originator of the statement.

   This NDR discusses NIEM data in terms of objects, a term more accessible than the word used by RDF, resources. RDF defines the world in terms of resources. [RDF Semantics] describes what may constitute a resource:

      ...no assumptions are made here about the nature of resources; "resource" is treated here as synonymous with "entity", i.e., as a generic term for anything in the universe of discourse.

   RDF resources coincide with NIEM objects and associations. That is, both objects and associations in NIEM are RDF resources with the additional constraints:

      *  A NIEM object or association is an instance of a complex type defined by an XML Schema document.

      *  The XML Schema document that defines a NIEM object is a NIEM-conformant schema.

   NIEM associations are defined as n-ary properties, as described in [N-ary], "Use Case 3: N-ary relation with no distinguished participant". NIEM defines the terms [object type], [association type]NIEM associations are defined in Section 7.4.3, Association Types. Assertions are made via NIEM-conformant XML data, described by Section 8, XML Instance Rules.

   The XML Schema types that define NIEM objects and associations are related to each other via elements and attributes. That is, a type contains elements and attributes, and an element or attribute has a value that is an instance of an XML Schema type. In NIEM, these elements and attributes are XML Schema representations of RDF properties, which are described by [RDF Primer], "2.1 Basic Concepts":

      "RDF is based on the idea that the things being described have properties which have values, and that resources can be described by making statements...that specify those properties and values."

   This describes how NIEM works: schemas describe things and their properties. NIEM- conformant data specifies objects, the values of their properties, and the relationships between them.

   There are several kinds of assertions that may be made with NIEM-conformant data. Examples include:

      *  An assertion that an object exists. An occurrence of an element commonly establishes the existence of an object. Such an object may be tangible or intangible. For example, the element nc:Person in an exchange implies that a person does or did exist. An element may also express that an object does not exist (e.g., the license plate ABC123 was never issued), but this is an uncommon case.

         Descriptions of objects may carry an implicit assumption that objects exist. Such an assumption is dependent on the message in which such descriptions are made. If an object that is described does not exist, it should be made explicit in the definition of an element containing or referring to the object.

      *  An assertion that an object has a characteristic. A feature or quality of an object is commonly represented by an element appearing within the element that establishes the object. For example, the height of a person is described by the nc:PersonHeightMeasure element. The nc:PersonHeightMeasure element occurs as XML content of the nc:Person element. In some cases, a characteristic may be represented by an attribute owned by an element.

      *  An assertion that an object participates in a relationship. A relationship between objects may be established in any of several ways:

            *  Both objects may be referenced from an association that establishes the relationship. Associations are also useful for expressing n-ary relationships, as well as relationships supported by additional data.

            *  An element may occur within one object that indicates the relationship with the other object. This element may be either a content element or a reference element.

         The NIEM Core schema and some domain schemas have been normalized such that a minimum number of reference or content elements establish relationships. In these cases, use of an association is the more common method for establishing a relationship. However, in an exchange, using a reference or content element to express a relationship may be the simpler, preferred method for expressing a relationship.

5.2. NIEM properties

   NIEM-conformant data describes characteristics of objects and relationships between objects. In RDF, these characteristics and relationships are called properties of objects, which is also how NIEM refers to them. NIEM represents properties with element declarations and attribute declarations.

   Within data, a property relates XML data much as a verb relates nouns in a sentence: a verb has a subject and an object.

      *  The property itself: What relationship is being asserted? For example, the property may say that a weapon has a user, or that someone has hair of a particular color.

      *  The subject: About what object is the property being asserted? This would be the weapon that has the user, or the person whose hair is being described.

      *  The object: What is the value of the property, or with what other object does the relationship exist? This would be the person who is the user of the weapon or the person whose hair has the color brown.

   A property relates two objects. Data will describe an object having a characteristic with a specific value or will describe an object with a particular relationship to another object. All properties are pair-wise: between two objects, or between an object and a value.

   In theory, any relationship that involves more than two objects may be modeled as a set of binary properties. In NIEM, such relationships may be expressed either as a set of properties (i.e., as element and attribute declarations) or as a complex type defining an association.

5.3. Unique identification of data objects

   In NIEM, an exchange is generally adhoc. That is, a message may be generated without any persistence. It exists only to exchange data and may not have any universal meaning beyond that specific exchange. As such, a message may or may not have a URI as an identifier. NIEM was designed with the assumption that a given exchange need not have any unique identifier; NIEM does not require a unique identifier. NIEM also does not require any object (data instance) to be identified by a URI. This differs from RDF, in which all entities (other than literal values) are identified by globally meaningful URIs.

   A NIEM-conformant instance uses XML IDs to identify objects within an XML document; The NIEM XML ID is an attribute structures:id of type xs:ID. These IDs are not assumed by NIEM to have any universal significance; they need only be unique within the XML document. The use of an ID is required only when an object must be referenced within the document. NIEM recognizes no correlation between these local IDs and any URI.

   Any given implementation, message, or IEPD may be defined to apply a URI or other universally meaningful identifier to an object or message. However, NIEM has no such requirement.

5.4. NIEM data model is explicit, not implicit

   In NIEM data, that which is not stated is not implied. If data says a person's name is "John," it is not implicitly saying that he does not have other names, or that "John" is his legal name, or that he is different from a person known as "Bob." The only assertion being made is that one of the names by which this person is known is "John".

   This is one reason that definitions of NIEM content are so important. The definitions must state exactly what any given statement implies. The concept of "legal name" may be defined that makes additional assertions about a name of a person. Such assertions must be made explicit in the definition of the relationship.

5.5. NIEM data model implementation in XML Schema

   NIEM defines rules for XML Schema documents that enforce the NIEM conceptual model. The schemas that follow these rules are referred to as NIEM-conformant schemas.

   As discussed above, NIEM classes and properties are mapped onto XML Schema components. The following is an example of how a NIEM class for a person is rendered as an XML Schema complex type definition:

   Figure 5-1: Conceptual class rendered as XML Schema complex type

      <xs:complexType name="PersonType">
        <xs:annotation>
          <xs:documentation>A data type for a human being.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
          <xs:extension base="structures:ObjectType">
            <xs:sequence>
              <xs:element ref="nc:PersonBirthDate" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="nc:PersonBirthLocation" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="nc:PersonHeightMeasure" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="nc:PersonName" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="nc:PersonRace" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="nc:PersonSex" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="nc:PersonWeightMeasure" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:extension>
        </xs:complexContent>
      </xs:complexType>

   Note that the complex type definition incorporates not only the class itself, but also identifies properties that have a range (e.g., rdfs:range) of the class.

   The following is an example of how a property for a conveyance operator is rendered as a NIEM element declaration:

   Figure 5-2: Conceptual property rendered as element declaration

      <xs:element name="ConveyanceOperator" type="nc:PersonType" nillable="true">
        <xs:annotation>
          <xs:documentation>A person who operates or drives a conveyance.</xs:documentation>
        </xs:annotation>
      </xs:element>

   NIEM also defines rules for XML documents that enforce the NIEM conceptual model. An XML document is a [conformant instance XML document] if it follows the rules specified by the NIEM-conformant schema, as well as additional rules that are NIEM-specific. For example, in a NIEM-conformant XML document, a reference (structures:ref) must refer to a data element that is of an appropriate XML Schema type. If this is not the case, the document may be valid according to the schema, but it will not be a [conformant instance XML document].

6. Guiding principles

   Principles in this specification provide a foundation for the rules. These principles are generally applicable in most cases. They should not be used as a replacement for common sense or appropriate special cases.

   The principles are not operationally enforceable; they do not specify constraints on XML Schema documents and instances. The rules are the normative and enforceable manifestation of the principles.

   The principles discussed in this section are categorized as follows:

      *  Specification Guidelines

      *  XML Schema Design Guidelines

      *  Modeling Design Guidelines

      *  Implementation Guidelines

6.1. Specification guidelines

   The principles in this section address what material should be included in this NDR and how it should be represented.

6.1.1. Keep specification to a minimum

   This specification should state what is required for interoperability, not all that could be specified. Certain decisions (such as normative XML comments) could create roadblocks for interoperability, making heavy demands on systems for very little gain. The goal is not standardization for standardization's sake. The goal is to maximize interoperability and reuse.

   [Principle 1]

      This specification SHOULD specify what is necessary for semantic interoperability and no more.

   The term semantic interoperability is here defined as "the ability of two or more computer systems to exchange information and have the meaning of that information automatically interpreted by the receiving system accurately enough to produce useful results." 

6.1.2. Focus on rules for schemas

   This specification should try, as much as is possible, to specify schema-level content. This is a specification for schemas, and so it should specify schemas. It should avoid specifying complex data models or data dictionaries.

   [Principle 2]

      This specification SHOULD focus on providing rules for specifying schemas.

6.1.3. Use specific, concise rules

   A rule should be as precise and specific as possible to avoid broad, hard-to-modify rules. Putting multiple clauses in a rule makes it harder to enforce. Using separate rules allows specific conditions to be clearly stated.

   [Principle 3]

      This specification SHOULD feature rules thatare as specific, precise, and concise as possible.

6.2. XML Schema design guidelines

   The principles in this section address how XML Schema technology should be used in designing NIEM-conformant schemas and instances.

6.2.1. Disallow content modification with XML processors

   XML Schema has constructs that can make the data provided by XML processors different before and after schema processing. Anexample of this is the use of XML Schema attribute declarations with default values. Before schema validation, there may be no attribute value, but after processing, the attribute value exists.

   Within NIEM, the purpose of processing instances against schemas is solely validation: testing that data instances match desired constraints and guidelines. It should not be used to change the content of data instances.

   [Principle 4]

      The content of a NIEM-conformant data instance SHOULD NOT be modified by processing against XML Schema documents.

6.2.2. Use XML validating parsers for content validation

   NIEM is designed for XML Schema validation. A primary goal is to maximize the amount of validation that may be performed by XML Schema-validating parsers.

   XML Schema validates content using content models: descriptions of what elements and attributes may be contained within an element, and what values are allowable. It is the XML element hierarchy (elements with attributes and unstructured content, contained by other elements) that the XML Schema definition language specifies and that XML Schema validating parsers can validate.

   Mechanisms involving linking using attribute and element values are useful, but they should only be relied on when absolutely necessary, as XML Schema-validating parsers cannot readily validate them. For example, if a link is established via attribute values, an XML Schema- validating parser cannot determine that participants have appropriate type definitions. Whenever possible, NIEM content should rely on XML syntax that can be validated with XML Schema.

   [Principle 5]

      NIEM-conformant schemas and NIEM-conformant XML documents SHOULD use XML Schema validating parsers for validation of XML content.

6.2.3. Validate for conformance to reference schemas

   Systems that operate on XML data have the opportunity to perform multiple layers of processing. Middleware, XML libraries, schemas, and application software may process data. The primary purpose of XML Schema validation is to restrict processed data to that data that conforms to agreed-upon rules. This restriction is achieved by marking as invalid that data that does not conform to the rules defined by the schema.

   [Principle 6]

      Systems that use NIEM-conformant data SHOULD mark as invalid data that does not conform to the rules defined by applicable XML Schema documents.

6.2.4. Allow multiple schemas for XML constraints

   The NIEM does not attempt to create a one-size-fits-all schema to perform all validation. Instead, it creates a set of reference schemas, on which additional constraints may be placed. It also does not focus on language-binding XML Schema implementations, which convert XML Schema definitions into working programs. It is, instead, focused on normalizing language and preserving the meaning of data.

   [Principle 7]

      Constraints on XML instances MAY be validated by multiple schema validation passes, using multiple schemas for a single namespace.

6.2.5. Define one reference schema per namespace

   NIEM uses the concept of a reference schema, which defines the structure and content of a namespace. For each NIEM-conformant namespace, there is exactly one NIEM reference schema. A user may use a subset schema or constraint schema in place of a reference schema, but all NIEM-conformant XML documents must validate against a single reference schema for each namespace.

   [Principle 8]

      Each NIEM-conformant namespace SHOULD be defined by exactly one reference schema.

6.2.6. Disallow mixed content

   XML data that use mixed content are difficult to specify and complicate the task of data processing. Much of the payload carried by mixed content is unchecked and does not facilitate data standardization or validation.

   [Principle 9]

      NIEM-conformant schemas SHOULD NOT specify data that uses mixed content.

6.2.7. Specify types for all constructs

   Schema components within NIEM all have names. This means that there are no anonymous types, elements, or other components defined by NIEM. Once an application has determined the name (i.e., namespace and local name) of an attribute or element used in NIEM-conformant instances, it will also know the type of that attribute or element.

   There are no local attributes or elements defined by NIEM, only global attributes and elements. This maximizes the ability of application developers to extend, restrict, or otherwise derive definitions of local components from NIEM-conformant components. Using named global components in schemas maximizes the capacity for reuse.

   [Principle 10]

      NIEM-conformant schemas SHOULD NOT use or define local or anonymous components, as they adversely affect reuse.

6.2.8. Avoid wildcards in reference schemas

   Wildcards in NIEM-conformant schemas work in opposition to standardization. The goal of creating harmonized, standard schemas is to standardize definitions of data. The use of wildcard mechanisms (such as xs:any, which allows insertion of an arbitrary number of elements from any namespace) allows nonstandard data to be passed via otherwise standardized exchanges.

   Avoidance of wildcards in the standard schemas encourages the separation of standardized and nonstandardized data. It encourages users to incorporate their data into NIEM in a standardized way. It also encourages users to extend in a way that may be readily incorporated into NIEM.

   [Principle 11]

      NIEM-conformant components SHOULD NOT incorporate wildcards unless absolutely necessary, as they hinder standardization by encouraging use of nonstandardized data rather than standardized data.

6.2.9. Provide default reference schema locations

    [XML Schema Structures] provides three ways to specify the physical location of an XML Schema document: schemaLocation, an attribute of the element xs:import, along with xsi:schemaLocation and xsi:noNamespaceSchemaLocation, attributes of an XML Schema document element. In all of these uses, the specification explicitly maintains that the schema location specified is a hint, which may be overridden by applications.

   [Principle 12]

      Schema locations specified within NIEM-conformant reference schemas SHOULD be interpreted as hints and as default values by processing applications.

6.2.10. Use open standards

   The cooperative efforts of many knowledgeable individuals have resulted in many important published information standards. Where appropriate and applicable, NIEM ought to leverage these standards.

   [Principle 13]

      NIEM standards and schemas SHOULD leverage and enable use of other open standards.

6.3. Modeling design guidelines

   The principles in this section address the design philosophy used in designing the NIEM conceptual model.

6.3.1. Namespaces enhance reuse

   NIEM is designed to maximize reuse of namespaces and the schemas that define them. When referring to a concept defined by NIEM, a user should ensure that instances and schemas refer to the namespace defined by NIEM. User-defined namespaces should be used for specializations and extension of NIEM constructs but should not be used when the NIEM structures are sufficient.

   [Principle 14]

      NIEM-conformant instances and schemas SHOULD reuse components from NIEM distribution schemas when possible.

   NIEM relies heavily on XML namespaces to prevent naming conflicts and clashes. Reuse of any component is always by reference to both its namespace and its local name. All NIEM component names have global scope. Therefore, validation always occurs against the reference schemas or subsets thereof.

   Example:

   Figure 6-1: Example of the use of a namespace

      <xsd:element ref="nc:BinaryCaptureDate" minOccurs="0" maxOccurs="unbounded"/>

   In this example, nc:BinaryCaptureDate is reused by referencing its element declaration through both its namespace (which is bound to the prefix nc:) and its local name (BinaryCaptureDate). If an element named BinaryCaptureDate is declared in another namespace, it is an entirely different element than nc:BinaryCaptureDate. There is no implicit relationship to nc:BinaryCaptureDate.

   From a business perspective, the two elements are likely to be related in the sense that they may have very similar semantic meanings. They may have essentially the same meaning, but slightly different properties. Such a relationship may commonly exist. However, any relationship between the two elements must be made explicit using methods outlined in this document.

   [Principle 15]

      A component SHOULD be identified by its local name together with its namespace. A namespace SHOULD be a required part of the name of a component. A component's local name SHOULD NOT imply a relationship to components with similar names from other namespaces.

6.3.2. Design NIEM for extensibility

   NIEM is designed to be extended. Numerous methods are considered acceptable in creating extended and specialized components.

   [Principle 16]

      NIEM-conformant schemas and standards SHOULD be designed to encourage and ease extension and augmentation by users and developers outside the standardization process.

6.4. Implementation guidelines

   The principles in this section address issues pertaining to the implementation of applications that use NIEM.

6.4.1. Avoid displaying raw XML data

   XML data should be made human-understandable when possible, but it is not targeted at human consumers. HTML is intended for browsers. Browsers and similar technology provide human interfaces to XML and other structured content. As such, structured XML content does not belong in places targeting humans. Human-targeted information should be of a form suitable for presentation.

   [Principle 17]

      XML data SHOULD be designed for automatic processing. XML data SHOULD NOT be designed for literal presentation to people. NIEM standards and schemas SHOULD NOT use literal presentation to people as a design criterion.

6.4.2. Leave implementation decisions to implementers

   NIEM is intended to be an open specification supported by many diverse implementations. It was designed from data requirements and not from or for any particular system or implementation. Use of NIEM should not depend on specific software, other than XML Schema-validating parsers.

   [Principle 18]

      NIEM SHOULD NOT depend on specific software packages, software frameworks, or software systems for interpretation of XML instances.

   [Principle 19]

      NIEM schemas and standards SHOULD be designed such that software systems that use NIEM may be built with a variety of off-the-shelf and free software products.

6.5. Modeling guidelines

   The NIEM Naming and Design Rules (NDR) specify NIEM-conformant components, schemas, and instances. These guidelines influence and shape the more-specific principles and rules in this document. They are derived from best practices and from discussions within the NIEM Business Architecture Committee (NBAC) and the NIEM Technical Architecture Committee (NTAC). This list may grow and evolve as NIEM matures.

   The principles in this section address decisions that data modelers must face when creating NIEM-conformant schema representations of domain data. These guidelines are not absolute (the key word is SHOULD). It may not be possible to apply all guidelines in every case. However, they should always be considered.

6.5.1. Documentation

   As will be described in later sections of this document, all NIEM components are documented through their definitions and names. Although it is often very difficult to apply, a data component definition should be drafted before the data component name is finalized.

   Drafting the definition for a data component first ensures that the author understands the exact nature of the entity or concept that the data component represents. The component name should subsequently be composed to summarize the definition. Reversing this sequence often results in [data definitions] that very precisely describe the component name but do not adequately describe the entity or concept that the component is designed to represent. This can lead to the ambiguous use of such components.

   [Principle 20]

      A data component definition SHOULD be drafted before the associated data element name is composed.

6.5.2. Consistent naming

   Components in NIEM should be given names that are consistent with names of other NIEM components. Having consistent names for components has several advantages:

      1. It is easier to determine the nature of a component when it has a name that conveys the meaning and use of the component.

      2. It is easier to find a component when it is named predictably.

      3. It is easier to create a name for a component when clear guidelines exist.

   [Principle 21]

      Components in NIEM SHOULD be given names that are consistent with names of other NIEM components. Such names SHOULD be based on simple rules.

6.5.3. Reflect the real world

   NIEM provides a standard for data exchange. To help facilitate unambiguous understanding of NIEM reusable components, the names and structures should represent and model the informational aspects of objects and concepts that users are most familiar with. Types should not simply model collections of data.

   [Principle 22]

      Component definitions in NIEM-conformant schemas SHOULD reflect real-world concepts.

6.5.4. Be consistent

   There should be no conflicts of meaning among types. This holds for types within a namespace, as well as types in different namespaces. A type should be used consistently in similar situations for similar purposes. Types should be defined for clear understanding and ease of intended use.

   [Principle 23]

      Component definitions in NIEM-conformant schemas SHOULD have semantic consistency.

6.5.5. Reserve inheritance for specialization

   Specialization should not be applied simply for the sake of achieving property inheritance. Specialization should be applied only where it is meaningful and appropriate to model permanent sibling subclasses of a base class that are mutually exclusive of one another.

   [Principle 24]

      Complex type definitions in NIEM-conformant schemas SHOULD use type inheritance only for specialization.

   Note that application of type augmentations is a well-defined exception to this guideline.

6.5.6. Do not duplicate definitions

   A real-world entity should be modeled in only one way. The definition of a type or element should appear once and only once. Multiple components of identical or closely similar semantics hinder interoperability because too many valid methods exist for representing the same data. For each data concept that must be represented, there should be only one component (and associated type) to represent it.

   Components with very similar semantics may exist in different contexts. For example, a complex type created for a particular exchange may appear to have identical or closely similar semantics to a complex type defined in the NIEM Core schema. However, the type defined at the exchange level will have much more precise business requirements and syntax, compared with the broad definitions that are heavily reused. Specific contextual definitions should be considered semantic changes. This includes the application of augmentations to create a specialized type for a specific use.

   Two components may have the same definition while having different representations. For example, a string may hold the complete name of a person, or the name may be represented by a structure that separates the components of the name into first, last, etc. The definition of alternative representations should not be considered duplication.

   [Principle 25]

      Multiple components with identical or undifferentiated semantics SHOULD NOT be defined. Component definitions SHOULD have clear, explicit distinctions.

6.5.7. Keep it simple

   All NIEM content and structure is fundamentally based on business requirements for information exchange. To encourage adoption and use in practice, NIEM must implement business requirements in simple, consistent, practical ways.

   [Principle 26]

      NIEM-conformant schemas SHOULD have the simplest possible structure, content, and architecture consistent with real business requirements.

6.5.8. Be aware of scope

   The scope of components defined in NIEM-conformant schemas should be carefully considered. Some components represent simple data values, while others represent complex objects with many parts and relationships. Components should exist in layers. Components should exist as small, narrowly scoped, atomic entities that are used to consistently construct more broadly scoped, complex components (and so on).

   [Principle 27]

      Components defined by NIEM-conformant schemas SHOULD be defined appropriate for their scope.

6.5.9. Be mindful of namespace cohesion

   Namespaces should maximize cohesion. The namespace methodology helps prevent name clashes among communities or domains that have different business perspectives and may choose identical data names to represent different data concepts. A namespace should be designed so that its components are consistent, may be used together, and may be updated at the same time.

   [Principle 28]

      XML namespaces defined by NIEM-conformant schemas SHOULD encapsulate data components that are coherent, consistent, and internally related as a set. A namespace SHOULD encapsulate components that tend to change together.

7. Conformance to standards

7.1. Conformance to XML

   [Rule 7-1] (REF, EXT, INS)

      <sch:pattern>
        <sch:rule context="*[. is nf:get-document-element(.)]">
          <sch:report test="true()">The document MUST be a well-formed XML document, as defined by Extensible Markup Language.</sch:report>
        </sch:rule>
      </sch:pattern>

   See [XML] for the normative definition of well-formed XML document.

7.2. Conformance to XML Namespaces

   [Rule 7-2] (REF, EXT, INS)

      <sch:pattern>
        <sch:rule context="*[. is nf:get-document-element(.)]">
          <sch:report test="true()">The document MUST be namespace-well-formed.</sch:report>
        </sch:rule>
      </sch:pattern>            

   The term namespace-well-formed is normatively defined by [XML Namespaes] and [XML Namespaces Errata].

   [Rule 7-3] (REF, EXT, INS)

      <sch:pattern>
        <sch:rule context="*[. is nf:get-document-element(.)]">
          <sch:report test="true()">The document MUST be namespace-valid.</sch:report>
        </sch:rule>
      </sch:pattern>            

   The term namespace-valid is normatively defined by [XML Namespaes] and [XML Namespaces Errata].

7.3. Conformance to XML Schema

   [Rule 7-4] (REF, EXT)

      <sch:pattern>
        <sch:rule context="*[. is nf:get-document-element(.)]">
          <sch:report test="true()">The document MUST be a schema document.</sch:report>
          <sch:assert test="self::xs:schema"
            >The document element of the XML document must be xs:schema.</sch:assert>
        </sch:rule>
      </sch:pattern>            

   The term schema document is defined by [XML Schema Structures].

7.4. ISO 11179 Part 4

   Good data definitions are fundamental to data interoperability. You cannot effectively exchange what you cannot understand. NIEM employs the guidance of [ISO 11179-4] as a baseline for its data component definitions. [ISO 11179-4] All NIEM components are documented.

   To advance the goal of creating semantically rich NIEM-conformant schemas, it is necessary that data definitions be descriptive, meaningful, and precise. [ISO 11179-4] provides standard structure and rules for defining data definitions. NIEM uses this standard for component definitions.

   Note that the metadata maintained for each NIEM component contains additional details, including domain-specific usage examples and keywords. Such metadata is used to enhance search and discovery of components in a registry, and therefore, is not included in schemas.

   For convenience and reference, the summary requirements and recommendations in [ISO 11179-4] are reproduced here:

      ISO 11179 Requirements

      A data definition SHALL:

         *  Be stated in the singular.

         *  State what the concept is, not only what it is not.

         *  Be stated as a descriptive phrase or sentence(s).

         *  Contain only commonly understood abbreviations.

         *  Be expressed without embedding definitions of other data or underlying concepts.

      ISO 11179 Recommendations

      A data definition SHOULD:

         *  State the essential meaning of the concept.

         *  Be precise and unambiguous.

         *  Be concise.

         *  Be able to stand alone.

         *  Be expressed without embedding rationale, functional usage, or procedural information.

         *  Avoid circular reasoning.

         *  Use the same terminology and consistent logical structure for related definitions.

         *  Be appropriate for the type of metadata item being defined.

   In addition to the requirements and recommendations of [ISO 11179-4], NIEM applies additional rules to data definitions. These rules are detailed in Section 11.4.1, Human-readable documentation, below.

   These definitions leverage the term "definition" as defined by [ISO 11179-4]:

      representation of a concept by a descriptive statement which serves to differentiate it from related concepts

   [Definition: data definition]

      The data definition of a schema component is the content of the first occurrence of the element xs:documentation that is an immediate child of an occurrence of an element xs:annotation that is an immediate child of the element that defines the component.

   [Definition: documented component]

      In a NIEM-conformant schema, a documented component is an XML Schema component that has an associated [data definition]. Each documented component has a textual definition, so that the component may be well-understood.

   An example of a data definition is provided in Figure 7-1, Example of data definition of element nc:Activity, below.

   Figure 7-1: Example of data definition of element nc:Activity

      <xs:element name="Activity" type="nc:ActivityType" nillable="true">
        <xs:annotation>
          <xs:documentation>A single or set of related actions, events, or process steps.</xs:documentation>
        </xs:annotation>
      </xs:element>

   See [Rule 11-29], below, and [Rule 11-30], below, for application of [ISO 11179-4] to constrain NIEM [data definitions].

7.5. ISO 11179 Part 5

   Names are a simple but incomplete means of providing semantics to data components. Data definitions, structure, and context help to fill the gap left by the limitations of naming. The goals for data component names should be syntactic consistency, semantic precision, and simplicity. In many cases, these goals conflict and it is sometimes necessary to compromise or to allow exceptions to ensure clarity and understanding. To the extent possible, NIEM applies [ISO 11179-5] to construct NIEM data component names.

   The set of NIEM data components is a collection of data representations for real-world objects and concepts, along with their associated properties and relationships. Thus, names for these components would consist of the terms (words) for object classes or that describe object classes, their characteristic properties, subparts, and relationships.

7.5.1. Component names follow ISO 11179 Part 5 Annex A

   [Rule 7-5] (REF, EXT)

      A NIEM component name SHALL be formed by applying the informative guidelines and examples detailed in Annex A of [ISO 11179-5], with exceptions as specified in this document, most notably those specified in Section 9, Naming Rules.

   The guidelines and examples of [ISO 11179-5] provide a simple, consistent syntax for data names that captures context and thereby imparts a reasonable degree of semantic precision.

   NIEM uses the guidelines and examples of [ISO 11179-5] as a baseline for normative naming rules. However, some NIEM components require bending of these rules. Special naming rules for these classes of components are presented and discussed in Section 9. In spite of these exceptions, most NIEM component names can be disassembled into their [ISO 11179-5] constituent words or terms.

   Example:

   The NIEM component name AircraftFuselageColorCode disassembles as follows:

      *  Object class term = "Aircraft"

      *  Qualifier term = "Fuselage"

      *  Property term = "Color"

      *  Representation term = "Code"

   Section 9, Naming Rules, details the specific rules for each kind of term and how to construct NIEM component names from it. Exceptions for special components are also described in Section 9.

8. Strategy for a NIEM profile of XML Schema

8.1. Wildcards

   There are many constructs within XML Schema that act as wildcards. That is, they introduce buckets that may carry arbitrary or otherwise nonvalidated content. Such constructs violate [Principle 11], and as such provide implicit workarounds for the difficult task of agreeing on the content of data models. Such workarounds should be made explicitly, outside the core data model.

   The following restrictions help to ban wildcards and arbitrary data:

      *  Use of the type xs:anyType is prohibited.

      *  Use of the type xs:anySimpleType is prohibited in most cases.

      *  Use of the element xs:any is prohibited in reference schemas.

      *  Use of the element xs:anyAttribute is prohibited in reference schemas.

8.2. Components are globally reusable

   Each component defined by a NIEM-conformant schema may be reused from outside the schema document. Every NIEM component has a name. That is, type definitions, and element and attribute declarations are given explicit names; local and anonymous component definition is not allowed.

   This is supported by the following restrictions:

      *  Each declaration of an element, attribute, or type is a top-level component (child of xs:schema, rather than a local component defined within another component.

      *  There are no anonymous type declarations.

   Additional restrictions ensure that NIEM components are also defined such that new components may be derived from them and substituted for them. Reference schemas are defined to maximize reuse, while extension schemas are defined to enable a developer to customize schema definitions to match her exchange needs. In reference schemas, the following restrictions help enforce reusability through extension and substitution:

      *  A [conformant reference schema document] or [conformant extension schema document] may not use blockDefault or finalDefault.

      *  Element and type declarations in a [conformant reference schema document] may not use block or final.

   {Add, to the above, cross-references to specific rules}

8.3. Avoid recursive model groups

   XML Schema provides the capability for model groups to be recursively defined. This means that a sequence may contain a sequence, and a choice may contain a choice. These rules are designed to keep content models simple, comprehensive, and reusable: The content of an element should boil down to a simple list of elements, defined in as straightforward a manner as is possible to meet requirements.

8.4. Ensure schema processing does not alter processed data

   XML Schema provides the capability for element and attribute declarations to provide default values when XML instances using those components do not provide values. This is done through the use of the attributes default and fixed, both of which provide default values to attributes and element content.

   The use of default values means that the act of validating a schema will insert a value into an XML instance where none existed prior to schema validation. Schema validation is for rejection of invalid instances, not for modifying instance content, as specified in [Principle 4].

   The transparency of validation to data content is ensured through a prohibition on the use of default and fixed attributes in NIEM-conformant schema documents.

8.5. Use namespaces rigorously

   Require that every component defined by or used in a NIEM schema has a target namespace.

   XML Schema requires that namespaces used in external references be imported using the xs:import element. The xs:import element appears as an immediate child of the xs:schema element. A schema must import any namespace which is not the local namespace, and which is referenced from the schema.

   The behavior of import statements is not necessarily intuitive. In short, the import introduces namespace into the schema in which the import appears; it has no transitive effect. If the namespaces of an import statement are not referenced from the schema, then the import statement has no effect. 

   Certain tools have been seen introducing transitive behavior on imports, which is not portable across XML Schema validating parsers. If namespace 1 imports namespace 2 which imports namespace 3, a reference from namespace 1 to namespace 3 is not legal; namespace 1 must explicitly import namespace 3. A tool that imports transitively may allow schema 1 to reference 3 without a direct import of namespace 3. This is prohibited by rules which require imports of namespaces of referenced components.

8.6. Documentation is for people; appinfo is for machines

   The XML Schema specification defines two types of annotations: user information and application information. It defines that user information is for human consumption, while application information is for automatic processing. 

   Annotations in XML Schema "provide for human- and machine-targeted annotations of schema components." [XML Schema Structures] The two types: human-targeted and machine-targeted, are kept separate by the use of two separate container elements defined by XML Schema: xs:documentation and xs:appinfo.

   XML Schema describes the content of xs:documentation elements as "user information." This information is targeted for reading by humans. The XML Schema specification does not say what form human-targeted information should take. Within NIEM, user information is plain text with no formatting or XML structure.

   According to the XML Schema specification, the content of xs:documentation elements is intended for human consumption, whereas other structured XML content is intended for machine consumption. Therefore, the xs:documentation element MUST NOT contain structured XML data. As such, any XML content appearing within a documentation element is in the context of human-targeted examples and should be escaped using &lt; and &gt;. This rule also prohibits comments within documentation elements.

   XML comments are not XML Schema constructs and are not specifically associated with any schema-based components. As such, comments are not considered semantically meaningful by NIEM and may not be retained through processing of NIEM schemas.

9. Rules for a NIEM profile of XML Schema

   NIEM-conformant schemas use a profile of XML Schema. The W3C XML Schema Language provides many features that allow a developer to represent a data model many different ways. A number of XML Schema constructs are not used within NIEM-conformant schemas. Many of these constructs provide capability that is not currently needed within NIEM. Some of these constructs create problems for interoperability, with tool support, or with clarity or precision of data model definition.

   This section establishes a profile of XML Schema for NIEM-conformant schemas. Because the XML Schema specifications are flexible, comprehensive rules are needed to achieve a balance between establishing uniform schema design and providing developers flexibility to solve novel data modeling problems.

   Note that external schemas (i.e., non-NIEM-conformant schemas) do not need to obey the rules set forth in this section. So long as schema components from external schemas are adapted for use with NIEM according to the modeling rules in Section 7.7, they may be used as they appear in the external standard, even if the schema components themselves violate the rules for NIEM-conformant schemas.

   The following sections are broken down in the order provided by [XML Schema Structures] section 2.2, XML Schema Abstract Data Model, followed by a section on a schema document as a whole and a section on schema namespaces and assembly:

   * Section 9.1, Type definition components
   * Section 9.2, Declaration components
   * Section 9.3, Model group components
   * Section 9.4, Identity-constraint definition components
   * Section 9.5, Group definition components
   * Section 9.6, Annotation components
   * Section 9.7, Schema as a whole
   * Section 9.8, Schema assembly

   {add issue about requiring imports of referenced components}

9.1. Type definition components

9.1.1. Type definition hierarchy

9.1.1.1. Types prohibited as base types

9.1.1.1.1. No base type of xs:ID

   [Rule 9-1] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@base)]">
          <sch:assert test="resolve-QName(@base, .) != xs:QName('xs:ID')"
            >A schema component MUST NOT have an attribute {}base with a value of xs:ID.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.1.1.2. No base type of xs:IDREF

   [Rule 9-2] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@base)]">
          <sch:assert test="resolve-QName(@base, .) != xs:QName('xs:IDREF')"
            >A schema component MUST NOT have an attribute {}base with a value of xs:IDREF.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.1.1.3. No base type of xs:anyType

   [Rule 9-3] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@base)]">
          <sch:assert test="resolve-QName(@base, .) != xs:QName('xs:anyType')"
            >A schema component MUST NOT have an attribute {}base with a value of xs:anyType.</sch:assert>
        </sch:rule>
      </sch:pattern>

   XML Schema has the concept of the "ur-type," a type that is the root of all other types. This type is realized in schemas as xs:anyType.

   NIEM-conformant schemas must not use xs:anyType, because this feature permits the introduction of arbitrary content (i.e., untyped and unconstrained data) into an XML instance. NIEM intends that the schemas describing that instance describe all constructs within the instance.

9.1.1.1.4. No base type of xs:anySimpleType

   [Rule 9-4] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@base)]">
          <sch:assert test="resolve-QName(@base, .) != xs:QName('xs:anySimpleType')"
            >A schema component MUST NOT have an attribute {}base with a value of xs:anySimpleType.</sch:assert>
        </sch:rule>
      </sch:pattern>

   XML Schema provides a restriction of the "ur-type" that contains only simple content. This provides a wildcard for arbitrary text. It is realized in XML Schema as xs:anySimpleType.

   NIEM-conformant schemas must not use xs:anySimpleType because this feature is insufficiently constrained to provide a meaningful starting point for content definitions. Instead, content should be based on one of the more specifically defined simple types defined by XML Schema.

9.1.1.1.5. No base type of xs:NOTATION

   [Rule 9-5] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@base)]">
          <sch:assert test="resolve-QName(@base, .) != xs:QName('xs:NOTATION')"
            >A schema component MUST NOT have an attribute {}base with a value of xs:NOTATION.</sch:assert>
        </sch:rule>
      </sch:pattern>

   XML Schema notations allow the attachment of system and public identifiers on fields of data. The notation mechanism does not play a part in validation of instances and is not supported by NIEM.

9.1.2. Simple type definition

9.1.2.1. Simple type definition is top-level

   [Rule 9-6] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:simpleType">
          <sch:assert test="exists(parent::xs:schema)"
            >A simple type definition MUST be top-level.</sch:assert>
        </sch:rule>
      </sch:pattern>

   NIEM does not support anonymous types in NIEM-conformant schemas. All XML Schema "top-level" types (children of the document element) are required by XML Schema to be named. By requiring NIEM type definitions to be top level, they are forced to be named and are globally reusable.

9.1.2.2. Simple type data definitions

9.1.2.2.1. Simple type has data definition

   [Rule 9-7] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:simpleType">
          <sch:assert test="exists(xs:annotation/xs:documentation)"
            >A simple type MUST be a documented component.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.2.2. Simple type data definition is not empty

   [Rule 9-8] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:simpleType/xs:annotation/xs:documentation[
                               . is (../../xs:annotation/xs:documentation)[1]]">
          <sch:assert test="string-length(normalize-space(string-join(text(), ''))) &gt; 0"
            >A data definition MUST NOT be empty.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.3. Simple types prohibited as list item types

   There is no explicit prohibition on the use of xs:NOTATION as list item type, because it is prohibited by [XML Schema Datatypes].

   There is no prohibition on xs:anyType as a list item type, because xs:anyType is not a simple type.

9.1.2.3.1. No list item type of xs:ID

   [Rule 9-9] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@itemType)]">
          <sch:assert test="resolve-QName(@itemType, .) != xs:QName('xs:ID')"
            >A schema component MUST NOT have an attribute {}itemType with a value of xs:ID.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.3.2. No list item type of xs:IDREF

   [Rule 9-10] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@itemType)]">
          <sch:assert test="resolve-QName(@itemType, .) != xs:QName('xs:IDREF')"
            >A schema component MUST NOT have an attribute {}itemType with a value of xs:IDREF.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.3.3. No list item type of xs:anySimpleType

   [Rule 9-11] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@itemType)]">
          <sch:assert test="resolve-QName(@itemType, .) != xs:QName('xs:anySimpleType')"
            >A schema component MUST NOT have an attribute {}itemType with a value of xs:anySimpleType.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.4. Simple types prohibited as union member types

   There is no explicit prohibition on the use of xs:NOTATION as a union member type, because it is prohibited by [XML Schema Datatypes].

   There is no prohibition on xs:anyType as a union member type, because xs:anyType is not a simple type.

9.1.2.4.1. No union member types of xs:ID

   [Rule 9-12] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@memberTypes)]">
          <sch:assert test="every $type-qname 
                            in tokenize(normalize-space(@memberTypes), ' ')
                            satisfies resolve-QName($type-qname, .) != xs:QName('xs:ID')"
            >A schema component MUST NOT have an attribute {}memberTypes that includes a value of xs:ID.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.4.2. No union member types of xs:IDREF

   [Rule 9-13] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@memberTypes)]">
          <sch:assert test="every $type-qname 
                            in tokenize(normalize-space(@memberTypes), ' ')
                            satisfies resolve-QName($type-qname, .) != xs:QName('xs:IDREF')"
            >A schema component MUST NOT have an attribute {}memberTypes that includes a value of xs:IDREF.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.4.3. No union member types of xs:anySimpleType

   [Rule 9-14] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@memberTypes)]">
          <sch:assert test="every $type-qname 
                            in tokenize(normalize-space(@memberTypes), ' ')
                            satisfies resolve-QName($type-qname, .) != xs:QName('xs:anySimpleType')"
            >A schema component MUST NOT have an attribute {}memberTypes that includes a value of xs:anySimpleType.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.5. No simple type disallowed derivation

   [Rule 9-15] (REF)

      <sch:pattern>
        <sch:rule context="xs:simpleType">
          <sch:assert test="empty(@final)"
            >An element xs:simpleType MUST NOT have an attribute {}final.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.6. Enumeration data definitions

9.1.2.6.1. Enumeration has data definition

   [Rule 9-16] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:enumeration">
          <sch:assert test="exists(xs:annotation/xs:documentation)"
            >An enumeration facet MUST be a documented component.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.2.6.2. Enumeration data definition is not empty

   [Rule 9-17] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:enumeration/xs:annotation/xs:documentation[
                               . is (../../xs:annotation/xs:documentation)[1]]">
          <sch:assert test="string-length(normalize-space(string-join(text(), ''))) &gt; 0"
            >A data definition MUST NOT be empty.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.3. Complex type definitions

9.1.3.1. Complex type definitions are top-level

   [Rule 9-18] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:assert test="exists(parent::xs:schema)"
            >A complex type definition must be top-level.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Note that this implies that every xs:complexType element has a name attribute.

9.1.3.2. Complex type data definitions

9.1.3.2.1. Complex type has data definition

   [Rule 9-19] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:assert test="exists(xs:annotation/xs:documentation)"
            >A complex type MUST be a documented component.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.3.2.2. Complex type data definition is not empty

   [Rule 9-20] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType/xs:annotation/xs:documentation[
                               . is (../../xs:annotation/xs:documentation)[1]]">
          <sch:assert test="string-length(normalize-space(string-join(text(), ''))) &gt; 0"
            >A data definition MUST NOT be empty.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.3.3. No mixed content

9.1.3.3.1. No mixed content on complex type

   [Rule 9-21] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType[exists(@mixed)]">
          <sch:assert test="xs:boolean(@mixed) = false()"
            >A complex type declaration MUST NOT have mixed content.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Mixed content allows the mixing of data tags with text. Languages such as XHTML use this syntax for markup of text. NIEM-conformant schemas define XML that is for data exchange, not text markup. Mixed content creates complexity in processing, defining, and constraining content.

   Well-defined markup languages exist outside NIEM and may be used with NIEM data. External schemas may include mixed content and may be used with NIEM. However, mixed content must not be defined by NIEM-conformant schemas in keeping with [Principle 9].

9.1.3.3.2. No mixed content on complex content

   [Rule 9-22] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexContent[exists(@mixed)]">
          <sch:assert test="xs:boolean(@mixed) = false()"
            >A complex type declaration MUST NOT have mixed content.</sch:assert>
        </sch:rule>
      </sch:pattern>

   See [Rule 9-21], above, for the rationale for this rule.

9.1.3.4. Complex type content is explicitly simple or complex

   [Rule 9-23] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:assert test="exists(xs:simpleContent) or exists(xs:complexContent)"
            >An element xs:complexType MUST have a child element xs:simpleContent or xs:complexContent.</sch:assert>
        </sch:rule>
      </sch:pattern>

   XML Schema provides shorthand to defining complex content of a complex type, which is to define the complex type with immediate children that specify elements, or other groups, and attributes. In the desire to normalize schema representation of types and to be explicit, NIEM forbids the use of that shorthand.

9.1.3.5. Complex content

   Within a reference schema, a complex type with complex content can be created in one of two ways:

      1. By extension of an existing NIEM complex type with complex content.

      2. By extension of a type defined in the structures namespace.

   Both of these methods use the element xs:extension. Within extension schemas, exchange schemas, and subset schemas, the use of xs:restriction to create complex types with complex content is also allowed.

9.1.3.5.1. Complex content uses extension

   [Rule 9-24] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexContent">
          <sch:assert test="exists(xs:extension)"
            >An element xs:complexContent MUST have a child xs:extension.</sch:assert>
        </sch:rule>
      </sch:pattern>

   NIEM does not support the use of complex type restriction in reference schemas. The use of restriction in a reference schema would reduce the ability for that schema to be reused. Restriction may be used in extension schemas.

   Note that XML Schema requires use of the attribute base on xs:extension.

9.1.3.5.2. Complex type with complex content must have complex content

   [Rule 9-25] (SET, REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType[
            nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))
            or nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument'))]
          /xs:complexContent
            /xs:*[(self::xs:restriction or self::xs:extension)
                  and exists(@base)]">
          <sch:let name="not-complex-content"
                   value="for $qname in resolve-QName(@base, .),
                              $not-structures-qname in $qname[namespace-uri-from-QName(.) != xs:anyURI('http://release.niem.gov/niem/structures/3.0/')],
                              $base-type in nf:resolve-type(., $not-structures-qname),
                              $base-complex-type in $base-type[self::xs:complexType],
                              $base-not-complex-content in $base-complex-type[empty(xs:complexContent)]
                          return $base-not-complex-content"/>
          <sch:assert test="empty($not-complex-content)"
            >The base type of complex type that has complex content MUST have complex content.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.3.6. Simple content

9.1.3.6.1. Simple content uses extension

   Within a NIEM-conformant schema, a complex type with simple content can be created in one of two ways:

      1. By extension of an existing complex type with simple content.

      2. By extension of an existing simple type.

   Both of these methods use the element xs:extension. Although these two methods have similar syntax, there are subtle differences. NIEM's conformance rules ensure that any complex type has the necessary attributes for representing IDs, references, metadata, and relationship metadata. Case 1 does not require adding these attributes, as they are guaranteed to occur in the base type. However, in case 2, in which a new complex type is created from a simple type, the attributes for complex types must be added. This is done by reference to the attribute group structures:SimpleObjectAttributeGroup.

   [Rule 9-26] (REF)

      <sch:pattern>
        <sch:rule context="xs:simpleContent">
          <sch:assert test="exists(xs:extension)"
            >A complex type definition with simple content schema component must have a derivation method of extension.</sch:assert>
        </sch:rule>
      </sch:pattern>

   This rule ensures that the definition of a complex type with simple content will use XML Schema extension. This allows for the above cases while disallowing more complicated syntactic options available in XML Schema. The above rule allows for use of xs:restriction within xs:simpleContent in extension schemas.

9.1.3.6.2. Complex types with simple content have structures:SimpleObjectAttributeGroup

   [Rule 9-27] (REF)

      <sch:pattern>
        <sch:rule context="xs:simpleContent/xs:extension[
            for $base in resolve-QName(@base, .), 
                $base-qname in namespace-uri-from-QName($base) return
              (namespace-uri-from-QName($base) = 'http://www.w3.org/2001/XMLSchema'
               or (some $type in nf:resolve-type(., $base) satisfies 
                    node-name($type) = xs:QName('xs:simpleType')
                  )
              )
           ]">
          <sch:assert test="exists(
                              xs:attributeGroup[
                                exists(@ref)
                                and resolve-QName(@ref, .) = xs:QName('structures:SimpleObjectAttributeGroup')
                              ]
                            )"
            >A complex type definition with simple content schema component with a derivation method of extension that has a base type definition that is a simple type MUST incorporate the attribute group {http://release.niem.gov/niem/structures/3.0/}SimpleObjectAttributeGroup.</sch:assert>
        </sch:rule>
      </sch:pattern>

   This rule ensures that a complex type with simple content that is created as an immediate extension of a simple type adds the attributes required for specific NIEM linking mechanisms.

   This creates a pattern for complex type with simple content definition as follows:

   Figure 9-1: Example of complex type with simple content derived from a simple type

      <xs:complexType name="PercentageType">
        ... 
        <xs:simpleContent>
          <xs:extension base="nc:PercentageSimpleType">
            <xs:attributeGroup ref="structures:SimpleObjectAttributeGroup"/>
          </xs:extension>
        </xs:simpleContent>
      </xs:complexType>

9.1.3.7. No complex type disallowed substitutions

   [Rule 9-28] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:assert test="empty(@block)"
            >An element xs:complexType MUST NOT have an attribute {}block.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.1.3.8. No complex type disallowed derivation

   [Rule 9-29] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:assert test="empty(@final)"
            >An element xs:complexType MUST NOT have an attribute {}final.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2. Declaration components

9.2.1. Element declaration

   Every element declaration in a NIEM-conformant schema document is a top-level element; rules prohibit the declaration of local elements.

   Within a NIEM-conformant schema document, an element may be declared as abstract. Elements may be defined without a type, but any element declaration that has no type must be declared abstract, as specified by [Rule 9-33], below.

   Within an element declaration, the attributes fixed, nillable, and substitutionGroup may be used as per the XML Schema specification. The attribute form is irrelevant to NIEM, as NIEM-conformant schemas may not contain local element definitions, as specified by [Rule 9-30], below.

9.2.1.1. Element declaration is top-level

   [Rule 9-30] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name)]">
          <sch:assert test="exists(parent::xs:schema)"
            >An element declaration MUST be top-level.</sch:assert>
        </sch:rule>
      </sch:pattern>

   All schema components defined by NIEM-conformant schemas must be named, accessible from outside the defining schema, and reusable across schemas. Local element definitions provide named elements that are not reusable outside the context in which they are defined.Requiring named NIEM elements to be top level ensures that they are globally reusable.

9.2.1.2. Element declaration data definitions

9.2.1.2.1. Element declaration has data definition

   [Rule 9-31] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name)]">
          <sch:assert test="exists(xs:annotation/xs:documentation)"
            >An element declaration MUST be a documented component.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.2.2. Element declaration data definition is not empty

   [Rule 9-32] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name)]/xs:annotation/xs:documentation[
                               . is (../../xs:annotation/xs:documentation)[1]]">
          <sch:assert test="string-length(normalize-space(string-join(text(), ''))) &gt; 0"
            >A data definition MUST NOT be empty.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.3. Untyped element is abstract

   [Rule 9-33] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:schema/xs:element[empty(@type)]">
          <sch:assert test="exists(@abstract)
                            and xs:boolean(@abstract) = true()"
            >A top-level element declaration that has no type MUST be abstract.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Untyped element declarations act as wildcards that may carry arbitrary data. By declaring such types abstract, NIEM allows the creation of type independent semantics without allowing arbitrary content to appear in XML instances.

9.2.1.4. Element of type xs:anySimpleType is abstract

   The type xs:anySimpleType does not have any concrete semantics; The use of xs:anySimpleType is limited to the case where an abstract element is of type xs:anySimpleType, to act as a base for concrete implementations of the element.

   [Rule 9-34] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@type)
                                      and resolve-QName(@type, .) = xs:QName('xs:anySimpleType')]">
          <sch:assert test="exists(@abstract)
                            and xs:boolean(@abstract) = true()"
                      >An element declaration that has a type xs:anySimpleType MUST be abstract.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.5. Element type not in the XML Schema namespace

   [Rule 9-35] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@type)]">
          <sch:assert test="for $type-qname in resolve-QName(@type, .) return
                              $type-qname = xs:QName('xs:anySimpleType')
                              or namespace-uri-from-QName($type-qname) != xs:anyURI('http://www.w3.org/2001/XMLSchema')"
            >An element type that is not xs:anySimpleType MUST NOT have a namespace name <namespace-uri-for-prefix>xs</namespace-uri-for-prefix>.</sch:assert>
        </sch:rule>
      </sch:pattern>

   The prohibition of element types having the XML Schema namespace subsumes a prohibition of the type xs:anyType.

9.2.1.6. Element type not in a special namespace

   [Rule 9-36] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@type)]">
          <sch:assert test="not(namespace-uri-from-QName(resolve-QName(@type, .))
                                = (xs:anyURI('http://www.w3.org/XML/1998/namespace'),
                                     xs:anyURI('urn:us:gov:ic:ism'),
                                     xs:anyURI('urn:us:gov:ic:ntk')))"
            >An element type MUST NOT have a namespace name that is in a special namespace.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.7. Element type is not a simple type

   [Rule 9-37] (SET)

      <sch:pattern>
        <sch:rule context="xs:element[(nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))
                                       or nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument')))
                                      and exists(@type)]">
          <sch:assert test="every $type-qname in resolve-QName(@type, .),
                                  $type in nf:resolve-type(., $type-qname)
                            satisfies empty($type/self::xs:simpleType)"
                      >An element type MUST NOT be a simple type.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.8. No element disallowed substitutions 

   [Rule 9-38] (REF)

      <sch:pattern>
        <sch:rule context="xs:element">
          <sch:assert test="empty(@block)"
            >An element xs:element MUST NOT have an attribute {}block.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.9. No element disallowed derivation

   [Rule 9-39] (REF)

      <sch:pattern>
        <sch:rule context="xs:element">
          <sch:assert test="empty(@final)"
            >An element xs:element MUST NOT have an attribute {}final.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.10. No element value constraints

9.2.1.10.1. No element default values

   [Rule 9-40] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element">
          <sch:assert test="empty(@default)"
            >An element xs:element MUST NOT have an attribute {}default.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.10.2. No element fixed values

   [Rule 9-41] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element">
          <sch:assert test="empty(@fixed)"
            >An element xs:element MUST NOT have an attribute {}fixed.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.1.11. Element declaration is nillable

   All elements declared by reference schemas allow a nil value. This enables the ID/IDREF mechanism linking structures:ref and structures:id, as described by Section 12.3, Reference elements, below.

   A developer may constrain the use of nil in instance by setting nillable to false in subset schemas, or by use of non-XML Schema mechanisms, such as Schematron.

   [Rule 9-42] (REF)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name)
                                      and (empty(@abstract)
                                           or xs:boolean(@abstract) = false())]">
          <sch:assert test="exists(@nillable)
                            and xs:boolean(@nillable) = true()"
            >An [element declaration schema component] MUST have the nillable property with a value of true.</sch:assert>
        </sch:rule>
      </sch:pattern>

   [Element declaration schema component] has a normative definition.

9.2.2. Element substitution group

9.2.3. Attribute declaration

   Within an attribute declaration, the attribute form is irrelevant to NIEM, as NIEM-conformant schemas may not contain local attribute declarations.

   An attribute use has an {attribute declaration} property that is a top-level, named attribute declaration. NIEM-conformant schemas do not define local named attributes within type definitions. Within an attribute use, the attribute use may be used as per the XML Schema specification.

9.2.3.1. Attribute declarations are top-level

   [Rule 9-43] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@name)]">
          <sch:assert test="exists(parent::xs:schema)"
            >An attribute declaration MUST be top-level.</sch:assert>
        </sch:rule>
      </sch:pattern>

   All schema components defined by NIEM-conformant schemas are named, accessible from outside the defining schema, and reusable across schemas. Local attribute definitions provide named attributes that are not reusable outside the context in which they are defined. Requiring named NIEM attributes to be top level ensures that they are globally reusable.

9.2.3.2. Attribute declaration data definitions

9.2.3.2.1. Attribute declaration has data definition

   [Rule 9-44] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@name)]">
          <sch:assert test="exists(xs:annotation/xs:documentation)"
            >An attribute declaration MUST be a documented component.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.3.2.2. Attribute declaration data definition is not empty

   [Rule 9-45] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@name)]/xs:annotation/xs:documentation[
                               . is (../../xs:annotation/xs:documentation)[1]]">
          <sch:assert test="string-length(normalize-space(string-join(text(), ''))) &gt; 0"
            >A data definition MUST NOT be empty.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.3.3. Attribute declaration has type

   [Rule 9-46] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@name)]">
          <sch:assert test="exists(@type)"
            >A top-level attribute declaration MUST have a type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Untyped XML Schema attributes allow arbitrary content, with no semantics. Attributes must have a type so that specific syntax and semantics will be provided.

9.2.3.4. Prohibited attribute types

   There is no explicit prohibition on the use of xs:NOTATION as an attribute type, because it is prohibited by [XML Schema Datatypes].

   These types are only explicitly prohibited from attributes, not elements, because the case is covered by a general prohibition against elements having simple types.

9.2.3.4.1. No attribute type of xs:ID

   [Rule 9-47] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@type)]">
          <sch:assert test="resolve-QName(@type, .) != xs:QName('xs:ID')"
            >A schema component MUST NOT have an attribute {}type with a value of xs:ID.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.3.4.2. No attribute type of xs:IDREF

   [Rule 9-48] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@type)]">
          <sch:assert test="resolve-QName(@type, .) != xs:QName('xs:IDREF')"
            >A schema component MUST NOT have an attribute {}type with a value of xs:IDREF.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.3.5. No attribute value constraints

9.2.3.5.1. No attribute default values

   [Rule 9-49] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute">
          <sch:assert test="empty(@default)"
            >An element xs:attribute MUST NOT have an attribute {}default.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.2.3.5.2. No attribute fixed values

   [Rule 9-50] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute">
          <sch:assert test="empty(@fixed)"
            >An element xs:attribute MUST NOT have an attribute {}fixed.</sch:assert>
        </sch:rule>
      </sch:pattern>

   The use of the fixed attribute may result in alteration of the post-schema-validation infoset, like the use of default does. This behavior is described by [XML Schema Structures] section 3.2.1, The Attribute Declaration Schema Component.

9.2.4. Notation declaration

9.2.4.1. No use of element xs:notation

   [Rule 9-51] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:notation">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:notation.</sch:assert>
        </sch:rule>
      </sch:pattern>

   See Section 9.1.1.1.5, No base type of xs:NOTATION, above, for comments about the use of notations.

9.3. Model group components

9.3.1. Model group

   Complex content definitions in XML Schema use model group schema components. These schema components, xs:all, xs:choice and xs:sequence, also called compositors, provide for ordering and selection of particles within a model group.

   XML Schema defines a particle as an occurrence of xs:element, xs:sequence, xs:choice, xs:any (wildcard) and xs:group (model group) within a content model. For example, an xs:sequence within an XML Schema complex type is a particle. An xs:element occurring within an xs:sequence is also a particle.

9.3.1.1. Model group does not affect meaning

   [Rule 9-52] (EXT)

      The use of model groups xs:all, xs:sequence, and xs:choice SHALL NOT define the semantics of an instance. The meaning of an element occurrance within an element occurrence SHALL be identical, regardless of the model group used to define a [schema component].

9.3.1.2. No xs:all

   [Rule 9-53] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:all">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:all</sch:assert>
        </sch:rule>
      </sch:pattern>

   The element xs:all provides a set of particles (e.g., elements) that may be included in an instance, in no particular order. This can greatly complicate processing and may be difficult to comprehend and satisfy.

   

9.3.1.3. Sequence

9.3.1.3.1. xs:sequence must be child of xs:extension

   [Rule 9-54] (REF)

      <sch:pattern>
        <sch:rule context="xs:sequence">
          <sch:assert test="exists(parent::xs:extension)"
            >An element xs:sequence must be a child of element xs:extension.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.1.3.2. xs:sequence must be child of xs:extension or xs:restriction

   [Rule 9-55] (EXT)

      <sch:pattern>
        <sch:rule context="xs:sequence">
          <sch:assert test="exists(parent::xs:extension) or exists(parent::xs:restriction)"
            >An element xs:sequence must be a child of element xs:extension or xs:restriction.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.1.4. Choice

9.3.1.4.1. No xs:choice

   [Rule 9-56] (REF)

      <sch:pattern>
        <sch:rule context="xs:choice">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:choice</sch:assert>
        </sch:rule>
      </sch:pattern>

   The element xs:choice provides an exclusive set of particles, one of which may appear in an instance. This can greatly complicate processing and may be difficult to comprehend, satisfy, and reuse.

   The element xs:choice may be used in extension schemas, as it presents a simple way for a schema writer to represent a set of optional content.

9.3.1.4.2. xs:choice must be child of xs:sequence

   [Rule 9-57] (EXT)

      <sch:pattern>
        <sch:rule context="xs:choice">
          <sch:assert test="exists(parent::xs:sequence)"
            >An element xs:choice must be a child of element xs:sequence.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.2. Particle

   In NIEM schemas, an element use is a element declaration acting as a particle within a content model. Each such element declaration must reference a top-level named element declaration.

   Element declarations acting as a particle (particles formed by xs:element) may have any cardinality. NIEM does not provide additional constraints on the values of the XML Schema properties {min occurs} and {max occurs} on element uses. These properties are described by [XML Schema Structures] section 3.9.1, The Particle Schema Component.

9.3.2.1. Sequence cardinality

   XML Schema allows each particle to specify cardinality (how many times the particle may appear in an instance). NIEM restricts the cardinality of xs:sequence particles to exactly one, to ensure that content model definitions are defined in as straightforward a manner as possible.

   Should a schema developer user require the instance syntax would be obtained from the use of specific cardinality on sequences, she should define cardinality on specific elements.

9.3.2.1.1. Sequence minimum cardinality

   [Rule 9-58] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:sequence">
          <sch:assert test="empty(@minOccurs) or xs:integer(@minOccurs) = 1"
            >An element xs:sequence MUST either not have the attribute {}minOccurs, or that attribute MUST have a value of 1.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.2.1.2. Sequence maximum cardinality

   [Rule 9-59] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:sequence">
          <sch:assert test="empty(@maxOccurs) or (@maxOccurs instance of xs:integer
                                                  and 1 = xs:integer(@maxOccurs))"
            >An element xs:sequence MUST either not have the attribute {}maxOccurs, or that attribute MUST have a value of 1.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.2.2. Choice cardinality

9.3.2.2.1. Choice minimum cardinality

   [Rule 9-60] (EXT)

      <sch:pattern>
        <sch:rule context="xs:choice">
          <sch:assert test="empty(@minOccurs) or 1 = xs:integer(@minOccurs)"
            >An element xs:choice MUST either not have the attribute {}minOccurs, or that attribute MUST have a value of 1.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.2.2.2. Choice maximum cardinality

   [Rule 9-61] (EXT)

      <sch:pattern>
        <sch:rule context="xs:choice">
          <sch:assert test="empty(@maxOccurs) or (@maxOccurs instance of xs:integer
                                                  and 1 = xs:integer(@maxOccurs))"
            >An element xs:choice MUST either not have the attribute {}maxOccurs, or that attribute MUST have a value of 1.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.3. Attribute use

9.3.3.1. Attribute ref defined by conformant schemas

   [Rule 9-62] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@ref)]">
          <sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@ref, .))"/>
          <sch:assert test="$namespace = nf:get-target-namespace(.)
                            or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                          and $namespace = xs:anyURI(@namespace)
                                          and empty(@appinfo:externalImportIndicator)])"
            >An attribute {}ref MUST have the target namespace or a namespace that is imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.4. Attribute group

9.3.4.1. Only known attribute groups

   In NIEM-conformant schemas, use of attribute groups is restricted. The only attribute group that plays a part in NIEM-conformant schemas is structures:SimpleObjectAttributeGroup. This attribute group provides the attributes necessary for IDs, references, metadata, and relationship metadata.

   [Rule 9-63] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attributeGroup[exists(@ref)]">
          <sch:assert test="for $ref in exactly-one(resolve-QName(@ref, .)) return
            ($ref = xs:QName('structures:SimpleObjectAttributeGroup')
             or (for $ref-namespace in exactly-one(namespace-uri-from-QName($ref)) return
                   $ref-namespace = (xs:anyURI('urn:us:gov:ic:ism'),
                                    xs:anyURI('urn:us:gov:ic:ntk'))))"
            >An attribute group reference MUST be structures:SimpleObjectAttributeGroup or have the IC-ISM or IC-NTK namespace.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.3.5. Wildcard

9.3.5.1. No use of xs:any

   [Rule 9-64] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:any">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:any.</sch:assert>
        </sch:rule>
      </sch:pattern>

   The xs:any particle (see Model Group Restrictions for an informative definition of particle) provides a wildcard that may carry arbitrary content. The particle xs:any may appear within constraint schemas, extension schemas, and exchange schemas.

9.3.5.2. No use of xs:anyAttribute

   [Rule 9-65] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:anyAttribute">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:anyAttribute.</sch:assert>
        </sch:rule>
      </sch:pattern>

   The xs:anyAttribute element provides a wildcard, where arbitrary attributes may appear. The element xs:anyAttribute may appear within constraint schemas or within other schemas that are not NIEM-conformant, but it is prohibited in NIEM- conformant schemas.

9.4. Identity-constraint definition components

   XML Schema provides NIEM with the ability to apply uniqueness constraints to schema-validated content. These mechanisms, however, establish relationships in a way that is very difficult to understand, extend, and keep consisent through schema reuse.

9.4.1. No use of xs:unique

   [Rule 9-66] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:unique">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:unique.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.4.2. No use of xs:key

   [Rule 9-67] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:key">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:key.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.4.3. No use of xs:keyref

   [Rule 9-68] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:keyref">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:keyref.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.4.4. No use of xs:selector

   [Rule 9-69] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:selector">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:selector.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.4.5. No use of xs:field

   [Rule 9-70] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:field">
          <sch:assert test="false()"
            >The schema SHALL NOT contain the element xs:field.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.5. Group definition components

9.5.1. Model group definition

9.5.1.1. No use of xs:group

   [Rule 9-71] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:group">
          <sch:assert test="false()"
            >The schema MUST NOT contain the element xs:group.</sch:assert>
        </sch:rule>
      </sch:pattern>

   NIEM does not allow groups of elements to be named other than as named complex types. A group in XML Schema creates a named entity that may be included in multiple types, and which consists of a sequence of or choice between element particles. The NIEM has not developed a semantic model for these components, and they are not integrated into NIEM's design.

9.5.2. Attribute group definition

9.5.2.1. No definition of attribute groups

   The only attribute groups used in NIEM-conformant schemas are structures:SimpleObjectAttributeGroup and attribute groups defined by the IC-ISM and IC-NTK schemas. Therefore, NIEM-conformant schemas do not define additional attribute groups.

   [Rule 9-72] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attributeGroup[@name]">
          <sch:assert test="false()"
            >The schema MUST NOT contain an attribute group definition schema component.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.6. Annotation components

9.6.1. Comments are not recommended

   [Rule 9-73] (REF, EXT)

      <sch:pattern>
        <sch:rule context="comment()">
          <sch:report test="true()"
            >An XML Comment is not an XML Schema annotation component; XML Comments SHOULD NOT appear in the schema.</sch:report>
        </sch:rule>
      </sch:pattern>

   Since XML comments are not associated with any specific XML Schema construct, there is no standard way to interpret comments. As such, comments should be reserved for internal use, and XML Schema annotations should be preferred for meaningful information about components. NIEM specifically defines how information should be encapsulated in NIEM-conformant schemas via xs:annotation elements.

9.6.2. Documentation elements have no element children

   [Rule 9-74] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:documentation/node()">
          <sch:assert test="self::text() or self::comment()"
            >A child of element xs:documentation MUST be text or an XML comment.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.6.3. Application information annotations

   XML Schema provides special annotations for support of automatic processing. The XML Schema specification provides the element xs:appinfo to carry such content and does not specify what style of content they should carry. In NIEM, xs:appinfo elements carry structured XML content.

9.6.3.1. Appinfo has elements

   [Rule 9-75] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:appinfo/node()">
          <sch:assert test="self::comment() or self::element()"
            >A child of element xs:appinfo MUST be an element or an XML comment.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Application information elements are intended for automatic processing; the meaning of an appinfo annotation is provided via elements.

9.6.3.2. Appinfo child elements have namespaces

   [Rule 9-76] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:appinfo/*">
          <sch:assert test="namespace-uri() != xs:anyURI('')"
            >An element that is a child of xs:appinfo MUST have a namespace name.</sch:assert>
        </sch:rule>
      </sch:pattern>

   The XML namespaces specification includes the concept of content not in a namespace. Use of elements without namespaces can lead to conflicting data definitions, and makes it difficult to identify relevant data definitions.

9.6.3.3. Appinfo descendants are not XML Schema elements

   [Rule 9-77] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:appinfo//xs:*">
          <sch:assert test="false()"
            >An element with a namespace name of xs: MUST NOT have an ancestor element xs:appinfo.</sch:assert>
        </sch:rule>
      </sch:pattern>

   NIEM-conformant schemas are designed to be very easily processed. Although uses of XML Schema elements as content of xs:appinfo elements could be contrived, it is not current practice and complicates the processing of XML elements by their namespaces and names. Forbidding the use of XML Schema elements outside valid uses of schema simplifies such processing.

9.7. Schema as a whole

   The XML Schema language defines that the document element xs:schema may contain the optional attributes attributeFormDefault and elementFormDefault. The values of these attributes are not material to a NIEM-conformant schema, as each attribute and element defined by a NIEM-conformant schema must be defined at the toplevel and so is qualified its target namespace.

9.7.1. Schema data definitions

9.7.1.1. Schema has data definition

   [Rule 9-78] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:schema">
          <sch:assert test="exists(xs:annotation/xs:documentation)"
            >A schema document element MUST be a documented component.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.7.1.2. Schema data definition is not empty

   [Rule 9-79] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:schema/xs:annotation/xs:documentation[
                               . is (../../xs:annotation/xs:documentation)[1]]">
          <sch:assert test="string-length(normalize-space(string-join(text(), ''))) &gt; 0"
            >A data definition MUST NOT be empty.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.7.2. Define target namespace

   [Rule 9-80] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:schema">
          <sch:assert test="exists(@targetNamespace)"
            >The schema MUST define a target namespace.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Schemas without defined namespaces provide definitions that are ambiguous, in that they are not universally identifiable.

9.7.3. Target namespace is absolute URI

   [Rule 9-81] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:schema[exists(@targetNamespace)]">
          <sch:report test="true()"
                      ><![CDATA[The value of the attribute targetNamespace MUST match the production <absolute-URI> as defined by RFC 3986.]]></sch:report>
        </sch:rule>
      </sch:pattern>

   Absolute URIs are the only universally meaningful URIs. URIs include both URLs and URNs. Finding the target namespace using standard XML Base technology is complicated and not specified by XML Schema. Relative URIs are not universally identifiable, as they are context-specific.

9.7.4. Schema document version

   It is very useful to be able to tell one version of a schema from another. Apart from the use of namespaces for versioning, it is sometimes necessary to release multiple versions of schema documents. Such use might include:

      *  Subset schemas and constraint schemas

      *  Error corrections or bug fixes

      *  Documentation changes

      *  Contact information updates

   In such cases, a different value for the version attribute implies a different version of the schema. No specific meaning is assigned to specific version identifiers.

   Note that some of the above uses for the version attribute are not employed in management of NIEM Core and domain schemas. An author of an application schema or exchange may use the version attribute for these purposes within their schemas.

9.7.4.1. Schema must have version

   [Rule 9-82] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:schema">
          <sch:assert test="exists(@version)"
              >An element xs:schema must have an attribute {}version.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.7.4.2. Schema version must not be empty.

   [Rule 9-83] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:schema[exists(@version)]">
          <sch:assert test="string-length(normalize-space(@version)) &gt; 0"
                      >An attribute version owned by an element xs:schema must not be empty.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.7.5. No disallowed substitutions

   [Rule 9-84] (REF)

      <sch:pattern>
        <sch:rule context="xs:schema">
          <sch:assert test="empty(@blockDefault)"
            >An element xs:schema MUST NOT have an attribute {}blockDefault.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.7.6. No disallowed derivations

   [Rule 9-85] (REF)

      <sch:pattern>
        <sch:rule context="xs:schema">
          <sch:assert test="empty(@finalDefault)"
            >An element xs:schema MUST NOT have an attribute {}finalDefault.</sch:assert>
        </sch:rule>
      </sch:pattern>

9.8. Schema assembly

9.8.1. No use of xs:redefine

   [Rule 9-86] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:redefine">
          <sch:assert test="false()"
            >The schema MUST NOT contain the element xs:redefine.</sch:assert>
        </sch:rule>
      </sch:pattern>

   The xs:redefine element allows an XML Schema document to restrict and extend components from a namespace, in a separate schema document from the one that initially defined that namespace. Such redefinition introduces duplication of definitions, allowing multiple definitions to exist for components from a single namespace. This violates [Principle 8], that a single reference schema defines a NIEM-conformant namespace.

9.8.2. No use of xs:include

   [Rule 9-87] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:include">
          <sch:assert test="false()"
            >The schema MUST NOT contain the element xs:include.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Element xs:include brings schemas defined in separate files into the current namespace. It breaks a namespace up into arbitrary partial schemas, which needlessly complicates the schema structure, making it harder to reuse and process, and also increases the likelihood of conflicting definitions.

   Inclusion of schemas that do not have namespaces also complicates schema understanding. This inclusion makes it difficult to find the realization of a specific schema artifact and create aliases for schema components that should be reused. Inclusion of schemas also violates [Principle 8], as it uses multiple schemas to construct a namespace.

9.8.3. xs:import must have namespace

   [Rule 9-88] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:import">
          <sch:assert test="exists(@namespace)"
            >An element xs:import MUST have an attribute {}namespace.</sch:assert>
        </sch:rule>
      </sch:pattern>

   An import that does not specify a namespace is enabling references to non-namespaced components. NIEM requires that all components have a defined namespace. It is important that the namespace declared by a schema be universally defined and unambiguous.

10. Rules for NIEM modeling, by NIEM concept

   This section focuses on building NIEM data models using XML schema. Whereas Section 9, Rules for a NIEM profile of XML Schema, above, addressed shrinking the XML Schema definition language to a smaller set of features, this section constructs new NIEM-specific features to address modeling and interoperability problems. This includes naming rules, categories of types, and augmentations.

   NIEM provides a framework for modeling concepts and relationships as XML artifacts. The data model is implemented via XML Schema. However, XML Schema does not provide sufficient structure and constraint to enable translating from a conceptual model to a schema and then to instances of the concepts. NIEM provides additional support for modeling concepts as schemas and provides rules for creating and connecting data that realizes those concepts.

   Underlying the NIEM data model are two namespaces: the [structures namespace] and the [appinfo namespace]. These two namespaces provide schema components that serve two functions:

      1. They provide support for connecting structural definitions to concepts.

      2. They provide base components from which to derive structural definitions.

   These namespaces are distributed with the NIEM data model content but are not themselves considered to be content of the data model. They are, instead, part of the structure on which the data model is built.

   This section is organized by concept, rather than component type. This section is integrated with the following sections:

      *  Section 11, Rules for NIEM modeling, by XML Schema component, below, is organized by component type, and provides a majority of the constraint rules for schemas that define NIEM models.

      *  Section 12, XML instance document rules, below, provides rules for XML documents that are instances of NIEM models.

   Concepts covered by this section include:

   * Section 10.1, NIEM structural facilities
   * Section 10.2, Categories of NIEM components
   * Section 10.3, Container elements
   * Section 10.4, Naming rules
   * Section 10.5, Machine-readable annotations

10.1. NIEM structural facilities

   NIEM provides the structures schema that contains base types for types defined in NIEM- conformant schemas. It provides base elements to act as heads for substitution groups. It also provides attributes that provide facilities not otherwise provided by XML Schema. These structures should be used to augment XML data. The structures provided are not meant to replace fundamental XML organization methods; they are intended to assist them.

   [Definition: structures namespace]

      The structures namespace is the namespace represented by the URI "http://release.niem.gov/niem/structures/3.0/".

   The structures namespace is a single namespace, separate from namespaces that define NIEM-conformant data. This document refers to this content via the prefix structures.

10.1.1. Use structures as specified

   [Rule 10-1] (REF, EXT, INS)

      The schema or instance MUST use content within the NIEM structures namespace as specified in this document and ONLY as specified by this document.

   This rule further enforces uniformity and consistency by mandating use of the NIEM structures namespace as is, without modification. Users are not allowed to insert types, attributes, etc. that are not specified by this document (the NDR).

10.2. Categories of NIEM components

   The NIEM rules on categories of types, and other components, use the name of a type as the key indicator of the type's category. This make the rules much simpler than doing a deep examination of each type and its base types to identify its category. For example, for complex types, the names follow a pattern:

      *  Name ends with "AssociationType" -> type is an association type.

      *  Name ends with "MetadataType" -> type is a metadata type.

      *  Name ends with "AugmentationType" -> type is an augmentation type.

      *  Otherwise -> type is an object type.

   Sections within this section include:

   * Section 10.2.1, Classes of complex types
   * Section 10.2.2, Objects
   * Section 10.2.3, Associations
   * Section 10.2.4, Augmentations
   * Section 10.2.5, Metadata

10.2.1. Classes of complex types

   [Rule 10-2] (REF, EXT)

      Within the schema, a complex type definition SHALL be one of the following:

         1. An object type.

         2. An association type.

         3. A metadata type.

         4. An augmentation type.

   This rule establishes the classes of NIEM complex types. It is a limited set, and each class has distinct semantics.

10.2.2. Objects

   The categories of objects are covered by the following sections:

   * Section 10.2.2.1, General object types
   * Section 10.2.2.2, Roles
   * Section 10.2.2.3, External adapter types
   * Section 10.2.2.4, Code types
   * Section 10.2.2.5, Proxy types

10.2.2.1. General object types

   [Definition: object type]

      In a NIEM-conformant schema, an object type is a complex type definition, an instance of which asserts the existence of an object. An object type represents some kind of object: a thing with its own lifespan that has some existence. The object may or may not be a physical object. It may be a conceptual object.

10.2.2.1.1. Object types with complex content

10.2.2.1.1.1. An object type with complex content is derived from an object type

   [Rule 10-3] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType[
            exists(xs:complexContent)
            and not(ends-with(@name, 'AssociationType')
                or ends-with(@name, 'MetadataType')
                or ends-with(@name, 'AugmentationType'))]">
          <sch:assert test="
              for $derivation-method in (xs:complexContent/xs:extension, xs:complexContent/xs:restriction),
                  $base in $derivation-method/@base,
                  $base-qname in resolve-QName($base, $derivation-method)
                return ($base-qname = xs:QName('structures:ObjectType')
                        or (for $base-namespace in namespace-uri-from-QName($base-qname) return
                              (not($base-namespace
                                     = (xs:anyURI('http://www.w3.org/XML/1998/namespace'),
                                        xs:anyURI('urn:us:gov:ic:ism'),
                                        xs:anyURI('urn:us:gov:ic:ntk')))
                               and (for $base-local-name in local-name-from-QName($base-qname) return
                                      not(ends-with($base-local-name, 'AssociationType')
                                          or ends-with($base-local-name, 'MetadataType')
                                          or ends-with($base-local-name, 'AugmentationType'))
                                   )
                              )
                            )
                        )"
            >An object type with complex content MUST be derived from structures:Object type or from another object type.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.2.2. Roles

   {Indicate that a subset of role type could omit the RoleOf element, in which case an instance of the role type is just a regular object.}

   NIEM differentiates between an object and a role of the object. The term "role" is used here to mean a function or part played by some object. The simplest way to represent a role of an object is to use an element. The following element definition models the role of a person who undergoes an assessment:

   Figure 10-1: An element definition that constitutes a role without the use of a role type

      <xs:element name="AssessmentPerson" type="nc:PersonType" nillable="true">
        <xs:annotation>
          <xs:documentation>A person who undergoes an assessment.</xs:documentation>
        </xs:annotation>
      </xs:element>

   In many cases, there is a further need to represent characteristics and additional information associated with a role of an object. In such cases, the above element is insufficient. When a role must be modeled with additional information, a [role type] is called for.

   For example, when a person is a driver involved in an automotive crash, that person has a particular role in the crash, which is modeled by the element j:CrashDriver.

   Figure 10-2: Element j:CrashDriver, modeling the role of a driver in a crash

      <xs:element name="CrashDriver" type="j:CrashDriverType" nillable="true">
        <xs:annotation>
          <xs:documentation>A motor vehicle driver involved into a traffic accident.</xs:documentation>
        </xs:annotation>
      </xs:element>

   There is more information associated with this role of the driver than just his identity as a person. Information associated with this role include the drivers license, contributing circumstances, distractions, and other properties. These characteristics are modeled as shown in the following figure. The role is modeled as a [role type]:

   Figure 10-3: Role type j:CrashDriverType, modeling a driver involved in a crash

      <xs:complexType name="CrashDriverType">
        <xs:annotation>
          <xs:documentation>A data type for a motor vehicle driver involved in a traffic accident.</xs:documentation>
        </xs:annotation>
        <xs:complexContent>
          <xs:extension base="structures:ObjectType">
            <xs:sequence>
              <xs:element ref="nc:RoleOfPerson" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="j:DriverLicense" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="j:CrashDriverContributingCircumstances" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="j:CrashDriverDistraction" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="j:CrashDriverViolation" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="j:CrashDrivingViolation" minOccurs="0" maxOccurs="unbounded"/>
              <xs:element ref="j:CrashDriverAugmentationPoint" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
          </xs:extension>
        </xs:complexContent>
      </xs:complexType>

   The term [role type] has a normative definition:

   [Definition: role type]

      A role type is an [object type] that represents a particular function, purpose, usage, or role of one or more objects of its base type.

   A role type defines an object that carries information associated with an object playing a role. A role type is used instead of the base type (in this case, nc:PersonType). The role type holds information that is specific to the role, but is not specific to the context or the base object (the object that plays the role). Developers of NIEM-conformant schemas should create and use role types whenever they have nonpersistent information specific to a base object's function. Such information generally expires when the base object is no longer playing the role. Information that is persistent to the base object probably does not belong in a role type.

   [Definition: RoleOf element]

      A RoleOf element is an [element declaration schema component] that

         *  is defined by a [conformant reference schema document] or a [conformant extension schema document], and

         *  has a {name} that begins with "RoleOf".

      A RoleOf element represents a base type for a [role type].

   We saw the use of [RoleOf element] nc:RoleOfPerson in Figure 10-3, Role type j:CrashDriverType, modeling a driver involved in a crash, above. Its definition is the following figure:

   Figure 10-4: Declaration of RoleOf element nc:RoleOfPerson

      <xs:element name="RoleOfPerson" type="nc:PersonType" substitutionGroup="nc:RoleOf" nillable="true">
        <xs:annotation>
          <xs:documentation>A person of whom the role object is a function.</xs:documentation>
        </xs:annotation>
      </xs:element>

   Here is an example of the j:CrashDriver role type used in an instance:

   Figure 10-5: An XML instance of a role type

      <j:CrashDriver>
        <nc:RoleOfPerson structures:ref="BRAVO"/>
        <j:CrashDriverViolationCode>A10</j:CrashDriverViolationCode>
        <j:CrashDrivingViolationCode>S16</j:CrashDrivingViolationCode>
      </j:CrashDriver>
      <nc:Person structures:id="BRAVO">
        <nc:PersonBirthDate>
          <nc:Date>1966-06-06</nc:Date>
        </nc:PersonBirthDate>
        <nc:PersonName>
          <nc:PersonFullName>John Doe</nc:PersonFullName>
        </nc:PersonName>
      </nc:Person>

   Note that the value of the j:CrashPerson element was indicated above using a reference; it could have been shown as a content element, instead.

10.2.2.2.1. RoleOf element type is an object type

   [Rule 10-4] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[@name[starts-with(., 'RoleOf')]]">
          <sch:assert test="every $type in @type,
                                  $type-local-name in local-name-from-QName(resolve-QName($type, .)) satisfies
                              not(ends-with($type-local-name, 'AssociationType')
                                  or ends-with($type-local-name, 'MetadataType')
                                  or ends-with($type-local-name, 'AugmentationType'))"
            >The type definition of a RoleOf element SHALL be an object type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Note that by [Rule 11-13], below, the element's type must be from a conformant namespace.

10.2.2.2.2. Only object types have RoleOf element

   [Rule 10-5] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType[
            empty(@appinfo:externalAdapterTypeIndicator)
            and exists(descendant::xs:element[
                  exists(@ref[
                    starts-with(local-name-from-QName(resolve-QName(., ..)), 'RoleOf')])])]">
          <sch:assert test="not(ends-with(@name, 'AssociationType')
                                or ends-with(@name, 'MetadataType')
                                or ends-with(@name, 'AugmentationType'))"
            >A complex type that includes a RoleOf element in its content model SHALL be an object type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Note that [RoleOf element] and [object type] are defined terms.

10.2.2.2.3. RoleOf element indicates the base types of a role type

   [Rule 10-6] (REF, EXT)

      For every [element declaration schema component] that has a local name that begins with the string "RoleOf" SHALL represent a base type, of which the containing type represents a role.

10.2.2.2.4. Instance of RoleOf element indicates a role object

   [Rule 10-7] (INS)

      When a parent element has a child element valid to an [element declaration schema component] that is a [RoleOf element],

         *  The value of the parent element is a role object.

         *  The value of the child element is a base object of the role object.

   An instance of a [RoleOf element] indicates the base object of a role. The prefix "RoleOf" on the element ensures that a role object may be distinguished from other objects and that its link to the base object is also distinguishable from the additional properties that are characteristics or other data of the role.

   NIEM does not require that there be only one [RoleOf element] within a single type, nor does it require that a particular role object have only a single occurrence of a [RoleOf element]. However, the use of multiple [RoleOf elements] may not make sense in all cases. Many exchanges may restrict [RoleOf elements] to a single occurrence within a type.

10.2.2.3. External adapter types

   There are a variety of commonly used standards that are represented in XML Schema. Such schemas are generally not NIEM-conformant. NIEM-conformant schemas may reference components defined by these external schemas. NIEM-conformant components may be constructed from schema components that are not NIEM-conformant.

   [Definition: external schema]

      An external schema is any schema that is not a supporting schema and that is not NIEM-conformant.

   Note that the supporting schemas structures and appinfo are nonconformant because they define the fundamental framework on which NIEM is built; they are NIEM's support schemas. However, they are not considered external schemas because of their supporting nature and are thus excluded from this definition.

   NIEM-conformant schemas may work with external schemas by creating [adapter types].

   A single method is used to integrate external components into NIEM-conformant schemas: NIEM-conformant types are constructed from the external components.

   Figure 10-6: Use of external components to create a NIEM-conformant type

      Images are omitted from this edition.

   Components defined by external schemas are called external components. A NIEM-conformant type may use external components in a specific way: to construct a NIEM-conformant type from external components. The goal in this method is to preserve as a single unit a set of data that embodies a single concept from an external standard.

   For example, a NIEM-conformant type may be created to represent a bibliographic reference from an external standard. Such an object may be composed of multiple elements and types from the external standard. These pieces are put together to form a single NIEM-conformant type. For example, an element representing an author, a book, and a publisher may be included in a single bibliographic entry.

   A NIEM-conformant type built from these components may be used as any other NIEM- conformant type. That is, elements may be constructed from such a type, and those elements are fully NIEM-conformant.

   To construct such a component, a NIEM-conformant schema must first import an external schema.

   [Rule 10-8] (REF, EXT)

      Within the schema, an element xs:import that imports a namespace defined by an external schema MUST have the application information appinfo:ConformantIndicator, with a value of false.

   Rationale

   Knowledge of the conformance of an imported schema allows processors to understand the semantics of referenced components, without additional processing. Namespaces imported into NIEM-conformant schemas are assumed to be conformant unless otherwise indicated.

   [Rule 10-9] (REF, EXT)

      Within the schema, an element xs:import that imports a namespace defined by an external schema MUST be a documented component.

   Rationale

   A NIEM-conformant schema has well-known documentation points. Therefore, a schema that imports a NIEM-conformant namespace need not provide additional documentation. However, when an external schema is imported, appropriate documentation must be provided at the point of import because documentation associated with external schemas is undefined and variable. In this particular case, documentation of external schemas is required at their point of use in NIEM.

   [Definition: adapter type]

      An adapter type is a NIEM-conformant type that adapts external components for use within NIEM. An adapter type creates a new class of object that embodies a single concept composed of external components. A NIEM-conformant schema defines an adapter type.

   [Rule 10-10] (REF, EXT)

      Within the schema, an adapter type MUST have application information appinfo:ExternalAdapterTypeIndicator with a value of true. A type that is not an adapter type SHALL NOT contain that indicator.

   Rationale

   This rule flags as external adapters those types that may contain external content. This allows for easier processing.

   [Rule 10-11] (REF, EXT)

      Within the schema, an adapter type MUST be an immediate extension of type structures:ComplexObjectType.

   Rationale

   The adapter type must contain the content defined for any NIEM component. The type structures:ComplexObjectType provides such content.

   [Rule 10-12] (REF, EXT)

      Within the schema, an adapter type MUST be composed of only elements and attributes from an external standard.

   Rationale

   An adapter type should contain the information from an external standard to express a complete concept. This expression should be composed of content entirely from an external schema. Most likely, the external schema will be based on an external standard with its own legacy support.

   In the case of an external expression that is in the form of model groups, attribute groups, or types, additional elements and type components may be created in an external schema, and the adapter type may use those components.

   [Rule 10-13] (REF, EXT)

      Within the schema, an element reference used in an adapter type definition MUST be a documented component.

   [Rule 10-14] (REF, EXT)

      Within the schema, an attribute reference used in an adapter type definition MUST be a documented component.

   Rationale

   In normal (conformant) type definition, a reference to an attribute or element is a reference to a documented component. Within an adapter type, the references to the attributes and elements being adapted are references to undocumented components. These components must be documented to provide comprehensibility and interoperability. Since documentation made available by nonconformant schemas is undefined and variable, documentation of these components is required at their point of use, within the conformant schema.

   [Rule 10-15] (REF, EXT)

      Within the schema, an adapter type MUST NOT be extended or restricted.

   Rationale

   Adapter types are meant to stand alone; each type expresses a single concept from an external schema, and adapter types are maintained in separate schemas that only contain adapter types. In this way, processors may easily switch modes, processing NIEM-conformant content in one way, and external content in another.

10.2.2.3.1. External adapter type has complex content

   [Rule 10-16] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)]">
          <sch:assert test="xs:complexContent"
            >An external adapter type definition must be a complex type definition with complex content.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.2.3.2. External adapter type uses extension

   [Rule 10-17] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)
                                          and exists(xs:complexContent)]">
          <sch:assert test="xs:complexContent/xs:extension"
            >An external adapter type definition must be use the extension derivation method.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.2.3.3. External adapter type extends structures:ObjectType

   [Rule 10-18] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)
                                          and exists(xs:complexContent/xs:extension)]">
          <sch:assert test="for $extension in xs:complexContent/xs:extension return
                              resolve-QName($extension/@base, $extension) = xs:QName('structures:ObjectType')"
            >An external adapter type definition MUST extend structures:ObjectType.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.2.3.4. External adapter types use sequence

   [Rule 10-19] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)
                                          and exists(xs:complexContent/xs:extension)]">
          <sch:assert test="exists(xs:complexContent/xs:extension/xs:sequence)"
            >An external adapter type must use sequence as its top-level compositor.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.2.4. Code types

   [Definition: code type]

      A code type is a NIEM object type with a content model that is constrained by one or more enumeration facets.

   These types represent lists of values, each of which has a known meaning beyond the text representation. These values may be meaningful text or may be a string of alphanumeric identifiers that represent abbreviations for literals.

10.2.2.4.1. The name of a code type ends in "CodeType"

   [Rule 10-20] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:let name="has-code-type-name" value="ends-with(@name, 'CodeType')"/>
          <sch:let name="has-code-type-base" value="
              exists(xs:simpleContent[
                exists(xs:*[local-name() = ('extension', 'restriction')
                            and (ends-with(@base, 'CodeSimpleType')
                                 or ends-with(@base, 'CodeType'))])])"/>
          <sch:assert test="$has-code-type-name = $has-code-type-base"
            >A complex type with a [base type] of a code type or code simple type MUST have a name that ends in 'CodeType'.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Using the qualifier Code (e.g. CodeType, CodeSimpleType) immediately identifies a type as representing a fixed list of codes. These types may be handled in specific ways, as lists of codes are expected to have their own lifecycles, including versions and periodic updates. Codes may also have responsible authorities behind them who provide concrete semantic bindings for the code values.

10.2.2.5. Proxy types

10.2.3. Associations

   Within NIEM, an association is a specific relationship between objects. Associations are used when a simple NIEM property is insufficient to model the relationship clearly and when properties of the relationship exist that are not attributable to the objects being related.

   Here is an example of an association in an XML instance:

   Figure 10-7: An association in an instance

      <nc:GuardianAssociation>
        <nc:PersonGuardianReference s:ref="p1"/>
        <nc:PersonDependentReference s:ref="p2"/>
      </nc:GuardianAssociation>
      
      <nc:Person s:id="p1">
        <nc:PersonName>
          <nc:PersonFullName>John Doe</nc:PersonFullName>
        </nc:PersonName>
      </nc:Person>
                
      <nc:Person s:id="p2">
        <nc:PersonName>
          <nc:PersonFullName>Jane Doe</nc:PersonFullName>
        </nc:PersonName>
      </nc:Person>

   This example shows an association between a guardian and a dependent. This relationship is defined by the element nc:GuardianAssociation, whose structure is defined by the type nc:GuardianAssociationType. The type defines what an association relates, but the element defines the actual meaning of the association.

   An example of an association type defined by an XML Schema document follows.

   Note that the NIEM Core schema in NIEM 2.0 defines a type nc:AssociationType, which acts as the base type for all other association types defined within NIEM Core. This is a convention adopted by the NIEM Core namespace but is not a requirement of the NDR. Implementers of NIEM-conformant schemas are not required to base association types on nc:AssociationType.

   Figure 10-8: A definition of an association type

      <xsd:complexType name="AssociationType">
        ...
        <xsd:complexContent>
          <xsd:extension base="s:ComplexObjectType">
          <xsd:sequence>
            <xsd:element ref="nc:AssociationBeginDate" minOccurs="0" maxOccurs="unbounded"/>
            <xsd:element ref="nc:AssociationEndDate" minOccurs="0" maxOccurs="unbounded"/>
          </xsd:sequence>
          </xsd:extension>
        </xsd:complexContent>
      </xsd:complexType>
      
      <xsd:complexType name="GuardianAssociationType">
        ...
        <xsd:complexContent>
          <xsd:extension base="nc:AssociationType">
          <xsd:sequence>
            <xsd:element ref="nc:PersonGuardianReference" minOccurs="0" maxOccurs="unbounded"/>
            <xsd:element ref="nc:PersonDependentReference" minOccurs="0" maxOccurs="unbounded"/>
          </xsd:sequence>
          </xsd:extension>
        </xsd:complexContent>
      </xsd:complexType>
      
      <xsd:element name="GuardianAssociation" type="nc:GuardianAssociationType" nillable="true">
        ...
      </xsd:element>

   This schema fragment shows the definition of a generic AssociationType, which contains a begin and end date. It then defines a specific association type, which contains the structure required to express guardianship. This is followed by the definition of an element that expresses the semantics of the guardian relationship.

   [Definition: association type]

      In a NIEM-conformant schema, an association type is a type that establishes a relationship between objects, along with the properties of that relationship. An association type provides a structure that does not establish existence of an object but instead specifies relationships between objects.

   [Definition: association]

      In a NIEM-conformant schema, an association is an element whose type is an association type.

   [Rule 10-21] (REF, EXT)

      Within the schema, an association type SHALL be a complex type definition that either constitutes a NIEM-conformant component or for which there exists a NIEM-conformant component definition. The NIEM-conformant component definition SHALL have one of the following forms:

         1. Has complex content, is based on the complex type structures:ComplexObjectType, and has application information appinfo:Base of structures:Association.

         2. Is a complex type that is derived from an association type, which is defined according to this rule.

   Rationale

   Associations within reference schemas, extensions schemas, and exchange schemas are easily identifiable as such and have a commonly defined base type. For subset schemas, the NIEM-conformant definition may be located in a primary schema and then identified.

   [Rule 10-22] (REF, EXT)

      Given that an association type defines a relationship between a set of participants, within an association type definition, any element that represents a participant SHALL be a reference element.

   Rationale

   Associations are intended to relate objects defined elsewhere. They are not intended to carry content of participant objects.

10.2.3.1. Association types

10.2.3.1.1. Association types are derived from association types

   [Rule 10-23] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:let name="is-association-type" value="exists(@name[ends-with(., 'AssociationType')])"/>
          <sch:let name="has-association-base-type" value="
            exists(xs:complexContent[
              exists(xs:*[local-name() = ('extension', 'restriction')
                          and exists(@base[ends-with(., 'AssociationType')])])])"/>
          <sch:assert test="$is-association-type = $has-association-base-type"
            >A type MUST have a association type name if an only if it is derived from a association type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Using the qualifier Association immediately identifies a type as representing an association.

10.2.3.2. Association element declarations

10.2.3.2.1. Association element is an element of an association type

   [Rule 10-24] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name)]">
          <sch:assert test="exists(@type[ends-with(., 'AssociationType')])
                            = exists(@name[ends-with(., 'Association')])"
            >An element MUST have a name that ends in 'Association' if and only if it has a type that is a association type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Using the qualifier Association immediately identifies an element as representing an association.

10.2.4. Augmentations

   Sections:

   * Section 10.2.4.1, Augmentable types
   * Section 10.2.4.2, Augmentation point element declarations
   * Section 10.2.4.3, Augmentation point element use
   * Section 10.2.4.4, Augmentation types
   * Section 10.2.4.5, Augmentation element declarations

   Builders of domains and extensions to NIEM distribution schemas need to be able to define extensions to types. However, extension of types by multiple domain schemas and extension schemas proves problematic, as it results in multiple extensions of a single type. XML Schema does not provide for multiple types of an instance;consequently, such a method results in duplication of base type content and a need to resolve "same-as" relationships between the instances of the various derived types.

   Instead, it is preferable for domains and extensions to provide augmentations. These are reusable types and elements of those types, which may be added to an object class, in a single extended type, by the author of a NIEM-conformant schema. This avoids the problem of multiple extended types but allows domains and extensions to define reusable extensions.

   Augmentation types such as j:PersonAugmentationType, where "j" is the prefix for the NIEM Justice domain, http://release.niem.gov/niem/domains/jxdm/5.0/, exist to extend NIEM Core types such as nc:PersonType without creating a new specialized object within the model. Augmentation types are never applied within the model to the types they are designed to augment. Doing so would restrict reusing and combining these augmentations.

   Instead, augmentation should be applied within IEPDs. So in an IEPD (NOT within NIEM), base nc:PersonType may be extended, for example, as my-iepd:PersonType by adding elements a:PersonAugmentation and b:PersonAugmentation. As a result, my-iepd:PersonType will contain all the properties in nc:PersonType plus the properties in both of the elements a:PersonAugmentation and b:PersonAugmentation, which, in turn, each contain their respective sets of subelements.

   All NIEM augmentation types extend the abstract type structures:AugmentationType. Therefore, all augmentation types automatically contain the attributes structures:id and structures:metadata for referencing and metadata, respectively. NIEM also provides the abstract element structures:Augmentation (of type structures:AugmentationType) as the common substitution group head for all augmentation elements. An augmentation element placed into this substitution group can be used in an instance wherever structures:Augmentation occurs in the corresponding IEPD schema. The user must follow NIEM naming conventions for augmentation component names and must place new augmentation elements into the structures:Augmentation substitution group. Further, if an augmentation element cannot be applied to all types in the model, then the user must document those types that the new augmentation element can be applied to using the appinfo:AppliesTo element.

   [Definition: augmentation]

      An augmentation of a NIEM-conformant object type is a block of additional data added to an object type to carry additional data beyond that of the original object definition.

   [Rule 10-25] (REF, EXT)

      An augmentation type:

         1. SHALL be transitively derived from structures:AugmentationType.

         2. SHALL contain elements that represent properties to be applied to a base type.

   Rationale

   A base type is the type to which an augmentation is to be applied. An augmentation may be applied to any number of types. Base types are assigned by augmentation elements.

   [Rule 10-26] (REF, EXT)

      Within the schema, an augmentation element definition:

         1. SHALL have a type that is an augmentation type.

         2. SHALL use the substitutionGroup attribute such that it is transitively substitutable for the element structures:Augmentation.

      An element that is not an augmentation element SHALL NOT meet either of the above criteria.

   Rationale

   An augmentation is trivially identifiable as such. The use of the common structures:Augmentation element allows message builders to optionally delay specifying augmentations to be applied to a type until runtime.

   [Rule 10-27] (REF, EXT)

      Within the schema, an element definition for an augmentation element MAY contain one or more instances of the element appinfo:AppliesTo as application information to specify types to which the augmentation element applies.

   [Rule 10-28] (REF, EXT)

      Within the schema, an element definition for an augmentation element that does not contain any instances of the element appinfo:AppliesTo MAY be applied to any object or association type.

   Rationale

   These rules allow schema builders to establish applicability for augmentations. An augmentation may be applicable to specific types.

   Users who wish to apply an augmentation type to a given object type may do so by creating a new augmentation element, applicable to the object type.

10.2.4.1. Augmentable types

   [Definition: augmentable type]

      An augmentable type is any [complex type definition] that meets all of these criteria:

         *  It is defined by either a [conformant reference schema document] or by an [conformant extension schema document].

         *  It is either:

               *  an [association type], or

               *  an [object type] that has complex content and is not an external adapter type.

10.2.4.1.1. Augmentable type has augmentation point

   [Rule 10-29] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType[
                             exists(@name[
                               not(ends-with(., 'MetadataType'))
                               and not(ends-with(., 'AugmentationType'))])
                             and empty(@appinfo:externalAdapterTypeIndicator)
                             and exists(child::xs:complexContent)]">
          <sch:let name="augmentation-point-qname" 
                   value="QName(nf:get-target-namespace(.),
                                replace(./@name, 'Type$', 'AugmentationPoint'))"/>
          <sch:assert test="count(xs:complexContent/xs:extension/xs:sequence/xs:element[
                                    exists(@ref[resolve-QName(., ..) = $augmentation-point-qname])]) = 1"
            >An augmentable type MUST contain exactly one reference its augmentation point element.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.4.2. Augmentation point element declarations

10.2.4.2.1. An augmentation point corresponds to an augmentable type

   [Rule 10-30] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name[
                                       matches(., 'AugmentationPoint$')])]">
          <sch:let name="element-name" value="@name"/>
          <sch:assert test="exists(
                              parent::xs:schema/xs:complexType[
                                @name = replace($element-name, 'AugmentationPoint$', 'Type')
                                and exists(@name[
                                        not(ends-with(., 'MetadataType'))
                                        and not(ends-with(., 'AugmentationType'))])
                                      and empty(@appinfo:externalAdapterTypeIndicator)
                                      and exists(child::xs:complexContent)])"
            >A schema document defining an augmentation point element MUST also define a corresponding [augmentable type].</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.4.2.2. An augmentation point has no type

   [Rule 10-31] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name[
                                       matches(., 'AugmentationPoint$')])]">
          <sch:assert test="empty(@type)"
              >An augmentation point element MUST have no type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   There is no rule requiring that the augmentation element is abstract, as that is implied by the lack of @type.

10.2.4.2.3. An augmentation point has no substitution group

   [Rule 10-32] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name[
                                       matches(., 'AugmentationPoint$')])]">
          <sch:assert test="empty(@substitutionGroup)"
              >An augmentation point element MUST have no substitution group.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.4.3. Augmentation point element use

10.2.4.3.1. Augmentation element may only be referenced by its type

   [Rule 10-33] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType//xs:element[exists(@ref[
                             matches(local-name-from-QName(resolve-QName(., ..)), 'AugmentationPoint$')]) ]">
      
          <sch:assert test="QName(nf:get-target-namespace(ancestor::xs:complexType[1]), ancestor::xs:complexType[1]/@name)
                            = QName(namespace-uri-from-QName(resolve-QName(@ref, .)), 
                     replace(local-name-from-QName(resolve-QName(@ref, .)), 'AugmentationPoint$', 'Type'))"
            >An augmentation element MUST only be referenced by its corresponding type.</sch:assert>
        </sch:rule>
      </sch:pattern>            

10.2.4.3.2. Augmentation reference is optional

   [Rule 10-34] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType//xs:element[exists(@ref[
                                 matches(local-name-from-QName(resolve-QName(., ..)), 'AugmentationPoint$')]) ]">
          <sch:assert test="exists(@minOccurs) and xs:integer(@minOccurs) = 0"
              >An augmentation element particle MUST have attribute minOccurs equal to 0.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.4.3.3. Augmentation reference is unbounded

   [Rule 10-35] (REF)

      <sch:pattern>
        <sch:rule context="xs:complexType//xs:element[exists(@ref[
                                 matches(local-name-from-QName(resolve-QName(., ..)), 'AugmentationPoint$')]) ]">
          <sch:assert test="exists(@maxOccurs) and string(@maxOccurs) = 'unbounded'"
             >An augmentation element particle MUST have attribute maxOccurs set to unbounded.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.4.3.4. Augmentation reference must be last particle

   [Rule 10-36] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType//xs:element[exists(@ref[
                                 matches(local-name-from-QName(resolve-QName(., ..)), 'AugmentationPoint$')]) ]">
          <sch:assert test="empty(following-sibling::*)"
             >An augmentation element particle MUST be the last element atom in its content model.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.2.4.4. Augmentation types

   [Definition: augmentation type]

      An augmentation type is a complex type that provides a reusable block of data that may be added to object types or association types.

10.2.4.4.1. Augmentation type name ends in "AugmentationType"

   [Rule 10-37] (REF, EXT)

      A [schema component] has a name that ends in "AugmentationType" if and only if it is a [complex type definition] that defines an [augmentation type].

10.2.4.4.2. Augmentation type derived from augmentation type

   [Rule 10-38] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType[@name[ends-with(., 'AugmentationType')]]">
          <sch:assert test="xs:complexContent/
                              xs:*[self::xs:extension or self::xs:restriction]/
                                @base[resolve-QName(., ..) = xs:QName('structures:AugmentationType')
                                      or ends-with(., 'AugmentationType')]"
            >The [base type definition] of an [augmentation type] MUST be either structures:AugmentationType or an [augmentation type].</sch:assert>
        </sch:rule>
      </sch:pattern>

   The [base type definition] of an [augmentation type] is required to be from a conformant namespace by [Rule 11-3], below.

10.2.4.4.3. Augmentation types are derived from augmentation types

   [Rule 10-39] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:let name="is-augmentation-type" value="exists(@name[ends-with(., 'AugmentationType')])"/>
          <sch:let name="has-augmentation-base-type" value="
            exists(xs:complexContent[
              exists(xs:*[local-name() = ('extension', 'restriction')
                          and exists(@base[ends-with(., 'AugmentationType')])])])"/>
          <sch:assert test="$is-augmentation-type = $has-augmentation-base-type"
            >A type MUST have a augmentation type name if an only if it is derived from a augmentation type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Using the qualifier Augmentation immediately identifies a type as representing an augmentation.

10.2.4.5. Augmentation element declarations

10.2.4.5.1. Augmentation element is an element of an augmentation type

   [Rule 10-40] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name)]">
          <sch:assert test="exists(@type[ends-with(., 'AugmentationType')])
                            = exists(@name[ends-with(., 'Augmentation')])"
            >An element MUST have a name that ends in 'Augmentation' if and only if it has a type that is a augmentation type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Using the qualifier Augmentation immediately identifies an element as representing an augmentation.

10.2.5. Metadata

10.2.5.1. Metadata types

   Within NIEM, metadata is defined as "data about data." This may include information such as the security of a piece of data or the source of the data. These pieces of metadata may be composed into a metadata type. The types of data to which metadata may be applied may be constrained.

   [Definition: metadata type]

      A metadata type describes data about data, that is, information that is not descriptive of objects and their relationships, but is descriptive of the data itself. It is useful to provide a general mechanism for data about data. This provides required flexibility to precisely represent information.

   [Rule 10-41] (REF, EXT)

      Within the schema, a metadata type SHALL contain elements appropriate for a specific class of data about data.

   [Rule 10-42] (REF, EXT)

      Within the schema, a metadata type and only a metadata type SHALL be derived directly from structures:MetadataType.

   Rationale

   A metadata type establishes a specific, named aggregation of data about data. Any type derived from structures:MetadataType is a metadata type. Metadata types should not be derived from other metadata types. Such metadata types should be used asis and additional metadata types defined for additional content.

   [Rule 10-43] (REF, EXT)

      Within the schema, a metadata type MAY have application information appinfo:AppliesTo, indicating the NIEM-conformant object, association, or external adapter types to which the metadata applies.

   [Rule 10-44] (REF, EXT)

      Within the schema, a metadata type that does not have application information appinfo:AppliesTo MAY be applied to any object type, association type, or external adapter type.

   Rationale

   Metadata may be constrained to be applicable to only specific types, or it may be defined to be applicable to any type. The source of a piece of data and the security classification of a piece of data are examples of metadata that may be considered globally applicable.

10.2.5.2. Metadata types are derived from metadata types

   [Rule 10-45] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType">
          <sch:let name="is-metadata-type" value="exists(@name[ends-with(., 'MetadataType')])"/>
          <sch:let name="has-metadata-base-type" value="
            exists(xs:complexContent[
              exists(xs:*[local-name() = ('extension', 'restriction')
                          and exists(@base[ends-with(., 'MetadataType')])])])"/>
          <sch:assert test="$is-metadata-type = $has-metadata-base-type"
            >A type MUST have a metadata type name if an only if it is derived from a metadata type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Using the qualifier Metadata immediately identifies a type as representing metadata.

10.3. Container elements

   All NIEM properties establish a relationship between the object holding the property and the value of the property. For example, an activity object of type nc:ActivityType may have an element nc:ActivityDescriptionText. This element will be of type nc:TextType and represents a NIEM property owned by that activity object. An occurrence of this element within an activity object establishes a relationship between the activity object and the text: the text is the description of the activity.

   In a NIEM-conformant instance, an element establishes a relationship between the object that contains it and the element's value. This relationship between the object and the element may be semantically strong, such as the text description of an activity in the previous example, or it may be semantically weak, with its exact meaning left unstated. In NIEM, the contained element involved in a weakly defined semantic relationship is commonly referred to as a container element.

   A container element establishes a weakly defined relationship with its containing element. For example, an object of type nc:ItemDispositionType may have a container element nc:Item of type nc:ItemType. The container element nc:Item does not establish what relationship exists between the object of nc:ItemDispositionType and itself. There could be any of a number of possible semantics between an object and the value of a container element. It could be a contained object, a subpart, a characteristic, or some other relationship. The appearance of this container element inside the nc:ItemDispositionType merely establishes that the disposition has an item.

   The name of the container element is usually based on the NIEM type that defines it: nc:PersonType uses a container element nc:Person, while nc:ActivityType uses a container element nc:Activity. The concept of an element as a container element is a notional one.

   There are no formalized rules addressing what makes up a container element. A container element is vaguely defined and carries very little semantics about its context and its contents. Accordingly, there is no formal definition of container elements in NIEM: There are no specific artifacts that define a container element; there are no appinfo or other labels for container elements.

   The appearance of a container element within a NIEM type carries no additional semantics about the relationship between the property and the containing type. The use of container elements indicates only that there is a relationship; it does not provide any semantics for interpreting that relationship.

   For example, a NIEM container element nc:Person would be associated with the NIEM type nc:PersonType. The use of the NIEM container element nc:Person in a containing NIEM type indicates that a person has some association with the instances of the containing NIEM type. But because the nc:Person container element is used, there is no additional meaning about the association of the person and the instance containing it. While there is a person associated with the instance, nothing is known about the relationship except its existence.

   The use of the Person container element is in contrast to a NIEM property named nc:AssessmentPerson, also of NIEM type nc:PersonType. When the NIEM property nc:AssessmentPerson is contained within an instance of a NIEM type, it is clear that the person referenced by this property was responsible for an assessment of some type, relevant to the exchange being modeled. The more descriptive name, nc:AssessmentPerson, gives more information about the relationship of the person with the containing instance, as compared with the semantic-free implications associated with the use of the nc:Person container element.

   When a NIEM-conformant schema requires a new container element, it may define a new element with a concrete type and a general name, with general semantics. Any schema may define a container element when it requires one. NIEM-conformant schemas may also create reference elements with general semantics. For example, an element nc:PersonReference will carry the same general, container-like meaning as an element nc:Person.

10.4. Naming rules

   This section outlines the rules used to create names for NIEM data components previously discussed in this document. Data component names must be understood easily both by humans and by machine processes. These rules improve name consistency by restricting characters, terms, and syntax that could otherwise allow too much variety and potential ambiguity. These rules also improve readability of names for humans, facilitate parsing of individual terms that compose names, and support various automated tasks associated with dictionary and controlled vocabulary maintenance.

10.4.1. Extension of XSD namespace simple types

   [Rule 10-46] (REF, EXT)

      Within the schema, a complex type that is a direct extension of a simple type from the XML Schema namespace simple type MAY use the same local name as the simple type if and only if the extension adds no content other than the attribute group structures:SimpleObjectAttributeGroup.

   Rationale

   It is useful to build complex type bases for further extension. The NIEM distribution proxy schema xsd.xsd provides complex type bases for some of the simple types in the XML Schema namespace. However, the complex types in this proxy schema reuse the local names of the simple types they extend, even though the simple type names may not be NIEM-conformant. Requiring name changes for those NIEM-provided complex type bases would work against user understanding, for those already familiar with the names of the XML Schema namespace simple types being extended.

10.4.2. Usage of English

   [Rule 10-47] (REF, EXT)

      The name of any XML Schema component defined by the schema SHALL be composed of words from the English language, using the prevalent U.S. spelling, as provided by [OED].

   Rationale

   The English language has many spelling variations for the same word. For example, American English "program" has a corresponding British spelling "programme." This variation has the potential to cause interoperability problems when XML components are exchanged because of the different names used by the same elements. Providing users with a dictionary standard for spelling will mitigate this potential interoperability issue.

10.4.3. Characters in names

   [Rule 10-48] (REF, EXT)

      The name of any XML Schema component defined by the schema SHALL contain only the following characters:

         *  Upper-case letters ("A"-"Z").

         *  Lower-case letters ("a"-"z").

         *  Digits ("0"-"9").

         *  Hyphen ("-").

      Other characters, such as the underscore ("_") character and the period (".") character SHALL NOT appear in component names in NIEM-conformant schemas.

   [Rule 10-49] (REF, EXT)

      The hyphen character ("-") MAY appear in component names only when used as a separator between parts of a single word, phrase, or value, which would otherwise be incomprehensible without the use of a separator.

   Rationale

   Names of standards and specifications, in particular, tend to consist of series of discrete numbers. Such names require some explicit separator to keep the values from running together. The separator used within NIEM is the hyphen.

   Names of NIEM components follow the rules of XML Schema, by [Rule 5-3]. NIEM components also must follow the rules specified for each type of XML Schema component.

10.4.4. Character case

   Names of conformant components use the camel case formatting convention, as described by [WP CamelCase]:

      CamelCase (camel case) or medial capitals is the practice of writing compound words or phrases such that each word or abbreviation begins with a capital letter. Camel case may start with a capital or, especially in programming languages, with a lowercase letter.

10.4.4.1. Names use camel case

   [Rule 10-50] (REF, EXT)

      The name of any XML Schema component defined by the schema SHALL use the camel case formatting convention.

   [Rule 10-51] (REF, EXT)

      Within the schema, any attribute declaration SHALL have a name that begins with a lower-case letter ("a"-"z").

   [Rule 10-52] (REF, EXT)

      Within the schema, any XML Schema component other than an attribute declaration SHALL have a name that begins with an upper-case letter ("A"-"Z").

   The foregoing rules establish lowerCamelCase for all NIEM components that are XML attributes and UpperCamelCase for all NIEM components that are types, elements, or groups.

10.4.5. Use of acronyms and abbreviations

   Acronyms and abbreviations have the ability to improve readability and comprehensibility of large, complex, or frequently used terms. They also obscure meaning and impair understanding when their definitions are not clear or when they are used injudiciously. They should be used with great care. Acronyms and abbreviations that are used must be documented and used consistently.

   [Rule 10-53] (REF, EXT)

      The schema MUST consistently use approved acronyms, abbreviations, and word truncations within defined names. The approved shortened forms are defined in Table Table 10-1, Abbreviations used in NIEM core names.

   {remove this table}

   Table 10-1: Abbreviations used in NIEM core names

      Abbreviation|Full Meaning

      ANSI|American National Standards Institute

      CMV|Commercial Motor Vehicle

      DEA|Drug Enforcement Agency

      DNA|Deoxyribonucleic Acid

      FGI|Foreign Government Information

      FIPS|Federal Information Processing Standard

      IC|Intelligence Community

      ID|Identifier

      IP|Internet Protocol

      ISO|International Standards Organization

      LIS|NCIC code list for license state

      LSTA|NCIC code list for state/country index

      MCO|Manufacturer's Certificate of Origin

      MGRS|Military Grid Reference System

      MSRP|Manufacturer's Suggested Retail Price

      NANP|North American Numbering Plan

      NCIC|National Crime Information Center

      NCTC|National Counter Terrorist Center

      NIBRS|National Incident Based Reporting System

      NLETS|The International Justice & Public Safety Information Sharing Network (formerly known as the National Law Enforcement Teletype System)

      ORI|Organization Identifier (Orion)

      RES|NCIC code list for registration state for boat registrations

      RF|Radio Frequency

      SIM|Subscriber Identity Module

      SSN|Social security number

      TYP|NCIC code list for gun type

      TYPO|NCIC code list for ORI type

      URI|Uniform Resource Identifier

      US|United States

      UTM|Universal Transverse Mercator

      VIN|Vehicle Identification Number

      VINA|Vehicle Identification Number Analysis

   Rationale

   Consistent, controlled, and documented abridged terms that are used frequently and/or tend to be lengthy can support readability, clarity, and reduction of name length.

10.4.6. Word forms

   [Rule 10-54] (REF, EXT)

      A noun used as a term in the name of an XML Schema component MUST be in singular form unless the concept itself is plural.

   [Rule 10-55] (REF, EXT)

      A verb used as a term in the name of an XML Schema component MUST be used in the present tense unless the concept itself is past tense.

   [Rule 10-56] (REF, EXT)

      Articles, conjunctions, and prepositions SHALL NOT be used in NIEM component names except where they are required for clarity or by standard convention.

   Rationale

   Articles (e.g., a, an, the), conjunctions (e.g., and, or, but), and prepositions (e.g., at, by, for, from, in, of, to) are all disallowed in NIEM component names, unless they are required. For example, PowerOfAttorneyCode requires the preposition. These rules constrain slight variations in word forms and types to improve consistency and reduce potentially ambiguous or confusing component names.

10.4.7. Name generation

   Elements in NIEM-conformant schemas are given names that follow a specific pattern. This pattern comes from [ISO 11179-5].

   [Rule 10-57] (REF, EXT)

      Except as specified elsewhere in this document, any element or attribute defined within the schema SHALL have a name that takes the form:

         *  Object-class qualifier terms (0 or more).

         *  An object class term (1).

         *  Property qualifier terms (0 or more).

         *  A property term (1).

         *  Representation qualifier terms (0 or more).

         *  A representation term (1).

   Rationale

   Consistent naming rules are helpful for users who wish to understand components with which they are unfamiliar, as well as for users to find components with known semantics. This rule establishes the basic structure for an element or attribute name, in line with the rules for names under [ISO 11179-5]. Note that many elements with complex type should not have a representation term.

10.4.8. Object-class term

   The NIEM adopts an object-oriented approach to representation of data. Object classes represent what [ISO 11179-5] refers to as "things of interest in a universe of discourse that may be found in a model of that universe." An object class or object term is a word that represents a class of real-world entities or concepts. An object-class term describes the applicable context for a NIEM component.

   [Rule 10-58] (REF, EXT)

      The object-class term of a NIEM component SHALL consist of a term identifying a category of concrete concepts or entities.

   Rationale

   The object-class term indicates the object category that this data component describes or represents. This term provides valuable context and narrows the scope of the component to an actual class of things or concepts.

   Example

   Concept term: Activity

   Entity term: Vehicle

10.4.9. Property term

   Objects or concepts are usually described in terms of their characteristic properties, data attributes, or constituent subparts. Most objects can be described by several characteristics. Therefore, a property term in the name of a data component represents a characteristic or subpartof an object class and generally describes the essence of that data component.

   [Rule 10-59] (REF, EXT)

      A property term SHALL describe or represent a characteristic or subpart of an entity or concept.

   Rationale

   The property term describes the central meaning of the data component.

10.4.10. Qualifier terms

   Qualifier terms modify object, property, representation, or other qualifier terms to increase semantic precision and reduce ambiguity. Qualifier terms may precede or succeed the terms they modify. The goal for the placement of qualifier terms is to generally follow the rules of ordinary English while maintaining clarity.

   [Rule 10-60] (REF, EXT)

      Multiple qualifier terms MAY be used within a component name as necessary to ensure clarity and uniqueness within its namespace and usage context.

   [Rule 10-61] (REF, EXT)

      The number of qualifier terms SHOULD be limited to the absolute minimum required to make the component name unique and understandable.

   [Rule 10-62] (REF, EXT)

      The order of qualifiers SHALL NOT be used to differentiate names.

   Rationale

   Very large vocabularies may have many similar and closely related properties and concepts. The use of object, property, and representation terms alone is often not sufficient to construct meaningful names that can uniquely distinguish such components. Qualifier terms provide additional context to resolve these subtleties. However, swapping the order of qualifiers rarely (if ever) changes meaning; qualifier ordering is no substitute for meaningful terms.

10.4.11. Representation terms

   The representation terms for a component name serve several purposes in NIEM:

      1. It can indicate the style of component. For example, types are clearly labeled with the representation term Type.

      2. It helps prevent name conflicts and confusion. For example, elements and types may not be given the same name.

      3. It indicates the nature of the value carried by element. Labeling elements and attributes with a notional indicator of the content eases discovery and comprehension.

   [Rule 10-63] (REF, EXT)

      If any word in the representation term is redundant with any word in the property term, one occurrence SHOULD be deleted.

   Rationale

   This rule, carried over from 11179, is designed to prevent repeating terms unnecessarily within component names. For example, this rule allows designers to avoid naming an element "PersonFirstNameName."

   The valid value set of a data element or value domain is described by the representation term. NIEM uses a standard set of representation terms in the representation portion of a NIEM-conformant component name. Table Table 11-1, Representation terms, below, lists the primary representation terms and a definition for the concept associated with the use of that term. The table also lists secondary representation terms that may represent more specific uses of the concept associated with the primary representation term.

   [Rule 10-64] (REF, EXT)

      Within the schema, the name of an element declaration that is of simple content MUST use a representation term found in Table Table 11-1, Representation terms.

   [Rule 10-65] (REF, EXT)

      Within the schema, the name of an element declaration that is of complex content, and that corresponds to a concept listed in Table Table 11-1, Representation terms, MUST use a representation term from that table.

   [Rule 10-66] (REF, EXT)

      Within the schema, the name of an element declaration that is of complex content and that does not correspond to a concept listed in Table Table 11-1, Representation terms MUST NOT use a representation term.

   Rationale

   An element that represents a value listed in the table should have a representation term. It should do so even if its type is complex with multiple parts. For example, a type with multiple fields may represent a sound binary, a date, or a name.

10.5. Machine-readable annotations

   XML Schema provides application information schema components to provide for automatic processing and machine-readable content for schemas. NIEM utilizes application information to convey information that is outside schema definition and outside human-readable text definitions. NIEM uses application information to convey high-level data model concepts and additional syntax to support the NIEM conceptual model and validation of NIEM-conformant XML instances.

   XML elements, attributes, and text content may appear as machine-readable annotations within an XML Schema document. The methods provided by XML Schema for machine-readable annotations are:

      1. An element in the XML Schema namespace (e.g., xs:schema, xs:complexType, ...) may carry attributes from namespaces other than the XML Schema namespace. By the rules of XML Schema, any XML Schema element may have attributes that are from other namespaces. These attributes do not participate in XML Schema validation, but may carry information useful to tools that process schemas. In [XML Schema Structures], these attributes are described in the XML Representation summary of XML Schema elements as "{any attributes with non-schema namespace . . .}", for example in section 3.2.2, XML Representation of Attribute Declaration Schema Components.

      2. XML Schemas may include xs:appinfo elements, which may include arbitrary XML content. This XML does not participate in XML Schema validation, but may communicate useful information to schema readers or processors. These are described by [XML Schema Structures] in section 3.13.1, The Annotation Schema Component and section 3.13.2, XML Representation of Annotation Schema Components.

   NIEM defines the term "machine-readable annotation" to normatively refer to such annotations within XML Schema documents:

   [Definition: machine-readable annotation]

      An information item within a schema is defined to be a machine-readable annotation when all of the following are true:

         1. It is one of the following:

               1. It is an element information item that is a child of an xsd:appinfo element.

               2. It is an attribute information item that satisfies the "{any attributes with non- schema namespace . . .}" clause within the declaration of an XML Schema element.

         2. The namespace name property of the item is not the XML namespace, XML Schema namespace, or the XSI namespace.

   Attributes from the XML namespace, the XML Schema namespace, and the XML Schema instance namespace have special meanings within XML Schema, and may have effects on validation, and so are not considered machine-readable annotations.

   [Definition: application information]

      A component is said to have application information of some element $element when the XML Schema element that defines the component has an immediate child element xs:annotation, which has an immediate child element xs:appinfo, which has as an immediate child the element $element.

   If a component is described as having some [application information], this means that the elements in question appear in an xs:appinfo annotation of the element that defines the component.

   The majority of uses of application information from the [appinfo namespace] are described in the modeling rules for the specific component.

10.5.1. Machine-readable annotations are valid

   [Rule 10-67] (REF, EXT)

      Every element information item or attribute information item that appears as a machine-readable annotation in a schema MUST be a valid instance, according to its specification.

   The specification for an element or attribute may be via an XML Schema, a Schematron schema, via a DTD, by some other specification, or by other means. This rule is intended to allow NIEM schema developers to leverage relevant vocabularies without being limited by the vocabulary's method of specification, while ensuring that developers do not subvert or misuse those vocabularies.

10.5.2. The NIEM appinfo namespace

   NIEM defines a single namespace that holds components for use in NIEM-conformant schema application information. This namespace is referred to as the [appinfo namespace].

   [Definition: appinfo namespace]

      The appinfo namespace is the namespace represented by the URI "http://release.niem.gov/niem/appinfo/3.0/".

   The [appinfo namespace] defines attributes which provide additional semantics for components built by NIEM-conformant schemas. The XML Schema document for the appinfo namespace appears in Appendix C, Appinfo namespace, below.

10.5.2.1. Deprecation

   The appinfo schema provides a construct for indicating that a construct is deprecated. A deprecated component is one whose use is not recommended. A deprecated component may be kept in a schema for support of older versions but should not be used in new efforts. A deprecated component may be removed, replaced, or renamed in a later version of a namespace.

   [Definition: deprecated component]

      A deprecated component is one whose use is not recommended, yet which is maintained in the schema for compatibility with previous versions of the namespace.

10.5.2.1.1. A component marked as deprecated is a deprecated component

   [Rule 10-68] (REF, EXT)

      A [schema component] that has an attribute appinfo:deprecated with a value of "true" SHALL be a [deprecated component].

   Deprecation can allow version management to be more consistent; versions of schema may be incrementally improved without introducing validation problems and incompatibility. As XML Schema lacks a deprecation mechanism, NIEM defines such a mechanism.

10.5.2.1.2. Deprecated annotates schema component

   [Rule 10-69] (REF, EXT)

      <sch:pattern>
        <sch:rule context="*[exists(@appinfo:deprecated)]">
          <sch:assert test="namespace-uri-from-QName(node-name(.)) = xs:anyURI('http://www.w3.org/2001/XMLSchema')"
                  >The attribute appinfo:deprecated MUST be owned by an element with a namespace name <namespace-uri-for-prefix>xs</namespace-uri-for-prefix>.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.5.2.2. External import indicator annotates import

   [Rule 10-70] (REF, EXT)

      <sch:pattern>
        <sch:rule context="*[exists(@appinfo:externalImportIndicator)]">
          <sch:assert test="exists(self::xs:import)"
              >The attribute {http://release.niem.gov/niem/appinfo/3.0/}externalImportIndicator MUST be owned by an element xs:import.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.5.2.3. External adapter type indicator annotates complex type

   [Rule 10-71] (REF)

      <sch:pattern>
        <sch:rule context="*[exists(@appinfo:externalAdapterTypeIndicator)]">
          <sch:assert test="exists(self::xs:complexType)"
                  >The attribute appinfo:externalAdapterTypeIndicator MUST be owned by an element xs:complexType.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.5.2.4. Applies to types annotation

10.5.2.4.1. Applies to types annotates metadata element

   [Rule 10-72] (REF, EXT)

      <sch:pattern>
        <sch:rule context="*[exists(@appinfo:appliesToTypes)]">
          <sch:assert test="exists(self::xs:element[exists(@name)
                                     and ends-with(@name, 'Metadata')])"
            >The attribute appinfo:appliesToTypes MUST be owned by a metadata element.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.5.2.4.2. Applies to types indicates elements

   [Rule 10-73] (SET)

      <sch:pattern>
        <sch:rule context="*[exists(@appinfo:appliesToTypes)]">
          <sch:assert test="every $item in tokenize(normalize-space(@appinfo:appliesToTypes), ' ') satisfies
                              exists(nf:resolve-type(., resolve-QName($item, .)))"
            >Every item in @appinfo:appliesToTypes MUST resolve to a type.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.5.2.5. Applies to elements annotation

10.5.2.5.1. Applies to elements annotates metadata element

   [Rule 10-74] (REF, EXT)

      <sch:pattern>
        <sch:rule context="*[exists(@appinfo:appliesToElements)]">
          <sch:assert test="exists(self::xs:element[
                                exists(@name)
                                and ends-with(@name, 'Metadata')])"
                  >The attribute appinfo:appliesToElements MUST be owned by a metadata element.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.5.2.5.2. Applies to elements indicates elements

   [Rule 10-75] (SET)

      <sch:pattern>
        <sch:rule context="*[exists(@appinfo:appliesToElements)]">
          <sch:assert test="every $item in tokenize(normalize-space(@appinfo:appliesToElements), ' ') satisfies
                              count(nf:resolve-element(., resolve-QName($item, .))) = 1"
            >Every item in @appinfo:appliesToElements must resolve to an element.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.5.3. The NIEM local terminology namespace

10.5.3.1. LocalTerm annotates schema

   [Rule 10-76] (REF, EXT)

      <sch:pattern>
        <sch:rule context="term:LocalTerm">
          <sch:assert test="parent::xs:appinfo[parent::xs:annotation[parent::xs:schema]]"
              >The element {http://release.niem.gov/niem/localTerminology/3.0/}LocalTerm MUST be application information an an element xs:schema.</sch:assert>
        </sch:rule>
      </sch:pattern>

10.5.3.2. LocalTerm has literal or definition

   [Rule 10-77] (REF, EXT)

      <sch:pattern>
        <sch:rule context="term:LocalTerm">
          <sch:assert test="exists(@literal) or exists(@definition)"
                  >The element {http://release.niem.gov/niem/localTerminology/3.0/}LocalTerm MUST have a literal or definition.</sch:assert>
        </sch:rule>
      </sch:pattern>

11. Rules for NIEM modeling, by XML Schema component

   This section focuses on building NIEM data models using XML schema. Whereas Section 9, Rules for a NIEM profile of XML Schema, above, addressed shrinking the XML Schema definition language to a smaller set of features, this section constructs new NIEM-specific features to address modeling and interoperability problems. This includes naming rules, categories of types, and augmentations.

11.1. Type definition components

11.1.1. Name of type ends in "Type"

   [Rule 11-1] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType[exists(@name)
                             and exists(xs:simpleContent/xs:extension/@base)
                             and (for $extension in xs:simpleContent/xs:extension,
                                      $base-qname in resolve-QName($extension/@base, $extension) return
                                    $base-qname = QName('http://www.w3.org/2001/XMLSchema', @name))]">
          <sch:report test="false()">The name of a proxy type does not end in "Type".</sch:report>
        </sch:rule>
        <sch:rule context="xs:*[(self::xs:simpleType or self::xs:complexType) and exists(@name)]">
          <sch:assert test="ends-with(@name, 'Type')"
            >A type definition schema component that does not define a proxy type MUST have a name that ends in "Type".</sch:assert>
        </sch:rule>
      </sch:pattern>

   Use of the representation term "Type" immediately identifies XML types in a NIEM-conformant schema and prevents naming collisions with corresponding XML elements and attributes. The exception for proxy types ensures that simple NIEM-compatible uses of base XML Schema types are familiar to people with XML Schema experience.

   Note that the first sch:rule and subsequent sch:report serve to provide an exception to the rule for proxy types. It does not establish a constraint on the data.

11.1.2. Name of type is in upper camel case

   {Revise rule name to identify the exception for proxy types.}

   [Rule 11-2] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:complexType[exists(@name)
                             and exists(xs:simpleContent/xs:extension/@base)
                             and (for $extension in xs:simpleContent/xs:extension,
                                      $base-qname in resolve-QName($extension/@base, $extension) return
                                    $base-qname = QName('http://www.w3.org/2001/XMLSchema', @name))]">
          <sch:report test="false()">The name of a proxy type is not upper camel case.</sch:report>
        </sch:rule>
        <sch:rule context="xs:*[(self::xs:simpleType or self::xs:complexType) and exists(@name)]">
          <sch:assert test="matches(@name, '^([A-Z][A-Za-z0-9\-]*)+$')"
            >A type definition schema component that does not define a proxy type MUST be in upper camel case.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Note that the first sch:rule and q subsequent sch:report serve to provide an exception to the rule for proxy types. It does not establish a constraint on the data.

11.1.3. Type definition hierarchy

11.1.3.1. Base type definition defined by conformant schema

   [Rule 11-3] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:*[exists(@base)]">
          <sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@base, .))"/>
          <sch:assert test="$namespace = (nf:get-target-namespace(.), xs:anyURI('http://www.w3.org/2001/XMLSchema'))
                            or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                          and $namespace = xs:anyURI(@namespace)
                                          and empty(@appinfo:externalImportIndicator)])"
            >The [base type definition] of a [type definition] MUST have the target namespace or the XML Schema namespace or a namespace that is imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.1.4. Simple type definition

11.1.4.1. Name of simple type ends in "SimpleType"

   [Rule 11-4] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:simpleType[@name]">
          <sch:assert test="ends-with(@name, 'SimpleType')"
            >A simple type definition schema component MUST have a name that ends in "SimpleType".</sch:assert>
        </sch:rule>
      </sch:pattern>

   Specific uses of type definitions have similar syntax but very different effects on data definitions. Schemas that clearly identify complex and simple type definitions are easier to understand without tool support. This rule ensures that names of simple types end in SimpleType.

11.1.4.2. Name of simple type is upper camel case

   [Rule 11-5] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:simpleType[exists(@name)]">
          <sch:assert test="matches(string(@name), '^([A-Z][A-Za-z0-9\-]*)+$')"
            >The name of a simple type definition schema component MUST be upper camel case.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.1.4.3. Derivation by list

11.1.4.3.1. Use lists only when data is uniform

   [Rule 11-6] (REF, EXT)

      Within the schema, a simple type definition that uses xs:list SHOULD NOT be defined if any member of the list requires a property or metadata that is different than other members of the list. All members of the list SHOULD have the same metadata, and should be related via the same properties.

   The use of lists should be reserved for cases where the data is fairly uniform.

   Items in a list are not individually addressable by NIEM metadata techniques. The items are also not individually referencable by elements or attributes; one will have a value of the entire list, including all the items in the list. NIEM provides no method for individually addressing an item in a list. If an individual item in a list needs to be marked up in a manner different than other items in the list, the use of individual elements may be preferred to the definition of a list simple type.

11.1.4.3.2. List item type defined by conformant schemas

   [Rule 11-7] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:list[exists(@itemType)]">
          <sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@itemType, .))"/>
          <sch:assert test="$namespace = (nf:get-target-namespace(.), xs:anyURI('http://www.w3.org/2001/XMLSchema'))
                            or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                          and $namespace = xs:anyURI(@namespace)
                                          and empty(@appinfo:externalImportIndicator)])"
            >The item type of a list simple type definition MUST have a target namespace equal to the target namespace of the XML Schema document within which it is defined, or a namespace that is imported as conformant by the schema document within which it is defined.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.1.4.4. Derivation by union

11.1.4.4.1. Union member types defined by conformant schemas

   [Rule 11-8] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:union[exists(@memberTypes)]">
          <sch:assert test="every $qname in tokenize(normalize-space(@memberTypes), ' '),
                                  $namespace in namespace-uri-from-QName(resolve-QName($qname, .))
                            satisfies ($namespace = nf:get-target-namespace(.)
                                       or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                                 and $namespace = xs:anyURI(@namespace)
                                                 and empty(@appinfo:externalImportIndicator)]))"
                      >Every member type of a union simple type definition MUST have a target namespace that is equal to either the target namespace of the XML Schema document within which it is defined or a namespace that is imported as conformant by the schema document within which it is defined.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.1.4.5. Code simple types

   [Definition: code simple type]

      A code simple type is a simple type definition schema component that is constrained by one or more enumeration facets.

   These types represent lists of values, each of which has a known meaning beyond the text representation. These values may be meaningful text or may be a string of alphanumeric identifiers that represent abbreviations for literals.

11.1.4.5.1. Name of a code simple type has standard suffix

   [Rule 11-9] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:simpleType[exists(@name)
            and (xs:restriction/xs:enumeration
                 or xs:restriction[ends-with(local-name-from-QName(resolve-QName(@base, .)), 'CodeSimpleType')])]">
          <sch:assert test="ends-with(@name, 'CodeSimpleType')"
            >A simple type definition schema component that has an enumeration facet or that is derived from a code type MUST have a name that ends in "CodeSimpleType".</sch:assert>
        </sch:rule>
      </sch:pattern>

11.1.4.5.2. Code simple type has enumerations

   [Rule 11-10] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:simpleType[exists(@name) and ends-with(@name, 'CodeSimpleType')]">
          <sch:assert test="xs:restriction[ends-with(local-name-from-QName(resolve-QName(@base, .)), 'CodeSimpleType')]
                            or xs:restriction/xs:enumeration
                            or (for $union in xs:union,
                                   $member-types in $union/@memberTypes return
                                 some $member-type in tokenize(normalize-space($member-types), ' ') satisfies
                                   ends-with(local-name-from-QName(resolve-QName($member-type, $union)), 'CodeSimpleType'))"
            >A code simple type MUST be derived from a code simple type or have an enumeration facet.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Using the qualifier Code (e.g. CodeType, CodeSimpleType) immediately identifies a type as representing a fixed list of codes. These types may be handled in specific ways, as lists of codes are expected to have their own lifecycles, including versions and periodic updates. Codes may also have responsible authorities behind them who provide concrete semantic bindings for the code values.

11.2. Declaration components

11.2.1. Element declaration

11.2.1.1. Element name is upper camel case

   [Rule 11-11] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name)]">
          <sch:assert test="matches(string(@name), '^([A-Z][A-Za-z0-9\-]*)+$')"
                      >The name of an element declaration schema component MUST be upper camel case.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.2.1.2. Element type does not have a simple type name

   [Rule 11-12] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@type)]">
          <sch:assert test="not(ends-with(@type, 'SimpleType'))"
                      >The {type definition} of an [element declaration] MUST NOT have a {name} that ends in 'SimpleType'.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.2.1.3. Element type is from conformant namespace

   [Rule 11-13] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@type)]">
          <sch:assert test="for $type-qname in resolve-QName(@type, .),
                                $type-namespace in namespace-uri-from-QName($type-qname) return
                              $type-namespace = nf:get-target-namespace(.)
                              or exists(nf:get-document-element(.)/xs:import[
                                          xs:anyURI(@namespace) = $type-namespace
                                          and empty(@appinfo:externalImportIndicator)])"
                      >The {type definition} of an {element declaration} MUST have a {target namespace} that is the target namesapce, or one that is imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Additional prohibitions on element types are defined by [Rule 9-36], above, and [Rule 9-37], above.

11.2.1.4. Name of element that ends in "Abstract" must be abstract

   [Rule 11-14] (REF, EXT)

      {is there more normative terminology in the rule text here?}

      <sch:pattern>
        <sch:rule context="xs:element[@name[ends-with(., 'Abstract')]]">
          <sch:assert test="exists(@abstract) and xs:boolean(@abstract) = true()"
            >An element with a name that ends in 'Abstract' MUST be abstract.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.2.1.5. Name of element that ends in "Representation" must be abstract

   [Rule 11-15] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[@name[ends-with(., 'Representation')]]">
          <sch:assert test="exists(@abstract) and xs:boolean(@abstract) = true()"
            >An element with a name that ends in 'Representation' MUST be abstract.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.2.1.6. Object element declarations

   Table 11-1: Representation terms

      Primary Representation Term|Secondary Representation Term|Definition

      Amount|-|A number of monetary units specified in a currency where the unit of currency is explicit or implied.

      BinaryObject|-|A set of finite-length sequences of binary octets.

      |Graphic|A diagram, graph, mathematical curves, or similar representation

      |Picture|A visual representation of a person, object, or scene

      |Sound|A representation for audio

      |Video|A motion picture representation; may include audio encoded within

      Code||A character string (i.e.,letters, figures,and symbols) that for brevity, language independence, or precision represents a definitive value of an attribute.

      DateTime||A particular point in the progression of time together with relevant supplementary information.

      |Date|A particular day, month, and year in the Gregorian calendar.

      |Time|A particular point in the progression of time within an unspecified 24-hour day.

      |Duration|An amount of time; the length of a time span.

      ID||A character string to identify and distinguish uniquely one instance of an object in an identification scheme from all other objects in the same scheme together with relevant supplementary information.

      |URI|A string of characters used to identify (or name) a resource. The main purpose of this identifier is to enable interaction with representations of the resource over a network, typically the World Wide Web, using specific protocols. A URI is either a Uniform Resource Locator (URL) or a Uniform Resource Name (URN). The specific syntax for each is defined by [RFC 3986].

      Indicator||A list of two mutually exclusive Boolean values that express the only possible states of a property.

      Measure||A numeric value determined by measuring an object along with the specified unit of measure.

      Numeric||Numeric information that is assigned or is determined by calculation, counting, or sequencing. It does not require a unit of quantity or unit of measure.

      |Value|A result of a calculation.

      |Rate|A representation of a ratio where the two units are not included.

      |Percent|A representation of a ratio in which the two units are the same.

      Quantity||A counted number of nonmonetary units possibly including fractions.

      Text|-|A character string (i.e., a finite sequence of characters) generally in the form of words of a language.

      |Name|A word or phrase that constitutes the distinctive designation of a person, place, thing, or concept.

      |List|A sequence of values. This representation term is used in tandem with another of the listed representation terms.

11.2.1.6.1. Elements with simple content use representation term

   [Rule 11-16] (REF, EXT, SET)

      <sch:pattern>
        <sch:rule context="xs:element[
            (nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))
             or nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ExtensionSchemaDocument')))
            and exists(@name) 
            and exists(@type)]">
          <sch:let name="has-simple-content" value="
            some $type in nf:resolve-type(., resolve-QName(@type, .)) satisfies
              exists($type[exists(xs:simpleContent)])"/>
          <sch:let name="name-uses-representation-term" value="
            some $representation-term in ('Amount', 'BinaryObject', 'Graphic', 'Picture', 'Sound', 'Video', 'Code', 'DateTime', 'Date', 'Time', 'Duration', 'ID', 'URI', 'Indicator', 'Measure', 'Numeric', 'Value', 'Rate', 'Percent', 'Quantity', 'Text', 'Name', 'List') satisfies
              ends-with(@name, $representation-term)"/>
          <sch:assert test="if ($has-simple-content) then $name-uses-representation-term else true()"
            >the name of an element declaration that is of simple content MUST use a representation term.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Representation terms are defined by Table Table 11-1, Representation terms, above

11.2.1.7. Metadata element declarations

   [Definition: metadata element]

      Within a NIEM-conformant schema, a metadata element is an element with a type that is a metadata type.

    There are limitations on the meaning of a metadata element in an instance; it does not establish existence of an object, nor is it a property of its containing object.

11.2.1.7.1. Metadata element is an element of a metadata type

   [Rule 11-17] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@name)]">
          <sch:assert test="exists(@type[ends-with(., 'MetadataType')])
                            = exists(@name[ends-with(., 'Metadata')])"
            >An element MUST have a name that ends in 'Metadata' if and only if it has a type that is a metadata type.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Using the qualifier Metadata immediately identifies an element as representing metadata.

11.2.2. Element substitution group

11.2.2.1. Element substitution group defined by conformant schemas

   [Rule 11-18] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@substitutionGroup)]">
          <sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@substitutionGroup, .))"/>
          <sch:assert test="$namespace = nf:get-target-namespace(.)
                            or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                          and $namespace = xs:anyURI(@namespace)
                                          and empty(@appinfo:externalImportIndicator)])"
            >An element substitution group MUST have either the target namespace or a namespace that is imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.2.3. Attribute declaration

11.2.3.1. Attribute type defined by conformant schemas

   [Rule 11-19] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@type)]">
          <sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@type, .))"/>
          <sch:assert test="$namespace = (nf:get-target-namespace(.), xs:anyURI('http://www.w3.org/2001/XMLSchema'))
                            or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                          and $namespace = xs:anyURI(@namespace)
                                          and empty(@appinfo:externalImportIndicator)])"
            >The type of an attribute declaration MUST have the target namespace or the XML Schema namespace or a namespace that is imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.2.3.2. Attribute name uses representation term

   [Rule 11-20] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:attribute[exists(@name)]">
          <sch:assert test="some $representation-term in ('Amount', 'BinaryObject', 'Graphic', 'Picture', 'Sound', 'Video', 'Code', 'DateTime', 'Date', 'Time', 'Duration', 'ID', 'URI', 'Indicator', 'Measure', 'Numeric', 'Value', 'Rate', 'Percent', 'Quantity', 'Text', 'Name', 'List') satisfies
                              ends-with(@name, $representation-term)"
                      >An attribute name MUST end with a representation term.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.2.4. Notation declaration

11.3. Model group components

11.3.1. Model group

11.3.2. Particle

11.3.2.1. Element use

11.3.2.1.1. Element introduced only once in a content model

   [Rule 11-21] (REF, EXT)

      Within the schema, an element MUST NOT be introduced more than once into the content of a type definition. This applies to content acquired from base type definitions. This applies to elements substitutable through element substitution groups.

   This rule ensures that sequences of elements are simple sequences. A type does not define, for example, a sequence of elements A, B, then A again. Definitions should define, instead, what elements may be included, and the cardinality of each element. Schemas must also be careful not to introduce elements that are substitutable for one another, as this can create violations of the unique particle attribution constraint, as described by [XML Schema Structures] section 3.8.6, Constraints on Model Group Schema Components.

11.3.2.1.2. Element ref in external type defined by external schemas

   [Rule 11-22] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(@ref)
                                      and exists(ancestor::xs:complexType[exists(@appinfo:externalAdapterTypeIndicator)])]">
          <sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@ref, .))"/>
          <sch:assert test="$namespace != nf:get-target-namespace(.)
                            and exists(nf:get-document-element(.)/self::xs:schema/xs:import[
                                exists(@namespace)
                                and $namespace = xs:anyURI(@namespace)
                                and xs:boolean(@appinfo:externalImportIndicator) = true()])"
            >An element reference that appears within an external adapter type MUST have a target namespace that is imported as external.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.3.2.1.3. Element reference defined by conformant schemas

   [Rule 11-23] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:element[exists(ancestor::xs:complexType[empty(@appinfo:externalAdapterTypeIndicator)]) and exists(@ref)]">
          <sch:let name="namespace" value="namespace-uri-from-QName(resolve-QName(@ref, .))"/>
          <sch:assert test="$namespace = nf:get-target-namespace(.)
                            or exists(ancestor::xs:schema[1]/xs:import[exists(@namespace)
                                          and $namespace = xs:anyURI(@namespace)
                                          and empty(@appinfo:externalImportIndicator)])"
            >An element reference MUST be to a component that has a namespace that is either the target namespace of the [schema document] in which it appears, or which is imported as conformant by that [schema document].</sch:assert>
        </sch:rule>
      </sch:pattern>

11.3.3. Attribute use

11.3.4. Wildcard

11.4. Annotation components

   NIEM-conformant schemas define data models for the purpose of information exchange. A major part of defining data models is the proper definition of the contents of the model. What does a component mean, and what might it contain? How should it be used? NIEM- conformant schemas contain the invariant part of the definitions for the data model. The set of definitions includes:

      1. A text definition of each component. This describes what the component means. The term used in this specification for such a text definition is data definition.

      2. The structural definition of each component. This is made up of XML Schema component definitions, along with certain application information (appinfo).

   When possible, meaning is expressed via XML Schema mechanisms: type derivation, element substitution, specific types and structures, as well as names that are trivially parseable. Beyond that, NIEM-specific syntax must be used, as discussed in this section.

11.4.1. Human-readable documentation

   Note that [Rule 5-4] applies [ISO 11179-4] definition rules to documented components.

   [Rule 11-24] (REF, EXT)

      Words or synonyms for the words within a data element definition SHALL NOT be reused as terms in the corresponding component name if those words dilute the semantics and understanding of, or impart ambiguity to, the entity or concept that the component represents.

   [Rule 11-25] (REF, EXT)

      An object class SHALL have one and only one associated semantic meaning (i.e., a single word sense) as described in the definition of the component that represents that object class.

   [Rule 11-26] (REF, EXT)

      An object class SHALL NOT be redefined within the definitions of the components that represent properties or subparts of that entity or class.

   Rationale

   Data definitions should be concise, precise, and unambiguous without embedding additional definitions of data elements that have already been defined once elsewhere (such as object classes). [ISO 11179-4] says that definitions should not be nested inside other definitions. Furthermore, a data dictionary is not a language dictionary. It is acceptable to reuse terms (object class, property term, and qualifier terms) from a component name within its corresponding definition to enhance clarity, as long as the requirements and recommendations of [ISO 11179-4] are not violated. This further enhances brevity and precision.

   [Rule 11-27] (REF, EXT)

      A data definition SHALL NOT contain explicit representational or data typing information such as number characters, type of characters, etc., unless the very nature of the component can be described only by such information.

   Rationale

   A component definition is intended to describe semantic meaning only, not representation or structure. How a component with simple content is represented is indicated through the representation term and further refined through constraints.

   Figure 11-1: A definition that describes mathematical representation

      <xsd:element name="AngularMinuteValue" type="nc:AngularMinuteType" nillable="true">
        <xsd:annotation>
          <xsd:documentation>
            A value that specifies a minute of a degree. The value comes from a restricted range of 0 (inclusive) to 60 (exclusive).
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

   In Figure 7-1, above, the component definition contains representational information because the component is mathematical and therefore requires such. In Figure 7-2, below, the definition is incorrect and states unnecessary representational information about the data element. nc:PersonSSNIdentification is not a social security number (SSN); it is a complex element (type nc:IdentificationType) that contains a SSN identifier as well as other properties that describe a person's SSN identifier (such as issue date, issue authority, etc.). The phrase "9-digit" is incorrect and unnecessary because it applies only to the SSN identifier and should be applied as a length or pattern constraint on the identifier only.

   Figure 11-2: A definition that describes syntactic representation

      <xsd:element name="PersonSSNIdentification" type="nc:IdentificationType">
        <xsd:annotation>
          <xsd:documentation>
            A social security number that references a person; a 9-digit numeric identifier assigned to a living person by the United States Social Security Administration.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>

   [Rule 11-28] (REF, EXT)

      A component definition SHALL begin with a standard opening phrase that depends on the class of the component per Table Table 11-2, Standard opening phrases.

   Table 11-2: Standard opening phrases

      Component class|Definition opening phrase

      Abstract element|"A data concept for a..."

      Association element|"A relationship..."

      Association type|"A data type for a relationship..."

      Augmentation element|"Supplements..."

      Augmentation type|"A data type that supplements..."

      Metadata element|Either "Metadata about..." or "Information that further qualifies..."

      Metadata type|"A data type for metadata about..." or "A data type for information that further qualifies..."

      Element with a date representation term|"A date..."

      Element with a quantity representation term|"A (optional adjective) count/number of..."

      Element with an image representation term|"A(n) (optional adjective) image/picture/photograph of..."

      Element with an indicator representation term|"True if...; false otherwise/if..."

      Element with an identification representation term|"A(n) (optional adjective) identification..."

      Element with an ID representation term|"An identifier..."

      Element with a status representation term|"A(n) (optional adjective) status/state of..."

      Element with a name representation term|"A name of..."

      Element with a category text representation term|"A kind of..."

      Element with a description text representation term|"A description of..."

      Other element|"A(n)..."

      Other type|"A data type for a(n)..."

   Rationale

   A standard opening phrase based on component class helps to ensure consistent definitions that appropriate for the type of component item being defined. These opening phrases also provide a cue that facilitates recognition of the particular kind of component.

11.4.2. Data definition follows 11179-4 requirements

   [Rule 11-29] (REF, EXT)

      Each [data definition] SHALL conform to the requirements for data definitions provided by [ISO 11179-4] section 5.2, Requirements.

11.4.3. Data definition follows 11179-4 recommendations

   [Rule 11-30] (REF, EXT)

      Each [data definition] SHOULD conform to the recommendations for data definitions provided by [ISO 11179-4] section 5.3, Recommendations.

11.5. Schema as a whole

11.5.1. xs:schema document element restrictions

   [Rule 11-31] (REF, EXT)

      Two XML Schema documents SHALL have the same value for attribute targetNamespace carried by the element xs:schema, if and only if they represent the same set of components.

   [Rule 11-32] (REF, EXT)

      Two XML Schema documents SHALL have the same value for attribute targetNamespace carried by the element xs:schema, and different values for attribute version carried by the element xs:schema if and only if they are different views of the same set of components.

   Rationale

   These rules embody the basic philosophy behind NIEM's use of namespaced components: A component is uniquely identified by its class (e.g. element, attribute, type), its namespace (a URI), and its local name (an unqualified string). Any two matching component identifiers refer to the same component, even if the versions of the schemas containing each are different.

11.6. Schema assembly

11.6.1. Reference schemas import reference schemas.

   [Rule 11-33] (SET)

      <sch:pattern>
        <sch:rule context="xs:import[
                               nf:has-effective-conformance-target-identifier(., xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))
                               and exists(@namespace)
                               and empty(@appinfo:externalImportIndicator)
                               and not(xs:anyURI(@namespace) = (
                                         xs:anyURI('http://release.niem.gov/niem/structures/3.0/'),
                                         xs:anyURI('http://www.w3.org/XML/1998/namespace'),
                                         xs:anyURI('urn:us:gov:ic:ism'),
                                         xs:anyURI('urn:us:gov:ic:ntk')))]">
          <sch:assert test="every $schema 
                            in nf:resolve-namespace(., @namespace)
                            satisfies nf:has-effective-conformance-target-identifier($schema, xs:anyURI('http://reference.niem.gov/niem/specification/naming-and-design-rules/3.0/#ReferenceSchemaDocument'))"
            >A namespace imported as conformant from a reference schema document MUST identify a reference schema document.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.6.2. Special namespaces are imported as conformant

11.6.2.1. Structures imported as conformant

   [Rule 11-34] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:import[exists(@namespace) 
                                     and xs:anyURI(@namespace) = xs:anyURI('http://release.niem.gov/niem/structures/3.0/')]">
          <sch:assert test="empty(@appinfo:externalImportIndicator)"
            >The structures namespace MUST be imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>          

11.6.2.2. Schema for XML imported as conformant

   [Rule 11-35] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:import[exists(@namespace)
                                     and xs:anyURI(@namespace) = xs:anyURI('http://www.w3.org/XML/1998/namespace')]">
          <sch:assert test="empty(@appinfo:externalImportIndicator)"
            >The namespace for XML MUST be imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>          

11.6.2.3. Schema for IC-ISM imported as conformant

   [Rule 11-36] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:import[exists(@namespace)
                                     and xs:anyURI(@namespace) = xs:anyURI('urn:us:gov:ic:ism')]">
          <sch:assert test="empty(@appinfo:externalImportIndicator)"
            >The namespace for IC-ISM MUST be imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>          

11.6.2.4. Schema for IC-NTK imported as conformant

   [Rule 11-37] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:import[exists(@namespace)
                                     and xs:anyURI(@namespace) = xs:anyURI('urn:us:gov:ic:ntk')]">
          <sch:assert test="empty(@appinfo:externalImportIndicator)"
            >The namespace for IC-NTK MUST be imported as conformant.</sch:assert>
        </sch:rule>
      </sch:pattern>          

11.6.3. Each namespace may have only a single root schema in a schema set.

   [Rule 11-38] (SET)

      <sch:pattern>
        <sch:rule context="xs:schema[exists(@targetNamespace)
                                     and (some $element 
                                         in nf:resolve-namespace(., xs:anyURI(@targetNamespace))
                                         satisfies $element is .)]">
          <sch:assert test="count(nf:resolve-namespace(., xs:anyURI(@targetNamespace))) = 1"
                      >A namespace may appear as a root schema in a schema set only once.</sch:assert>
        </sch:rule>
      </sch:pattern>

11.6.4. Consistently marked namespace imports

   XML Schemas allows multiple xs:import elements for the same namespace, which allows for multiple sets of annotations and schema locations. 

   [Rule 11-39] (REF, EXT)

      <sch:pattern>
        <sch:rule context="xs:import">
          <sch:let name="namespace" value="@namespace"/>
          <sch:let name="is-conformant" value="empty(@appinfo:externalImportIndicator)"/>
          <sch:let name="first" value="exactly-one(parent::xs:schema/xs:import[@namespace = $namespace][1])"/>
          <sch:assert test=". is $first
                            or $is-conformant = empty($first/@appinfo:externalImportIndicator)"
                  >All xs:import elements that have the same namespace MUST have the same conformance marking via appinfo:externalImportIndicator.</sch:assert>
        </sch:rule>
      </sch:pattern>

12. XML instance document rules

   This specification attempts to restrict XML instance data as little as possible while still maintaining interoperability. Section 2.6, NIEM-Conformant XML Documents and Elements, defines terminology for NIEM-conformance and XML documents.

   NIEM does not require a specific encoding or specific requirements for the XML prologue, except as specified by [XML].

12.1. Instance must be schema-valid

   [Rule 12-1] (INS)

      The XML document MUST be schema-valid, assessed with reference to the schema composed of the reference schemas, extension schemas, exchange schemas, utility schemas, and external schemas for the relevant namespaces.

   The schemas that define the exchange must be authoritative. Each is the reference schema, extension schema, or exchange schema for the namespace it defines. Application developers may use other schemas for various purposes, but for the purposes of determining conformance, the authoritative schemas are relevant.

   This rule should not be construed to mean that XML validation must be performed on all XML instances as they are served or consumed; only that the XML instances validate if XML validation is performed. The XML Schema component definitions specify XML documents and element information items, and the instances should follow the rules given by the schemas, even when validation is not performed.

   NIEM embraces the use of XML Schema instance attributes, including xsi:type, xsi:nil, and xsi:schemaLocation, as specified by [XML Schema Structures].

12.2. Content elements

   In XML instances, relationships between data objects are expressed as XML elements:

      1. Data objects are expressed as XML elements.

      2. XML elements contain attributes and other elements.

   In this way, there is a relationship between the outer element (the containing element, also called the parent element) and the inner elements (the contained elements, also called as the child elements). An element that contains its content in this way is called a [content element].

   [Definition: content element]

      A content element is an element information item that does not contain an attribute structures:ref. A content element expresses its value as text and element content of the element information item.

   The most common NIEM patterns use content elements to represent most data. The following is an example of a content element in use. All elements in this example are content elements.

   Figure 12-1: Example of content elements

      <nc:Item>
        <nc:ItemOwner>
          <nc:EntityPerson>
            <nc:PersonName>
              <nc:PersonFullName>John Doe</nc:PersonFullName>
            </nc:PersonName>
          </nc:EntityPerson>
        </nc:ItemOwner>
      </nc:Item>

12.3. Reference elements

   Content elements are sufficient to represent data that takes the form of a tree. However, use of content elements has limitations. Problematic cases include:

   Expression of all relationships via element containment is not always possible. Situations that cause problems include:

      *  Cycles: the relationships transitively held by an object include a relationship to itself.

         For example, suppose that object 1 has a relationship to object 2 and object 2 has a relationship to object 1. This is not a tree, and so needs some representation other than a simple tree.

      *  Reuse: multiple objects have a relationshp to a common object.

         For example, suppose object 1 has a relationship to object 2 and object 3 has a relationship to object 2. Expressed via containment, this would result in a duplicate of object 2.

   A method that solves this problem is the use of references. In a C or assembler, you could use a pointer. In C++, a reference might be used. In Java, a reference value might be used. The method defined by the XML standard is the use of ID and IDREF. An IDREF refers to an ID. NIEM uses this method and assigns to it specific semantics.

   Naive solutions to these problems that use only content elements require techniques such as repeating data and identifying and excluding duplicate data; these operation entail the use of excess storage and processing time.

   It is good to avoid these problems; in order to avoid them, NIEM allows [reference elements]. A reference element expresses a relationship to another object by using a reference attribute, structures:ref. In Figure 12-2, Example of reference element, below, the outer object is the content of nc:Item, which is an object of type nc:ItemType. It has a relationship nc:ItemOwner to the object that is the content of the nc:Entity element.

   Figure 12-2: Example of reference element

      <nc:Item>
        <nc:ItemOwner structures:ref="m82"/>
      </nc:Item>
      <nc:Entity structures:id="m82">
        <nc:EntityPerson>
          <nc:PersonName>
            <nc:PersonFullName>John Doe</nc:PersonFullName>
          </nc:PersonName>
        </nc:EntityPerson>
      </nc:Entity>

   NIEM XML instances use IDREF attributes to establish links between XML elements.

   [Definition: reference element]

      A reference element is an element information item that has an attribute structures:ref. A reference element refers to its value by reference, instead of carrying it as content.

12.3.1. Element with structures:ref does not have content

   [Rule 12-2] (INS)

      <sch:pattern>
        <sch:rule context="*[@structures:ref]">
          <sch:assert test="empty(element() | text())"
            >An element that has attribute structures:ref MUST NOT have element or text content.</sch:assert>
        </sch:rule>
      </sch:pattern>            

12.3.2. Attribute structures:ref must reference structures:id

   [Rule 12-3] (INS)

      <sch:pattern>
        <sch:rule context="*[@structures:ref]">
          <sch:let name="ref" value="@structures:ref"/>
          <sch:assert test="exists(//*[@structures:id = $ref])"
            >The value of an attribute structures:ref must match the value of an attribute structures:id of some element in the XML document.</sch:assert>
        </sch:rule>
      </sch:pattern>            

   This mirrors the terminology in [XML] subsection Validity constraint: IDREF within section 3.3.1, Attribute Types, except it requires the target attribute to be structures:id, rather than any attribute of type ID.

12.3.3. Linked elements have same validation root

   [Rule 12-4] (INS)

      Given that:

         *  $element is an element information item

         *  $element has attribute structures:ref with value $ref

         *  $element has property [validation context] with value called the referencing element validation root

         *  $target is an element information item

         *  $target has attribute structures:id with value $ref

         *  $target has property [validation context] with value called the referenced element validation root

      Every element that has an attribute structures:ref MUST have a referencing element validation root that is equal to the referenced element validation root.

   The term "validation root" is defined by [XML Schema Structures] section 5.2, Assessing Schema-Validity. It is established as a part of validity assessment of an XML document. It is required because relationships between the types of elements cannot be established if those elements were not assessed together.

12.3.4. Attribute structures:ref references element of correct type

   [Rule 12-5] (INS)

      Given that:

         *  $element is an element information item

         *  $element has attribute structures:ref with value $ref

         *  $element has property [element declaration] with value $element-declaration

         *  $element-declaration has property {type definition} with value called the referencing element type definition

         *  $target is an element information item

         *  $target has attribute structures:id with value $ref

         *  $target has property [type definition] with value called the referenced element type definition

      Every element that has an attribute structures:ref MUST have a referencing element type definition that is validly derived from the referenced element type definition.

   The term validly derived is as established by [XML Schema Structures] subsection Schema Component Constraint: Type Derivation OK (Complex) within section 3.4.6, Constraints on Complex Type Definition Schema Components.

   This rule requires that the type of the element information item pointed to by a structures:ref attribute must be of (or derived from) the type that is specified by the element declaration of the reference element.

12.3.5. Reference and content elements have same meaning

   An important aspect of the use of NIEM reference and content elements is that they have the same meaning. The use of a content element versus a reference element is merely for convenience and ease of serialization. There is no change in meaning or semantics between content and reference elements.

   Any claim that content elements represent composition while reference elements represent aggregation is incorrect. Any life cycle dependency is not expressed through the use of content and reference elements, and is not an explicit part of the NIEM model.

   [Rule 12-6] (INS)

      There MUST NOT be any difference in meaning between a relationship established via a content element and a relationship established via reference element, except as explicitly described by the semantics of the elements involved.

   There is no difference in meaning between relationships established by content elements and those established by reference elements. They are simply two mechanisms for expressing connections between objects. Neither mechanism implies that properties are intrinsic or extrinsic; such characteristics must be explicitly stated in property definitions.

   Being of type xs:ID and xs:IDREF, validating schema parsers will perform certain checks on the values of structures:id and structures:ref. Specifically, no two IDs may have the same value. This includes structures:id and other IDs that may be used within an XML document. Also, any value of structures:ref must also appear as the value of an ID.

   By this rule, the following two XML fragments have the same meaning. First, Figure 12-3, Example with a backward reference, below, shows a person object being expressed, followed by a backwards reference to it. Second, Figure 12-4, Example with a forward reference, below, shows a person as a forward reference to the person object that is expressed later, within the definition of a witness. Both of these XML fragments have the same semantics.

   Figure 12-3: Example with a backward reference

      <nc:Person structures:id="c58">
        <nc:PersonName>
          <nc:PersonFullName>John Doe</nc:PersonFullName>
        </nc:PersonName>
      </nc:Person>
      <j:Witness>
        <nc:RoleOfPerson structures:ref="c58"/>
      </j:Witness>

   Figure 12-4: Example with a forward reference

      <nc:Person structures:ref="t85"/>
      <j:Witness>
        <nc:RoleOfPerson structures:id="t85">
          <nc:PersonName>
            <nc:PersonFullName>John Doe</nc:PersonFullName>
          </nc:PersonName>
        </nc:RoleOfPerson>
      </j:Witness>

   NIEM-conformant data instances may use content elements and reference elements as needed, to represent the meaning of the fundamental data. There is no difference in meaning between reference and content data representations. The two different methods are available for ease of representation. No difference in meaning should be implied by the use of one method or the other.

   Assertions that indicate "included" data is intrinsic, while referenced data is extrinsic, are not valid and are not applicable to NIEM-conformant data instances and data definitions.

12.4. Instance meaning

   [Rule 12-7] (INS)

      Within the instance, the meaning of an element with no content is that additional properties are not asserted. There SHALL NOT be additional meaning interpreted for an element with no content.

   Rationale

   Elements without content only show a lack of asserted information. That is, all that is asserted is what is explicitly stated, through a combination of XML instance data and its schema. Data that is not present makes no claims. It may be absent due to lack of availability, lack of knowledge, or deliberate withholding of information. These cases should be modeled explicitly, if they are required.

12.5. Instance metadata

   NIEM provides the metadata mechanism for giving information about object assertions. An object may have an attribute that refers to one or more metadata objects. A structures:metadata attribute indicates that a data item has the given metadata. A structures:relationshipMetadata attribute asserts that the link (or relationship) established by an element has the given metadata.

   Figure 12-5: Simple example of instance metadata

      <nc:Person>
        <nc:PersonName structures:metadata="o25" structures:relationshipMetadata="o67">
          <nc:PersonFullName>John Doe</nc:PersonFullName>
        </nc:PersonName>
      </nc:Person>
      <nc:Metadata structures:id="o25">
        <nc:SourceText>Adam Barber</nc:SourceText>
      </nc:Metadata>
      <nc:Metadata structures:id="o67">
        <nc:ProbabilityPercent>0.25</nc:ProbabilityPercent>
      </nc:Metadata>

   Figure 12-6: Example of metadata used in an instance

      <nc:Person>
        <nc:PersonBirthDate structures:metadata="j86">
          <nc:Date>1945-12-01</nc:Date>
        </nc:PersonBirthDate>
        <nc:PersonName structures:metadata="s22 j86" structures:relationshipMetadata="k25">
          <nc:PersonFullName>John Doe</nc:PersonFullName>
        </nc:PersonName>
      </nc:Person>
      <nc:Metadata structures:id="s22">
        <nc:SourceText>Adam Barber</nc:SourceText>
      </nc:Metadata>
      <nc:Metadata structures:id="j86">
        <nc:ReportedDate>
          <nc:Date>2005-04-26</nc:Date>
        </nc:ReportedDate>
      </nc:Metadata>
      <nc:Metadata structures:id="k25">
        <nc:ProbabilityPercent>0.25</nc:ProbabilityPercent>
      </nc:Metadata>

   This example shows a person named John Doe, born 12/1/1945. This data has several pieces of metadata on it:

      *  Metadata s22 asserts Adam Barber gave the name.

      *  Metadata j86 asserts the name and the birth date were reported on 4/26/2005.

      *  Link metadata o67 asserts a 25% probability that the name goes with the person.

   This shows several characteristics of metadata:

      *  Metadata objects may appear outside the data they describe.

      *  Metadata objects may be reused.

      *  Data may refer to more than one metadata object.

      *  Metadata pertains to an object or simple content, while link metadata pertains to the relationship between objects.

   An instance would not be valid XML if the structures:metadata or structures:relationshipMetadata attributes contained references for which there were no defined IDs. The instance would not be NIEM-conformant if the references were not to IDs defined with the structures:id attribute.

   The definition of a metadata type may contain an appinfo:AppliesTo element, which indicates the type to which the metadata applies. For example:

   Figure 12-7: A metadata type that describes applicability using appinfo:AppliesTo

      <xsd:complexType name="MeasureMetadataType">
        <xsd:annotation>
            ...
          <xsd:appinfo>
            <i:AppliesTo i:name="MeasureType"/>
          </xsd:appinfo>
        </xsd:annotation>
        <xsd:complexContent>
          ...
        </xsd:complexContent>
      </xsd:complexType>

   Application of metadata to a type to which it is not applicable is not NIEM-conformant. A metadata type may contain multiple appinfo:AppliesTo elements, in which case it may apply to an instance of any of the listed types. If a metadata type contains no appinfo:AppliesTo elements, then it may apply to any type. This is the case for nc:MetadataType in NIEM 2.0.

   [Rule 12-8] (INS)

      Within an element instance, when an object O links to a metadata object via an attribute structures:metadata, the information in the metadata object SHALL be applied to the object O.

   [Rule 12-9] (INS)

      Within an element instance, when an object O1 contains an element E, with content object O2 or with a reference to object O2, and O2 links to a metadata object via an attribute structures:relationshipMetadata, the information in the metadata object SHALL be applied to the relationship E between O1 and O2.

   Rationale

   These two rules define the meaning of metadata:

      *  structures:metadata applies metadata to an object.

      *  structures:relationshipMetadata applies metadata to a relationship between two objects.

   [Rule 12-10] (INS)

      Given that each IDREF in the value of an attribute structures:metadata must match the value of an ID attribute on some element in the XML document, that ID attribute MUST be an occurrence of the attribute structures:id.

   [Rule 12-11] (INS)

      Each element that an attribute structures:metadata references MUST have a type definition that is derived from structures:MetadataType.

   [Rule 12-12] (INS)

      Given that each IDREF in the value of an attribute structures:relationshipMetadata must match the value of an ID attribute on some element in the XML document, that ID attribute MUST be an occurrence of the attribute structures:id.

   [Rule 12-13] (INS)

      Each element that an attribute structures:relationshipMetadata references MUST have a type definition that is derived from structures:MetadataType.

   Rationale

   All structures:metadata and structures:relationshipMetadata attributes must refer to metadata objects, and the reference to that object must be established using the structures:id attribute, to facilitate processing of XML documents.

   [Rule 12-14] (INS)

      Given that an element information item E has a type definition of some type T, each metadata type that is the type definition of an element information item referenced by an attribute structures:metadata or structures:relationshipMetadata on element E MUST be applicable to T.

   Rationale

   The applicability is determined by appinfo:AppliesTo application information of the metadata type definition. The instances must correspond to the types specified by the metadata type definition.

   [Definition: XML instance document]

      An XML instance document is an [XML document] that is assessed as [valid] against an [XML Schema].

   [Definition: valid]

      The term "valid" is as defined by [XML Schema Structures] section 2.1, Overview of XML Schema, which states:

         [Definition:] the word valid and its derivatives are used to refer to clause 1 above, the determination of local schema-validity.

      The referenced clause 1 is a part of a description of schema-validity:

         Schema-validity assessment has two aspects:

            1. Determining local schema-validity, that is whether an element or attribute information item satisfies the constraints embodied in the relevant components of an XML Schema;

            2. Synthesizing an overall validation outcome for the item, combining local schema-validity with the results of schema-validity assessments of its descendants, if any, and adding appropriate augmentations to the infoset to record this outcome.

12.6. Attribute structures:ref references structures:id

   [Rule 12-15] (INS)

      <sch:pattern>
        <sch:rule context="*[exists(@structures:ref)]">
          <sch:let name="ref" value="@structures:ref"/>
          <sch:assert test="exists(//@structures:id[. = $ref])"
            >The value of an attribute structures:ref MUST appear as the value of an attribute structures:id in the [XML instance document].</sch:assert>
        </sch:rule>
      </sch:pattern>

   This states that in NIEM-conformant content, structures:ref attributes must refer to structures:id attributes. By [XML] section 3.3.1, Attribute Types, an IDREF is required to reference an ID. This rule ensures that the target of a reference is a NIEM ID for easier processing of XML documents.

12.7. Attribute structures:metadata references a metadata element

   [Rule 12-16] (INS)

      <sch:pattern>
        <sch:rule context="*[exists(@structures:metadata)]">
          <sch:assert test="every $metadata-ref in tokenize(normalize-space(@structures:metadata)) satisfies
                              exists(//*[exists(@structures:id[. = $metadata-ref])
                                         and ends-with(local-name(), 'Metadata')])"
            >Each item in the value of an attribute structures:metadata MUST appear as the value of an attribute structures:id with an owner element that is a metadata element.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Note that this will NOT catch a scenario in which the element with a name ending in "Metadata" is an external element; additional tests would be required to catch that.

12.8. Attribute structures:relationshipMetadata references a metadata element

   [Rule 12-17] (INS)

      <sch:pattern>
        <sch:rule context="*[exists(@structures:relationshipMetadata)]">
          <sch:assert test="every $metadata-ref in tokenize(normalize-space(@structures:relationshipMetadata)) satisfies
                              exists(//*[exists(@structures:id[. = $metadata-ref])
                                         and ends-with(local-name(), 'Metadata')])"
            >Each item in the value of an attribute structures:relationshipMetadata MUST appear as the value of an attribute structures:id with an owner element that is a metadata element.</sch:assert>
        </sch:rule>
      </sch:pattern>

   Note that this will NOT catch a scenario in which the element with a name ending in "Metadata" is an external element; additional tests would be required to catch that.

Appendix A. References

   [ClarkNS]: Clark, J. "XML Namespaces", 4 February 1999. Available from http://www.jclark.com/xml/xmlns.htm.

   [CTAS]: "NIEM Conformance Targets Attribute Specification, Version 3.0", 1 August 2012. Available from http://reference.niem.gov/niem/specification/conformance-target-attribute/3.0beta2/NIEM-CTAS-3.0beta2.html.

   [ISO 11179-4]: "ISO/IEC 11179-4 Information Technology -- Metadata Registries (MDR) -- Part 4: Formulation of Data Definitions Second Edition", 15 July 2004. Available from http://standards.iso.org/ittf/PubliclyAvailableStandards/c035346_ISO_IEC_11179-4_2004(E).zip.

   [ISO 11179-5]: "ISO/IEC 11179-5:2005, Information technology -- Metadata registries (MDR) -- Part 5: Naming and identification principles". Available from http://standards.iso.org/ittf/PubliclyAvailableStandards/c035347_ISO_IEC_11179-5_2005(E).zip.

   [N-ary]: "Defining N-ary Relations on the Semantic Web", W3C Working Group Note, 12 April 2006. Available from http://www.w3.org/TR/2006/NOTE-swbp-n-aryRelations-20060412//.

   [OED]: "Oxford English Dictionary, Third Edition", Oxford University Press, November 2010. http://dictionary.oed.com/.

   [RDF Primer]: "RDF Primer", W3C Recommendation, 10 February 2004. Available from http://www.w3.org/TR/2004/REC-rdf-primer-20040210/.

   [RDF Semantics]: "RDF Semantics", W3C Recommendation, 10 February 2004. Available from http://www.w3.org/TR/2004/REC-rdf-mt-20040210/.

   [RFC 2119]: Bradner, S. "Key words for use in RFCs to Indicate Requirement Levels", IETF RFC 2119, March 1997. Available from http://www.ietf.org/rfc/rfc2119.txt.

   [RFC 3986]: Berners-Lee, T., et al. "Uniform Resource Identifier (URI): Generic Syntax", Request for Comments 3986, January 2005. Available from http://www.ietf.org/rfc/rfc3986.txt.

   [WP CamelCase]: "CamelCase." Wikipedia, The Free Encyclopedia, January 19, 2014. http://en.wikipedia.org/w/index.php?title=CamelCase&oldid=591379310.

   [XML]: "Extensible Markup Language (XML) 1.0 (Fourth Edition)", W3C Recommendation, 16 August 2006. Available from http://www.w3.org/TR/2008/REC-xml-20081126/.

   [XML Infoset]: Cowan, John, and Richard Tobin. "XML Information Set (Second Edition)", 4 February 2004. http://www.w3.org/TR/2004/REC-xml-infoset-20040204/.

   [XML Namespaes]: "Namespaces in XML 1.0 (Third Edition)", W3C Recommendation, 8 December 2009. Available from http://www.w3.org/TR/2009/REC-xml-names-20091208/.

      NCName is described at #NT-NCName.

   [XML Namespaces Errata]: "Namespaces in XML Errata", 6 December 2002. Available from http://www.w3.org/XML/xml-names-19990114-errata.

   [XML Schema Datatypes]: "XML Schema Part 2: Datatypes Second Edition", W3C Recommendation, 28 October 2004. Available at http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/.

      Prohibition on direct use of simple type xs:NOTATION is at #enumeration-required-notation.

   [XML Schema Structures]: "XML Schema Part 1: Structures Second Edition", W3C Recommendation, 28 October 2004. Available from http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/.

   [Schematron]: "ISO/IEC STANDARD 19757-3: Information technology -- Document Schema Definition Languages (DSDL) Part 3: Rule-based validation -- Schematron", ISO/IEC, 1 June 2006. Retrieved from http://standards.iso.org/ittf/PubliclyAvailableStandards/c040833_ISO_IEC_19757-3_2006(E).zip.

   [XPath 2]: Berglund, Anders, Scott Boag, Don Chamberlin, Mary F. Fernandez, Michael Kay, Jonathan Robie, and Jerome Simeon. "XML Path Language (XPath) 2.0 (Second Edition)", W3C Recommendation, 3 January 2011. http://www.w3.org/TR/2010/REC-xpath20-20101214/.

Appendix B. Structures namespace

   <?xml version="1.0" encoding="US-ASCII"?>
   <xs:schema
       targetNamespace="http://release.niem.gov/niem/structures/3.0/"
       version="1"
       xmlns:structures="http://release.niem.gov/niem/structures/3.0/"
       xmlns:xs="http://www.w3.org/2001/XMLSchema">
   
       <xs:attribute name="id" type="xs:ID"/>
       <xs:attribute name="ref" type="xs:IDREF"/>
       <xs:attribute name="metadata" type="xs:IDREFS"/>
       <xs:attribute name="relationshipMetadata" type="xs:IDREFS"/>
      
       <xs:attributeGroup name="SimpleObjectAttributeGroup">
           <xs:attribute ref="structures:id"/>
           <xs:attribute ref="structures:ref"/>
           <xs:attribute ref="structures:metadata"/>
           <xs:attribute ref="structures:relationshipMetadata"/>
           <xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/>
       </xs:attributeGroup>
   
       <xs:complexType name="ObjectType" abstract="true">
           <xs:sequence>
               <xs:element ref="structures:ObjectAugmentationPoint" minOccurs="0" maxOccurs="unbounded"/>
           </xs:sequence>
           <xs:attribute ref="structures:id"/>
           <xs:attribute ref="structures:ref"/>
           <xs:attribute ref="structures:metadata"/>
           <xs:attribute ref="structures:relationshipMetadata"/>
           <xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/>
       </xs:complexType>
   
       <xs:element name="ObjectAugmentationPoint" abstract="true">
           <xs:annotation>
               <xs:documentation>An augmentation point for ObjectType</xs:documentation>
           </xs:annotation>
       </xs:element>
   
       <xs:complexType name="AssociationType" abstract="true">
           <xs:sequence>
               <xs:element ref="structures:AssociationAugmentationPoint" minOccurs="0" maxOccurs="unbounded"/>
           </xs:sequence>
           <xs:attribute ref="structures:id"/>
           <xs:attribute ref="structures:ref"/>
           <xs:attribute ref="structures:metadata"/>
           <xs:attribute ref="structures:relationshipMetadata"/>
           <xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/>
       </xs:complexType>
   
       <xs:element name="AssociationAugmentationPoint" abstract="true">
           <xs:annotation>
               <xs:documentation>An augmentation point for AssociationType</xs:documentation>
           </xs:annotation>
       </xs:element>
   
       <xs:complexType name="MetadataType" abstract="true">
           <xs:attribute ref="structures:id"/>
           <xs:attribute ref="structures:ref"/>
           <xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/>
       </xs:complexType>
   
       <xs:complexType name="AugmentationType" abstract="true">
           <xs:attribute ref="structures:id"/>
           <xs:attribute ref="structures:ref"/>
           <xs:attribute ref="structures:metadata"/>
           <xs:anyAttribute namespace="urn:us:gov:ic:ism urn:us:gov:ic:ntk" processContents="lax"/>
       </xs:complexType>
   
   </xs:schema>
   

Appendix C. Appinfo namespace

   <?xml version="1.0" encoding="US-ASCII"?>
   <xs:schema
       attributeFormDefault="qualified"
       targetNamespace="http://release.niem.gov/niem/appinfo/3.0/"
       version="1"
       xmlns:appinfo="http://release.niem.gov/niem/appinfo/3.0/"
       xmlns:xs="http://www.w3.org/2001/XMLSchema">
   
     <xs:annotation>
       <xs:documentation>The appinfo schema provides support for high level data model concepts and additional syntax to support the NIEM conceptual model and validation of NIEM-conformant instances.</xs:documentation>
     </xs:annotation>
   
     <xs:attribute name="deprecated">
       <xs:annotation>
         <xs:documentation>The Deprecated element provides a method for identifying schema components as being deprecated. A deprecated component is one that is provided, but the use of which is not recommended.</xs:documentation>
       </xs:annotation>
       <xs:simpleType>
         <xs:restriction base="xs:boolean">
           <xs:pattern value="true"/>
         </xs:restriction>
       </xs:simpleType>
     </xs:attribute>
   
     <xs:attribute name="appliesToTypes">
       <xs:annotation>
         <xs:documentation>The appliesToTypes attribute appears on the element declaration of a metadata element. It indicates a set of types to which the metadata element may be applied. The metadata element will also be applicable to any type that is derived from a listed type.</xs:documentation>
       </xs:annotation>
       <xs:simpleType>
         <xs:list itemType="xs:QName"/>
       </xs:simpleType>
     </xs:attribute>
   
     <xs:attribute name="appliesToElements">
       <xs:annotation>
         <xs:documentation>The appliesToElements attribute appears on the element declaration of a metadata element. It indicates a set of elements to which the metadata element may be applied. The metadata element will also be applicable to any element that is in the substitution group of a listed element.</xs:documentation>
       </xs:annotation>
       <xs:simpleType>
         <xs:list itemType="xs:QName"/>
       </xs:simpleType>
     </xs:attribute>
   
     <xs:attribute name="externalAdapterTypeIndicator">
       <xs:annotation>
         <xs:documentation>The externalAdapterTypeIndicator attribute indicates that a complex type is an external adapter type. An external adapter type is composed of elements and attributes from non-NIEM-conformant schemas.</xs:documentation>
       </xs:annotation>
       <xs:simpleType>
         <xs:restriction base="xs:boolean">
           <xs:pattern value="true"/>
         </xs:restriction>
       </xs:simpleType>
     </xs:attribute>
   
     <xs:attribute name="externalImportIndicator">
       <xs:annotation>
         <xs:documentation>The externalImportIndicator attribute is true if and only if a namespace identified via xs:import is expected to be non-conformant.</xs:documentation>
       </xs:annotation>
       <xs:simpleType>
         <xs:restriction base="xs:boolean">
           <xs:pattern value="true"/>
         </xs:restriction>
       </xs:simpleType>
     </xs:attribute>
   
   </xs:schema>
   

Appendix D. Local terminology namespace

   <?xml version="1.0" encoding="US-ASCII"?>
   <xs:schema
      elementFormDefault="qualified" 
      targetNamespace="http://release.niem.gov/niem/localTerminology/3.0/"
      version="1"
      xmlns:term="http://release.niem.gov/niem/localTerminology/3.0/"
      xmlns:xs="http://www.w3.org/2001/XMLSchema">
   
     <xs:element name="LocalTerm">
       <xs:complexType>
         <xs:sequence>
   	<xs:element name="SourceText" type="term:NonemptyStringSimpleType" 
                       minOccurs="0" maxOccurs="unbounded"/>
         </xs:sequence>
         <xs:attribute name="term" type="term:NonemptyStringSimpleType" use="required"/>
         <xs:attribute name="literal" type="term:NonemptyStringSimpleType"/>
         <xs:attribute name="definition" type="term:NonemptyStringSimpleType"/>
         <xs:attribute name="sourceURIs">
           <xs:simpleType>
             <xs:restriction>
               <xs:simpleType>
                 <xs:list itemType="xs:anyURI"/>
               </xs:simpleType>
               <xs:minLength value="1"/>
             </xs:restriction>
           </xs:simpleType>
         </xs:attribute>
       </xs:complexType>
     </xs:element>
   
     <xs:simpleType name="NonemptyStringSimpleType">
       <xs:restriction base="xs:string">
         <xs:minLength value="1"/>
       </xs:restriction>
     </xs:simpleType>
   
   </xs:schema>
   

Appendix E. Index of definitions

   The index of definitions is omitted from this edition.

Appendix F. Index

   The index is omitted from this edition.

