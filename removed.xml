<comment>
        <section>
          <title>Bases of Derived Components</title>
          <p>The <code>appinfo</code> namespace provides an annotation for indicating the base of a derived component. This is expressed via the <qName>appinfo:Base</qName> application information.</p>
          <rule applicability="REF EXT">
            <p>Within the schema, the element <qName>appinfo:Base</qName> MAY be used in one of the following ways:</p>
            <ol>
              <li><p>By a type definition, to indicate the base type, or <qName>structures:Object</qName> or <qName>structures:Association</qName>.</p></li>
              <li><p>By an element declaration, to indicate the base element.</p></li>
            </ol>
            <p>The element <qName>appinfo:Base</qName> SHALL NOT be used for any other purpose.</p>
          </rule>
            <p><strong>Rationale</strong></p>
            <p>The <qName>appinfo:Base</qName> element is required to clarify semantics of types as object or association types, when such derivation is not otherwise derivable from the component definitions.</p>
            <rule applicability="REF EXT">
              <p>Within the schema, the element <qName>appinfo:Base</qName> SHALL indicate, by namespace and name, one of the following:</p>
              <ol>
                <li><p>A NIEM-conformant schema component.</p></li>
                <li><p><qName>structures:Object</qName>.</p></li>
                <li><p><qName>structures:Association</qName>.</p></li>
              </ol>
            </rule>
            <rule applicability="REF EXT">
              <p>Within the schema, an attribute <qName>appinfo:namespace</qName> owned by an element <qName>appinfo:Base</qName> SHALL have a value of either of the following:</p>
              <ol>
                <li><p>A namespace which is the target namespace of a NIEM-conformant schema.</p></li>
                <li><p>The <code>structures</code> namespace.</p></li>              
              </ol>
            </rule>
            <rule applicability="REF EXT">
              <p>Within the schema, an element <qName>appinfo:Base</qName> that does not own an attribute <qName>appinfo:namespace</qName> SHALL refer to the target namespace of the schema in which it is used.</p>
            </rule>
            <rule applicability="REF EXT">
              <p>Within the schema, an element <qName>appinfo:Base</qName> SHALL own an attribute <qName>appinfo:name</qName>.</p>
            </rule>
            <rule applicability="REF EXT">
              <p>Within the schema, if an element <qName>appinfo:Base</qName> indicates a NIEM-conformant namespace, then the value of the attribute <qName>appinfo:name</qName> owned by the element <qName>appinfo:Base</qName> SHALL indicate a schema component in the indicated namespace.</p>
            </rule>
            <rule applicability="REF EXT">
              <p>Within the schema, if an element <qName>appinfo:Base</qName> indicates the <code>structures</code> namespace, then the value of the attribute <qName>appinfo:name</qName> owned by the element <qName>appinfo:Base</qName> SHALL have a value of one of the following:</p>
              <ol>
                <li><p><qName>structures:Object</qName>.</p></li>
                <li><p><qName>structures:Association</qName>.</p></li>
                <li><p>A schema component defined by the <code>structures</code> schema.</p></li>
              </ol>
            </rule>
            <p><strong>Rationale</strong></p>
            <p>Together, this set of rules establishes the element <qName>appinfo:Base</qName> as a reference to either a NIEM-conformant schema component or to a special NIEM component, which acts as the base for the containing schema component.</p>
        </section>
        </comment>

        <comment>
        <section>
          <title>Application of Constructs</title>
          <p>NIEM-conformant schemas provide capability for modeling beyond that provided by basic XML Schema. Two methods made available by NIEM are augmentations and metadata. Both of these methods create schema components that may be applied to types in specific ways. The applicability of these components to types is expressed with the <qName>appinfo:AppliesTo</qName> element.</p>
          <rule applicability="REF EXT">
            <p>Within the schema, the element <qName>appinfo:AppliesTo</qName> MAY be used in any of the following ways:</p>
            <ol>
              <li><p>To indicate a base type to which an augmentation may be applied.</p></li>
              <li><p>To indicate a base type to which a metadata type may be applied.</p></li>
            </ol>
            <p>The element <qName>appinfo:AppliesTo</qName> SHALL NOT be used for any other purpose.</p>
          </rule>
          <p><strong>Rationale</strong></p>
          <p>The <qName>appinfo:AppliesTo</qName> element is required to express constraints beyond those available within XML Schema. Use of this element allows advanced processing of instances and schemas for type safety.</p>
          <rule applicability="REF EXT">
            <p>Within the schema, the element <qName>appinfo:AppliesTo</qName> SHALL indicate a schema component by namespace and name.</p>
          </rule>
          <rule applicability="REF EXT">
            <p>Within the schema, an attribute <qName>appinfo:namespace</qName> owned by an element <qName>appinfo:AppliesTo</qName> SHALL indicate the namespace of the type to which <qName>appinfo:AppliesTo</qName> refers. The indicated namespace SHALL be defined by a NIEM-conformant schema.</p>
          </rule>
          <rule applicability="REF EXT">
            <p>Given that the element <qName>appinfo:AppliesTo</qName> refers to a type, the applicability described by the element SHALL be understood to be the indicated type or a type transitively derived from the indicated type.</p>
          </rule>
          <rule applicability="REF EXT">
            <p>Within the schema, an element <qName>appinfo:AppliesTo</qName> that does not carry an attribute <qName>appinfo:namespace</qName> SHALL refer to the target namespace of the schema in which it is used.</p>
          </rule>
          <rule applicability="REF EXT">
            <p>Within the schema, an element <qName>appinfo:AppliesTo</qName> SHALL carry an attribute <qName>appinfo:name</qName>. The value of this attribute SHALL indicate the local name of a schema component within the namespace specified by the element.</p>
          </rule>
          <p><strong>Rationale</strong></p>
          <p>Together, this set of rules establishes the element <qName>appinfo:AppliesTo</qName> as a reference to a NIEM-conformant schema component to which a NIEM construct may be applied.</p>
        </section>
        </comment>

        <comment>
        <section>
          <title>Targets of References</title>
          <p>NIEM provides references to avoid problems occurring when only XML element containment is available. The <qName>appinfo:ReferenceTarget</qName> element specifies the type to which a reference element may be applied.</p>
          <rule applicability="REF EXT">
            <p>Within the schema, the element <qName>appinfo:ReferenceTarget</qName> SHALL identify the XML Schema type definition of an element information item to which an instance of a reference element may validly refer. The element <qName>appinfo:ReferenceTarget</qName> SHALL NOT be used for any other purpose.</p>
          </rule>
          <p><strong>Rationale</strong></p>
          <p>This describes the meaning of a reference target. The term <em>type definition</em> is as used in <ref idref="XMLSchema-1"/>, in the PSVI (post-schema-validation infoset) definition for an element information item. The element <qName>appinfo:ReferenceTarget</qName> is required to express the type of referenced content. XML Schema does not provide this level of type safety.</p>
          <rule applicability="REF EXT">
            <p>Within the schema, a reference element MUST have at most one instance of the element <qName>appinfo:ReferenceTarget</qName>.</p>
          </rule>
          <p><strong>Rationale</strong></p>
          <p>Content elements in XML Schema may have at most one type. This rule ensures that reference elements follow the same pattern.</p>
          <rule applicability="REF EXT">
            <p>Within the schema, the element <qName>appinfo:ReferenceTarget</qName> SHALL indicate a type definition schema component, by namespace and name.</p>
          </rule>
          <rule applicability="REF EXT">
            <p>Within the schema, an attribute <qName>appinfo:namespace</qName> carried by an element <qName>appinfo:ReferenceTarget</qName> SHALL indicate the namespace of the referenced schema component. The indicated namespace SHALL be defined by a reference or extension schema.</p>
          </rule>
          <rule applicability="REF EXT">
            <p>Within the schema, an element <qName>appinfo:ReferenceTarget</qName> that does not carry an attribute <qName>appinfo:namespace</qName> SHALL refer to the target namespace of the schema in which it is used.</p>
          </rule>
          <rule applicability="REF EXT">
            <p>Within the schema, an element <qName>appinfo:ReferenceTarget</qName> SHALL carry an attribute <qName>appinfo:name</qName>. The value of this attribute SHALL indicate the local name of a type definition schema component within the namespace specified by the element.</p>
          </rule>
          <p><strong>Rationale</strong></p>
          <p>Together, this set of rules establishes the element <qName>appinfo:ReferenceTarget</qName> as a reference to a NIEM-conformant type definition schema component that a reference element instance may reference.</p>
        </section>
        </comment>

      <comment
         xmlns:xsl="example.org/xsl">
      <section>
        <title>Sequence ID</title>
        <p>NIEM provides the attribute <qName>structures:sequenceID</qName> for specification of sequential order of instances, when a complex type<char name="rsquo"/>s defined element sequence is insufficient. A limitation of XML Schema is that control of cardinality (the number of times an element may occur in an instance) requires the use of sequences of elements. This use of <qName>xs:sequence</qName> defines the elements occurring within a type in a specific order. This order may not match the desired sequential order of the represented entities.</p>
        <p>An example would be proper names, where the natural order of the names may not appear in the same order as the sequence defined by a complex type. In this case, the structure defined by <qName>nc:PersonNameType</qName> defines a sequence of name parts, including given name followed by surname. This works well enough for Western names:</p>
        <figure>
          <title>An instance of a name type</title>
          <pre><![CDATA[<nc:Person>
  <nc:PersonName>
    <nc:PersonGivenName>John</nc:PersonGivenName>
    <nc:PersonSurName>Doe</nc:PersonSurName>
  </nc:PersonName>
</nc:Person>]]></pre>
        </figure>
        <p>However, it does not work well for Chinese names, where the surname precedes the given name. For example, the basketball player Yao Ming has a given name of Ming and a surname of Yao. This cannot be expressed by the simple sequence used above because it lists the given name before the surname. To express the proper sequence of the data, use the <qName>structures:sequenceID</qName> attribute.</p>
        <figure>
          <title>An instance of a name type that uses <qName>structures:sequenceID</qName></title>
          <pre><![CDATA[<nc:Person>
  <nc:PersonName>
    <nc:PersonGivenName s:sequenceID="2">Ming</nc:PersonGivenName>
    <nc:PersonSurName s:sequenceID="1">Yao</nc:PersonSurName>
  </nc:PersonName>
</nc:Person>]]></pre>
        </figure>
        <p>Without the <qName>structures:sequenceID</qName> attribute, this example would create a dilemma: which name to represent correctly, and which to represent incorrectly? The <qName>structures:sequenceID</qName> attribute allows the schema sequence to be separated from the implied meaning.</p>
        <p>As another example, when using a derived type, within an instance, the base type<char name="rsquo"/>s elements occur first, followed by any elements added by extension. If those elements need to be interleaved into the existing structure for the proper meaning to be conveyed, the <qName>structures:sequenceID</qName> attribute is called for.</p>
        <p>The <qName>structures:sequenceID</qName> attribute allows instances to express the sequential order of data relative to a parent. The order of data is as yielded by the <qName>xsl:sort</qName> element, which is defined by XSLT, with data-type of <qName>xsl:number</qName>, and order of <code>ascending</code>. Content with identical <qName>structures:sequenceID</qName> values has undefined order.</p>
        <rule applicability="REF EXT">
          <p>Within the schema, a complex type definition SHALL include the attribute <qName>structures:sequenceID</qName> if the order of an occurrence of the type, within its parent, relative to its siblings, is meaningful and pertinent and if the schema does not specify the desired sequential order.</p>
        </rule>
        <p><strong>Rationale</strong></p>
        <p>This rule indicates that, if order is meaningful and the schema will not always represent the desired order, then data modelers need to include <qName>sequenceID</qName> to allow the proper order to be represented in instances.</p>
        <p>Rules on the use of <qName>sequenceID</qName> may be found in the rules on conformant instances in Section 8.4, Component Ordering.</p>
      </section>
      </comment>

